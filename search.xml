<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构之查找</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE/408DS-search/uncategorized/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE/408DS-search/uncategorized/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>小点：</strong></p><ul><li>查找是计算机中经常用到的一种操作，是指在数据集合中寻找满足某种条件的数据元素的过程。查找的过程与查找的结构<strong>（查找表）</strong>和查找的算法决定。根据是否可以修改查找表分为<strong>静态查找</strong>表和<strong>动态查找表</strong>。</li><li>查找是根据<strong>关键字</strong>进行的，至于数据的整体信息，可以通过指针指向。</li><li>判断查找效率的标准是平均查找长度**<em>ASL**</em>，可以分为<strong>成功ASL</strong>和<strong>失败ASL</strong>。        </li></ul></blockquote><h1 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>​        顺序查找是在线性表中从头到尾进行查找。有序的线性表查找成功的ASL为（n+1）/ 2，失败的ASL为（n+1）。</p><p>​        若线性表有序，则可以构建一棵顺序查找判定树。</p><p><img src="https://i.loli.net/2020/10/20/ABVd7Ii6Tmknf8e.png" alt="WeChatb8b442bca19fddec63ab85bd5738e73a.png"></p><p>​        对于查找判定树，计算ASL的方式是</p><ul><li>失败节点：数到失败节点经历的<strong>边数</strong></li><li>成功节点：数到成功节点经历的<strong>节点数</strong></li></ul><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>​        折半查找是算法题常考的点。算法的步骤就是<strong>先判断什么时候左移或者右移</strong>，再通过<strong>二分算法定位</strong>。</p><p>​        为了避免出现死循环，我们要记住二分法规则，<strong>左动左移，右动右移</strong>。下面是一种实现模版<code>while (l &lt; r)</code>版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;       <span class="comment">// 左移</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;           <span class="comment">// 左区间动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;    <span class="comment">// 右移</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;            <span class="comment">// 右区间动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当然，折半查找的<strong>ASL</strong>，也可以画出查找树进行计算。</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>​        分块查找又称索引顺序查找，将查找表分为若干子块，块内可以无序，但是块间必须有序。</p><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><p>​        树形结构是存储查找表的绝佳结构，由于树的高度是<em>log</em>级别，所以易于数据的查找和修改。</p><hr><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><blockquote><p>​        通过二叉平衡查找树，我们可以提高查找速度。但是，当数据量很大时，我们的索引二叉树需要保存在磁盘中时，每下降一层，就会读入一个磁盘快。频繁的I/O操作会极大地拖延时间，所以B-树可以让一个<strong>磁盘块多存几个关键字和指针信息</strong>，构成多路平衡查找树，提高了磁盘的I/O性能。</p></blockquote><p>​        B树又称<em>多路平衡查找树</em>，B数所有节点的最大孩子个数的最大值成为B树的阶，用<em>m</em>表示，一棵<em>m</em>叉B树满足：</p><ul><li>树节点最多有<em>m</em>个子树，包含最多<em>m - 1</em>个关键字</li><li>除了根节点，其他非叶节点至少有*(m + 1) / 2*棵子树。</li><li>每个非叶子结点中存储着<strong>关键字</strong>和指向下一层的节点的指针</li><li>叶子结点都在一个层次上，且<strong>不带信息</strong></li></ul><p><img src="https://i.loli.net/2020/10/20/nceaY789Q5IoZHM.png" alt="image.png"></p><h3 id="B树的高度（磁盘的存取次数）"><a href="#B树的高度（磁盘的存取次数）" class="headerlink" title="B树的高度（磁盘的存取次数）"></a>B树的高度（磁盘的存取次数）</h3><p>​        一般会计算最小高度和最大高度：</p><ul><li>最小高度：在每个节点都取最大关键字个数时</li><li>最大高度：在每个节点都取最小关键字个数时</li></ul><p><img src="https://i.loli.net/2020/10/20/z47EeIkuTXHRgwn.png" alt="WeChatcb65a1b84cb9e117c8599a298b770a0b.png"></p><h3 id="B数的查找"><a href="#B数的查找" class="headerlink" title="B数的查找"></a>B数的查找</h3><p>​        从根节点往下查找</p><ol><li>在B树中找节点：根据指针通过<strong>I/O</strong>操作将结点读入内存</li><li>在结点中找关键字：在内存中通过<strong>顺序查找</strong>或者<strong>折半查找</strong>等内部查找方式找关键词。</li></ol><h3 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h3><p>​        B树的插入都是在最底层非叶节点上，可能会产生溢出现象，需要及时<strong>分裂</strong>维持B树的结构。</p><p>​        B树的插入需要经历<strong>定位</strong>、<strong>插入</strong>和<strong>调整</strong>：</p><ul><li>定位：找到最底层非叶结点合适的位置</li><li>插入：插入到合适的位置</li><li>调整：插入后，观察是否结点产生了溢出（关键字个数超过<em>m - 1</em>），则需要结点<strong>向上</strong>分裂。</li></ul><p><img src="https://i.loli.net/2020/10/20/5NCVUZLtwrO6kGB.png" alt="WeChatc8b88ee24491c4f7d2174106824d2e7b.png"></p><h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3><p>​        B树的删除也可能出现结点关键字个数少于<em>（m + 1）/ 2</em> 的情况，需要<strong>合并</strong>维持B树结构。B树被删除关键字不在终端时，可以用删除他的前驱或者后继代替，最后转化为删除终端的某个节点。</p><p>​        删除终端节点的有三种情况：</p><ul><li>直接删除关键字：这时候删除不会影响结构</li><li>兄弟够借：兄弟可以借一个关键字来重新达到平衡</li><li>兄弟不够借：和兄弟，双亲一起组成一个结点，再调整少了一个结点的双亲</li></ul><p><img src="https://i.loli.net/2020/10/20/tEfJ1zo3nxL9Fpu.png" alt="WeChat933db3070b9bb2e6673ea95f1a4938d2.png"></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><blockquote><p>B树虽然解决了磁盘I/O问题，但是无法进行顺序遍历。B+树所有的<strong>叶子结点</strong>中包含了<strong>全部</strong>关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中<strong>仅含有其子树根结点中最大（或最小）关键字</strong>， (而B 树的非终节点也包含需要查找的有效信息)，所以还能进一步降低I/O次数。</p></blockquote><p>​        一颗<em>m</em>阶B+树满足：</p><ul><li>树节点最多有<em>m</em>个子树，包含最多<em>m</em>个关键字</li></ul><p>除了根节点，其他非叶节点至少有*(m + 1) / 2*棵子树。</p><ul><li>节点的子树个数和关键字个数相同。</li><li>所有<em>叶节点</em>包含<strong>全部关键字及指向相应记录的指针</strong>，叶节点按大小顺序排序且相互连接起来。</li><li>所有<em>分支节点</em>只包含子节点的<strong>最大（最小）关键字</strong>和指向子节点的指针。</li></ul><p><img src="https://i.loli.net/2020/10/20/QXKuHjEBJTbDUWa.jpg" alt="p.jpg"></p><h1 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h1><blockquote><p>散列查找通过某种<strong>散列函数</strong>在位置和记录关键字中建立关系，Hash(key) = Addr。当多个关键字映射到一个地址时，就产生了<strong>冲突</strong>。散列表是根据关键字直接进行访问的数据结构，建立了关键字和存储地址之间的映射关系。</p></blockquote><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>​        散列函数常用的有：</p><ul><li>直接定址法：**<em>H(key) = key 或者 H(key) = a ✖️key + b**</em></li><li>除留余数法：**<em>H(key) = key % p**</em>，<em>p</em>是不大于但是最接近散列表长度<em>m</em>的指数</li><li>数字分析法、平方去中法；</li></ul><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>​        当产生冲突时，需要为产生冲突的关键字找到下一个Hash地址，</p><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>​        所谓开放定址法就是散列表的空闲表项既可以向同义词表项开放，又向非同义词开放**<em>H = (H(key) + d) % m**</em>，根据<em>d</em>的取值可以分为：</p><ul><li>线性探测法：<em>d</em> = 0 ，1， 2， 3 …</li><li>平方探测法：<em>d</em> = 0，1，-1，4，-4，9，-9…</li><li>再散列法：*d = Hash_2(key)*，再通过一个散列函数来计算探测增量</li></ul><p><strong>注意</strong>：在开放定址法中，不能物理删除，只能通过打标记等逻辑删除方法。再定期进行物理删除。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><blockquote><p>通过临界表的方式来记录同义词。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法                          <span class="comment">// 和临界表的存储相似</span></span><br><span class="line">    <span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;   <span class="comment">// 保证不会出现负余数</span></span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法         </span><br><span class="line">    <span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU的两种设计方式</title>
      <link href="cpu%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/408-1/uncategorized/"/>
      <url>cpu%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/408-1/uncategorized/</url>
      
        <content type="html"><![CDATA[<h1 id="硬布线逻辑设计CPU"><a href="#硬布线逻辑设计CPU" class="headerlink" title="硬布线逻辑设计CPU"></a>硬布线逻辑设计CPU</h1><p>​        硬布线逻辑又称组合逻辑设计，通过指令操作码译码，直接发出各个周期的各种信号。硬布线逻辑的优点是逻辑清晰，执行速度快，缺点是线路结构复杂，也不规范，可更改性差。</p><p>​        设计组合逻辑CPU的主要步骤包括：</p><ul><li>分析指令系统，得出对数据通路的要求</li><li>为数据通路选择合适的组件</li><li>链接组件建立数据通路</li><li>分析每条指令的实现，已确定控制型号</li><li>集成控制信号，形成完整的控制逻辑</li></ul><hr><h2 id="硬布线逻辑逻辑"><a href="#硬布线逻辑逻辑" class="headerlink" title="硬布线逻辑逻辑"></a>硬布线逻辑逻辑</h2><p><img src="https://i.loli.net/2020/10/18/9eqwQARTrHsvfI5.png" alt="WeChatcf0a2bc7664665e29990d8241a7c04f5.png"></p><p>​        通过操作码，状态码进行逻辑运算，CU<strong>（控制单元）</strong>每个时钟周期发出一组控制信号，形成完整的控制逻辑。</p><h2 id="微操作的节拍安排"><a href="#微操作的节拍安排" class="headerlink" title="微操作的节拍安排"></a>微操作的节拍安排</h2><p>​        每个时钟周期一般包含几个微操作，往往有如下规则：</p><ul><li>有些微操作有先后顺序，必须严格遵守</li><li>能在一个时钟周期执行的微操作，尽量安排在一个时钟周期内</li></ul><h3 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h3><p>​        单周期处理器中，所有微操作都在一个时钟周期中。例如一下，一个简单的MIPS处理器，现在需要安排控制信号。</p><p><img src="https://i.loli.net/2020/10/18/v42HsRnYU81jcxd.png" alt="WeChatc0cc55c3c71d394a3ddde498765823f6.png"></p><p>​        先根据每条指令的要求，列出控制信号的汇总：</p><p><img src="https://i.loli.net/2020/10/18/pzA1ytwHLDVRIYc.png" alt="WeChatecdb30288da644a546eac51d2312c7c5.png"></p><p>​        我们可以根据控制信号的汇总，列出每个控制信号的逻辑表达式：</p><p>​        例如：<code>RegDst</code> = <code>add</code> + <code>sub</code> </p><h1 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h1><p>​        为了克服硬布线逻辑控制的缺点，微程序设计采用了类似存储程序的方法解决微操作序列的形成。一条机器指令包一个<strong>微程序</strong>，一个微程序包含若干<strong>微指令</strong>，一条微指令包含一个或几个<strong>微操作</strong>。微程序存储在<strong>控制存储器</strong>中。</p><hr><h2 id="微程序控制单元框图及工作原理"><a href="#微程序控制单元框图及工作原理" class="headerlink" title="微程序控制单元框图及工作原理"></a>微程序控制单元框图及工作原理</h2><p>​        采用微程序设计方法需要为每一条机器指令编写微程序，其中取址操作每条机器指令都是相同的。以下是控制存储器的基本组成。</p><p><img src="https://i.loli.net/2020/10/18/IJr8kC6hawcYPvf.png" alt="WX20201018-165255@2x.png"></p><pre><code>    ## 微指令的编码方式</code></pre><p>​        微程序的编码方式有以下三种</p><ol><li><p>直接编码控制方式</p><p>微指令的每一位代表一个微操作命令。每条指令需要包括所有控制位，所以很长，但是数量少</p></li><li><p>字段直接编码方式</p><p>将一组互斥的微操作放在一个字段内，通过对每个字段译码可以得到所有微操作。（需要留一个字码给什么都不操作）。</p></li><li><p>字段间接编码方式</p><p>一个字段的译码受到另一个字段的影响，进一步缩短了字长，但是削弱了并行控制的能力。</p></li></ol><p><img src="https://i.loli.net/2020/10/18/eatwLz6f2y8QNoP.png" alt="WeChat50727c1cd72c0b504ec50aed17432c48.png"></p><h2 id="微指令序列地址的形成"><a href="#微指令序列地址的形成" class="headerlink" title="微指令序列地址的形成"></a>微指令序列地址的形成</h2><ol><li>直接由微指令的下地址形成</li><li>机器指令的操作码形成</li><li>增量计数法（CMAR） + 1</li><li>分支转移</li><li>通过测试网络</li><li>由硬件产生微程序入口地址</li></ol><h2 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h2><p>​        微指令的格式与微指令的编码方式有关，通常分为<strong>水平型微指令</strong>和<strong>垂直型微指令</strong>。</p><ul><li>水平型微指令：以上的编码方式都是水平型微指令，特点是指令字长长，速度快，但是指令个数少，控制存储器呈现<strong>矮胖型</strong>。</li><li>垂直型微指令：类似于及其操作码的方式，由操作码规定操作方式，一条微指令有1～2个微命令，控制1～2种操作。控制存储器呈现<strong>高瘦型</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 设立自己的处理器</title>
      <link href="%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8/csapp-4/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/"/>
      <url>%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8/csapp-4/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="硬件控制语言"><a href="#硬件控制语言" class="headerlink" title="硬件控制语言"></a>硬件控制语言</h2><p>​        <strong>硬件描述语言（Hardware Description Language，HDL）</strong>可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。<strong>逻辑合成程序（Logic Synthesis）</strong>可以根据HDL的描述来生成有效的电路设计。所以从手工设计电路到合成生成的转变，就好像从手写汇编到高级语言的转变。</p><p>​        <strong>硬件控制语言（Hardware Control Language，HCL）只</strong>表达硬件设计的控制部分，只有有限的操作集合，也没有模块化，可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-hcl.pdf">这里</a>。</p><p>​        这么课开发了将HCL翻译成Verilog的工具，然后结合基本硬件单元的Verilog代码，就能产生HDL描述，由此就能合成实际能工作的微处理器了。可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-verilog.pdf">这里</a>。</p><h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>​        当前逻辑<code>1</code>是由1.0伏特左右的高电压表示，逻辑<code>0</code>是由0.0伏特左右的低电压表示。</p><p>​        实现一个数字系统主要有<strong>三个组成部分：</strong></p><ul><li>计算对位进行操作的函数的组合逻辑</li><li>存储位的存储器单元</li><li>控制存储器单元更新的时钟信号</li></ul><h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>​        当前逻辑<code>1</code>是由1.0伏特左右的高电压表示，逻辑<code>0</code>是由0.0伏特左右的低电压表示。</p><p>​        实现一个数字系统主要有<strong>三个组成部分：</strong></p><ul><li><p>计算对位进行操作的函数的组合逻辑</p></li><li><p>存储位的存储器单元</p></li><li><p>控制存储器单元更新的时钟信号</p><p>逻辑门是数字电路的<strong>基本计算单元</strong>。如下图所示</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459134690-ff754684-78ba-470a-b627-dc7dc9af50ed.jpg" alt="image"></p><p>​        其中第一行是布尔表达式，第二行是标准符号，第三行是HCL表达式。我们可以将AND和OR扩展到多个输入的版本。    </p><p>​        <strong>注意：</strong>1. 逻辑门只对单个位的值进行操作。2. 当一个门的输入发生变化时，输出会很快相应变化。</p><p>​        将很多逻辑门组合成一个实现某种功能的网，就能构成<strong>计算块（Computational block）</strong>，称为<strong>组合电路（Combinational Circuits）</strong>。想要构建有效的组合电路，有以下<strong>限制：</strong></p><ul><li><p>每个逻辑门的输入必须连接到以下其中之一：</p></li><li><ul><li>一个系统输入</li><li>某个存储器单元的输出</li><li>某个逻辑门的输出</li></ul></li><li><p>两个或多个逻辑门的输出不能连接在一起</p></li><li><p>网络不能形成回路</p></li></ul><p><strong>例1：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135037-648b2c9f-a4b0-479d-b565-e50935dda906.jpg" alt="image"></p><p>​        <strong>HCL表达式：</strong><code>bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</code></p><p>​        <strong>功能：</strong>用来判断输入<code>a</code>和<code>b</code>是否相同，结果保存在<code>eq</code>中。</p><p><strong>例2：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135096-748ed7f5-b7fc-421b-880b-a7e8fa4087da.jpg" alt="image"></p><p>​        <strong>HCL表达式：</strong><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></p><p>​        <strong>功能：</strong>该组合电路称为<strong>多路复用器（Multiplexor，MUX）</strong>， 当<code>s=1</code>时，<code>out</code>的值就是<code>a</code>的值；当<code>s=0</code>时，<code>out</code>值就是<code>b</code>的值。</p><p>​        <strong>HCL表达式和C语言逻辑表达式区别：</strong></p><ul><li><p><code>=</code>在HCL表达式中表示给表达式赋予的名字</p></li><li><p>组合电路中输出会持续相应输入的变化，而C语言只有在程序执行过程中遇到了才进行求职</p></li><li><p>逻辑门只允许对0和1进行操作，而C语言将0表示为FASLE，将其余任意值表示为TRUE</p></li><li><p>C语言中存在部分求值的特点，组合逻辑中不存在</p><p>​    以上HCL都是对单个位进行运算的，可以很容易对其进行扩展实现对数据<strong>字（Word）</strong>进行操作的电路。</p></li></ul><p><strong>例1：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135084-45b97dc7-f231-4a0b-adb9-75ff49f70f66.jpg" alt="image"></p><p>​        直接合并64个位级相等的组合电路，再加上一个逻辑与门，就能得到一个64位的字级相等组合电路。右边是对其的抽象，其中实线表示字级信号，虚线表示布尔信号。</p><p>​        为了简单，可以将所有字级信号都声明为int，不指定字的大小，则该组合电路可以由两个int类型的参数A和B构成的HCL表达式描述<code>bool Eq = (A == B);</code>。</p><p><strong>例2：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597459135004-df8cadeb-e9a0-4797-8432-ea603722ae83.jpeg" alt="image"></p><p>​        这是一个64位字级多路复用器电路。这里只产生了一次<code>!s</code>，可以减少需要的逻辑门数量。在HCL中，多路复用器函数可以用<strong>情况表达式（Case Expression）</strong>来描述</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  select1 : expr1;</span><br><span class="line">  select2 : expr2;</span><br><span class="line">  ...</span><br><span class="line">  selectk : exprk;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​        其中，<code>select</code>是布尔表达式，<code>expr</code>是字级表达式。</p><p>​        <strong>注意：</strong>1. 在HCL中，不要求不同的选择表达式之间是互斥的，但是实际的多路复用器的信号必须互斥。2. 选择表达式是<strong>顺序求值</strong>的，所以后续的选择表达式可以在之前的选择表达式的基础上进行简化。</p><p>​        右侧是字级多路复用器的抽象，根据HCL表达式可知，首先根据<code>s</code>的值来判断是否选择<code>A</code>，如果不选择，就一定会选择<code>B</code>。</p><p><strong>例3：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135030-f4998ae1-4045-4f68-aeae-8294453f4335.jpg" alt="image"></p><p>​        这是一个通过两个信号来控制的四路复用器。对应的HCL表达式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Out4 = [</span><br><span class="line">  !s1 &amp;&amp; !s2 : A; #<span class="number">00</span></span><br><span class="line">  !s1        : B; #<span class="number">01</span></span><br><span class="line">  !s2        : C; #<span class="number">10</span></span><br><span class="line">  <span class="number">1</span>          : D; #<span class="number">11</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​        而我们需要从两位<code>code</code>中提取出两个信号，可以通过相等测试：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code == <span class="number">2</span> || code == <span class="number">3</span>;</span><br><span class="line">bool s0 = code == <span class="number">1</span> || code == <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>​        也可以通过<strong>判断集合关系</strong>的方式，其通用格式为<code>iexpr in &#123;iexpr1, iexpr2, ..., iexprk&#125;</code>，所以可以表示为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code in &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">bool s0 = code in &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>​        比较重要的一个字级组合电路是<strong>算数/逻辑单元（ALU）</strong>，它包含3个输入：标号为A和B的两个数据输入，以及一个控制输入。根据控制输入的值来选择要对A和B进行的运算。如下图所示，是位Y86-64设计的ALU模型。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135014-f1e22695-71c5-44e5-9ee2-f08a9525904a.jpg" alt="image"></p><p>​        <strong>注意：</strong>组合电路值进行逻辑运算，不设计存储信息，当某个抽象能够存储信息，就不是组合电路。</p><h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>​        为了产生<strong>时序电路（Sequential Circuit）</strong>，即存在状态并且能在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。而这些存储设备是由同一个具有周期性信号的<strong>时钟</strong>控制的，决定什么时候将新值保存到存储器中。</p><p>​        主要有<strong>两类存储器设备：</strong></p><ul><li><p><strong>时钟寄存器（寄存器）：</strong>存储单个位或字，主要作为电路不同部分的组合逻辑之间的屏障。</p></li><li><p><strong>随机访问存储器（内存）：</strong>存储多个字，用地址来选择读写哪个字。<strong>包括：</strong></p></li><li><ul><li><strong>处理器的虚拟内存系统：</strong>通过操作系统对存储器进行抽象，使得处理器可以在很大的地址空间中访问，地址为虚拟内存的索引值。</li><li><strong>寄存器文件：</strong>是一个以寄存器标识符为地址，存储着对应程序寄存器值的随机访问存储器。在IA32或Y86-64处理器中，有15个程序寄存器（<code>%rax</code>~<code>%r14</code>）。</li></ul></li></ul><p>​        这里要注意区分机器级编程中的寄存器和硬件中的寄存器</p><ul><li><strong>硬件：</strong>寄存器指的是时钟寄存器，直接将它的输入和输出连接到电路的其他部分。这里称为硬件寄存器。</li><li><strong>机器级编程：</strong>寄存器代表的是存储在寄存器文件中的，CPU中少数可寻址的字，地址为寄存器标识符。这里称为程序寄存器。</li></ul><h4 id="硬件寄存器"><a href="#硬件寄存器" class="headerlink" title="硬件寄存器"></a>硬件寄存器</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459861451-6f692ec1-9e31-4ee7-890f-2b5a30c6322f.jpg" alt="image"></p><p>​        如上图所示，硬件寄存器大多数时候会保持在稳定状态x，产生的输出也是它当前的状态。当寄存器的输入发生改变时，寄存器的输出也不会马上变化，而是等时钟变成高电位时，才会将当前状态修改为输入值。由此将当前寄存器两侧的逻辑电路分隔开来。</p><p>​        Y86-64处理器会使用硬件寄存器老保存程序计数器（PC）、条件代码（CC）和程序状态（Stat）。</p><h4 id="寄存器文件"><a href="#寄存器文件" class="headerlink" title="寄存器文件"></a>寄存器文件</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459861504-bc5c7eb8-0da1-404a-9989-9946317463f0.jpg" alt="image"></p><p>​        寄存器文件包含两个读端口和一个写端口，意味着能读取两个程序寄存器的同时对第三个程序寄存器进行写操作。这里的地址就是程序寄存器标识符。<strong>（两读一写）</strong></p><p>​        寄存器文件的写入操作受时钟信号控制，只有当时钟为高电平时，才将<code>valW</code>中的值写入<code>dstw</code>指示的程序寄存器中。</p><h4 id="虚拟内存系统"><a href="#虚拟内存系统" class="headerlink" title="虚拟内存系统"></a>虚拟内存系统</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459861454-8340a5c3-9fce-41ff-b15c-db99d4f7193b.jpg" alt="image"></p><p>​        处理器用虚拟内存来保存程序数据。<code>read</code>和<code>write</code>是两个标志位，用来控制当前是要读还是写。包含通过逻辑电路实现的边界检查，如果地址超过虚拟内存地址空间，就会使得<code>error=1</code>。</p><p>​        虚拟内存的写入操作受时钟信号控制，只有当<code>write=1</code>并且时钟为高电平时，才会将<code>data in</code>的数据保存到对应地址的位置。</p><p>​        <strong>注意：</strong>向存储器（时钟寄存器、随机访问存储器）写入值时会受到时钟的控制，所以存在时序，而向存储器读取值时不受到时钟的控制，不存在时序，可以直接将其近似于逻辑电路，输入地址，一段延迟后，就会将值返回到输出中。</p><p><a href="https://www.yuque.com/office/yuque/0/2020/pdf/1413496/1597460297959-5f8f3ecf-1e0a-4ce7-b27c-263f692c543d.pdf?from=file:///Applications/%E8%AF%AD%E9%9B%80.app/Contents/Resources/app.asar/build/renderer/index.html?locale=zh-CN&isYuque=true&theme=1%23/editor">waside-hcl.pdf</a></p><h1 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h1><h2 id="Y86-64指令体系结构"><a href="#Y86-64指令体系结构" class="headerlink" title="Y86-64指令体系结构"></a>Y86-64指令体系结构</h2><h3 id="状态单元"><a href="#状态单元" class="headerlink" title="状态单元"></a>状态单元</h3><p>​        我们将每条指令会读取或修改处理器状态的部分称为<strong>程序员可见</strong>状态，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597460521723-6fbd90e0-837f-453f-b098-e72112229d24.jpg" alt="image"></p><ul><li><strong>程序寄存器RF：</strong>这里对x86-64的寄存器进行省略，降低复杂度。其中<code>%rsp</code>用于指示出栈、入栈、函数调用和返回地址。</li><li><strong>条件码CC：</strong>保存最近算数或逻辑指令造成的影响。</li><li><strong>程序计数器PC：</strong>保存当前正在执行的指令的地址。</li><li><strong>内存DEME：</strong>操作系统将物理内存抽象为一个单一的字节数组。</li><li><strong>程序状态Stat：</strong>表明当前程序运行的状态，取值如下图所示。当出现异常时，处理器会调用异常处理程序，这里为了简化，直接让处理器停止执行指令。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597460521578-a971fccb-a696-466b-88be-1724d92b294a.jpg" alt="image"></p><h3 id="Y86-64指令及其编码"><a href="#Y86-64指令及其编码" class="headerlink" title="Y86-64指令及其编码"></a>Y86-64指令及其编码</h3><p>​        指令集的设计要求字节编码要有唯一的解释。这里实现如下图所示的Y86-64指令集，左侧为汇编指令，右侧为指令对应的编码。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597461006623-f06d2893-2ec8-4f92-8cdc-f632d80785d3.jpeg" alt="image"></p><ul><li>传送指令分成了<code>rrmovq</code>、<code>irmovq</code>、<code>rmmovq</code>和<code>mrmovq</code>。其中第一个字母表示源，第二个字母表示目的，<code>r</code>寄存器、<code>i</code>立即数、<code>m</code>内存。这里为了简化，只支持基址和偏移量形式的内存引用。</li><li>整数操作指令<code>OPq</code>，包含<code>addq</code>、<code>subq</code>、<code>andq</code>和<code>xorq</code>。会设置条件码<code>ZF</code>、<code>SF</code>和<code>OF</code>。</li><li>跳转指令<code>jXX</code>，包括<code>jmp</code>、<code>jle</code>、<code>jl</code>、<code>je</code>、<code>jne</code>、<code>jge</code>和<code>jg</code>。这里<code>jXX</code>使用绝对地址。</li><li>条件传送指令<code>cmovXX</code>，包括<code>cmovle</code>、<code>cmovl</code>、<code>cmove</code>、<code>cmovne</code>、<code>cmovge</code>和<code>cmovg</code>。</li><li><code>call</code>使用绝对地址。</li><li><code>push</code>和<code>pop</code>是对栈的调整，<code>push %rsp</code>是先将<code>%rsp</code>的内容保存到栈中，再对<code>%rsp</code>减8；<code>pop %rsp</code>等价于<code>mrmovq (%rsp), %rsp</code>。</li><li><code>halt</code>指令停止指令的执行。</li></ul><p>​        我们将指令的高8位称为<strong>指令指示符</strong>，可以用来确定指令类型，其中高4位为<strong>代码部分</strong>，低4位为<strong>功能部分</strong>。代码部分能确定指令执行的步骤，而功能部分能确定ALU要进行什么运算以及确定条件码的组合，比如功能部分我<code>1</code>表示让ALU进行减法运算并设置对应的条件码，则整数操作指令会得到计算结果，分支指令和传送指令会根据条件码来确定是否跳转和传送。<code>OPq</code>、<code>jXX</code>和<code>cmovXX</code>的编码如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597461006553-c9d7e02a-e924-4129-b4e9-d1e0fa86b5b7.jpeg" alt="image"></p><p>​        <strong>对于指令操作数的编码：</strong></p><ul><li>当指令不包含操作数时，比如<code>ret</code>，只需要一个字节长度。</li><li>当指令包含寄存器作为操作数时，需要额外添加<strong>寄存器指示符字节</strong>，可以使用如下图所示的寄存器标识符，当只有一个寄存器操作数时，需要将另4个字节标识为<code>0xF</code>。此时需要两个字节长度。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597461006581-5339de63-82e0-48a9-8dbe-682817f52585.jpg" alt="image"></p><ul><li>当指令包含立即数、带偏移量的内存引用和目标地址，需要额外的8字节进行编码。</li></ul><p><strong>例：</strong><code>rmmovq %rsp, 0x123456789abcd(%rdx)</code>的编码</p><p>​        <code>rmmovq</code>的编码形式为</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1597461006651-3a02818f-e649-4e7f-89ef-48d6f68bddf7.png" alt="image"></p><p>​        其中，<code>%rsp</code>的寄存器标志符为<code>0x4</code>，<code>%rdx</code>的寄存器标志符为<code>0x2</code>。这里立即数不满足8字节，所以需要在其前面填充得到8字节，即<code>0x000123456789abcd</code>，由于采用小端法，所以要对字节顺序进行调整得到<code>cd ab 89 67 45 23 01 00</code>。最终将所有编码都拼接起来，得到<code>40 42 cd ab 89 67 45 23 01 00</code>。</p><h3 id="Y86-64程序例子"><a href="#Y86-64程序例子" class="headerlink" title="Y86-64程序例子"></a>Y86-64程序例子</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> *start, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1597462762924-6ac29e47-8145-4a49-ad51-1bf5087f0c30.png" alt="image.png"></p><p>​        这里可以通过汇编器YAS将其转变为可执行代码</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597462010337-4dfc21c1-754f-4359-ae1d-0a9decd824a7.jpeg" alt="image"></p><p>​        以上是Y86-64完整的汇编代码。其中以<code>.</code>开头的为<strong>汇编器伪指令（Assembler Directives）</strong>，用于让汇编器调整地址。<code>.pos address</code>表示从<code>address</code>处开始产生代码，如第2行的<code>.pos 0</code>表示从0开始产生代码，第<code>.pos 0x200</code>表示从<code>0x200</code>处开始产生栈。<code>.align 8</code>表示在8字节边界处对其。</p><p>​        这里实现了一个指令集模拟器YIS，可以模拟Y86-64机器代码程序的执行</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597462010275-a875301f-5ad3-48cb-be62-77019a860a64.jpeg" alt="image"></p><h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><h3 id="处理指令的阶段"><a href="#处理指令的阶段" class="headerlink" title="处理指令的阶段"></a>处理指令的阶段</h3><p>​        处理一条指令我们可以将其划分成若干个阶段：</p><ol><li><p><strong>取指（Fetch）：</strong>根据程序计数器PC从内存中读取指令字节。然后完成以下步骤</p></li><li><ol><li>从指令中提取出指令指示符字节，并且确定出指令代码（<code>icode</code>）和指令功能（<code>ifun</code>）</li><li>如果存在寄存器指示符，则从指令中确定两个寄存器标识符<code>rA</code>和<code>rB</code></li><li>如果存在常数字，则从指令中确定<code>ValC</code></li><li>根据指令指令长度以及指令地址，可确定下一条指令的地址<code>valP</code></li></ol></li><li><p><strong>译码（Decode）：</strong>如果存在<code>rA</code>和<code>rB</code>，则译码阶段会从寄存器文件中读取<code>rA</code>和<code>rB</code>的值<code>valA</code>和<code>valB</code>。对于<code>push</code>和<code>pop</code>指令，译码阶段还会从寄存器文件中读取<code>%rsp</code>的值。</p></li><li><p><strong>执行（Execute）：</strong>算术逻辑单元（ALU）会根据<code>ifun</code>的值执行对应的计算，得到结果<code>valE</code>，包括</p></li><li><ol><li>计算运算结果，会设置条件码的值，则条件传送和跳转指令会根据<code>ifun</code>来确定条件码组合，确定是否跳转或传送。</li><li>计算内存引用的有效地址</li><li>增加或减少栈指针</li></ol></li><li><p><strong>访存（Memory）：</strong>写入内存或从内存读取数据<code>valM</code>。</p></li><li><p><strong>写回（Write Back）：</strong>将结果写入寄存器文件中。</p></li><li><p><strong>更新PC（PC Update）：</strong>将PC更新为<code>valP</code>，使其指向下一条指令。</p><p>​    接下来将Y86-64的指令按照以上框架进行整理</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816665-282dfcca-1a3b-40ad-ac01-b5af158aaf38.jpeg" alt="image"></p><p>​        这里可以发现，相同<code>icode</code>具有相同的步骤，而相同的<code>ifun</code>在执行阶段具有相同的计算方式，比如<code>addq</code>、<code>jmp</code>和<code>rrmovq</code>的<code>ifun</code>都是0，所以都进行加法计算。</p><p><strong>注意：</strong><code>OPq</code>中会将<code>ifun</code>传入给ALU来确定<code>OP</code>的类型。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816847-757248f0-a5fa-406c-bad9-ac62b7918506.jpeg" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816892-161f9091-985e-40f9-a7a4-02695d8dc24f.jpeg" alt="image"></p><p><strong>注意：</strong><code>pop</code>在译码阶段读了两次栈顶指针的值，这是为了使后续流程和别的指令相似。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816871-b93b8d82-c4f5-4e90-87d1-7c4761e2f3b7.jpeg" alt="image"></p><p>​        这里都会对PC值进行修改，<code>jXX</code>在执行阶段会根据<code>ifun</code>和条件码来设置是否跳转<code>Cnd</code>。<code>call</code>需要将下一条指令的地址作为返回值存入栈中，并修改栈顶指针的值。<code>ret</code>需要从栈顶指针出获得返回地址，将其设置为PC，并且还要修改栈顶指针的值。</p><p>​        这里的每一行表示某个值的计算（比如<code>valP</code>）或者激活某个硬件单元（比如内存），我们列出这些计算和动作，其中增加了<code>valA</code>的源<code>srcA</code>、<code>valB</code>的源<code>srcB</code>、写入计算结果<code>valE</code>的寄存器<code>dstE</code>、写入内存值<code>valM</code>的寄存器<code>dstM</code>。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816932-19e9e99c-64b0-4a99-bc2c-12b29a79c065.jpeg" alt="image"></p><p>​        接下来将创建硬件设计来实现这6个阶段，并将其连接起来。</p><h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>​        我们可以得到顺序实现的SEQ抽象视图</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816660-a5b3cd8b-fc1c-4bf9-aab3-0700749b233d.jpg" alt="image"></p><ul><li><p>数据内存和指令内存都是在相同的内存空间中，只是根据不同的功能对其进行划分</p></li><li><p>寄存器文件包含两个读端口<code>A</code>和<code>B</code>，以及两个写端口<code>M</code>和<code>E</code>，分别接收来自内存的值<code>valM</code>以及ALU计算的结构<code>valE</code>。</p></li><li><p>PC更新的值可能来自于：下一条指令地址<code>valP</code>、来自内存的值<code>valM</code>、调用指令或跳转指令的目标地址<code>valC</code>。</p><p>​    更加详细的图如下所示</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816905-28be5ca2-2f21-457e-a5c8-118b6d6d877b.jpeg" alt="image"></p><ul><li>白色方框为时钟寄存器（程序计数器PC是唯一时钟寄存器）；蓝色方框为硬件单元，当做黑盒子而不关心细节设计；白色圆圈表示线路名字。</li><li>宽度为字长的数据使用粗线；宽度为字节或更窄的数据用细线；单个位的数据用虚线，主要表示控制值。</li><li>灰色圆角矩形表示控制逻辑块，能在不同硬件单元之间传递数据，以及操作这些硬件单元，使得对每个不同的指令执行指定的运算。是本章的重点，会给出对应的HCL表达式。</li></ul><p>​        SEQ的实现包括组合逻辑和两种存储器：时钟寄存器（程序计数器和条件码寄存器）和随机访问存储器（寄存器文件、指令内存和数据内存）。我们知道组合逻辑和存储器的读取是没有时序的，只要输入一给定，输出就会发生对应的变化。但是存储器的写入是受到时钟的控制的，只有当时钟为高电位时，才会将值写入存储器中。</p><p>​        所以涉及到写数据的存储器（程序计数器、条件码寄存器、寄存器文件和数据内存）就需要对时序进行明确的控制，才能控制好指令各阶段的执行顺序。为了保证每条指令执行的结果能和上一节中介绍的顺序执行的结果相同，我们要保证指令的计算<strong>不会回读</strong>，即处理器不需要为了完成一条指令的执行而去读取由该指令更新的状态。因为该指令更新的状态是写入数据，需要经过一个时钟周期，如果该指令需要读取更新过的状态，就需要空出一个时钟周期。</p><p>​        我们通过寄存器和内存的时钟控制，由此设计了上一节中的指令执行阶段，这样能够保证即使所有状态同时更新，也能等价于顺序执行各个阶段，也保证了能够在一个周期中完成一条指令。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816650-2ed57158-ca7b-4bbf-be91-9be91d6387ed.jpeg" alt="image"></p><p>​        如上图所示，每次时钟从低电平变为高电平时，就会执行一条指令。开始执行<code>addq %rdx, %rbx</code>时，在时钟周期起点①处，会在寄存器和内存中写入上一条指令计算的结果，此时逻辑电路（白色部分）还没开始计算，到了时钟周期结尾②处，会执行得到该条指令的结果，并且更新程序计数器指向下一条指令，但是由于时钟还处于低电平，所以还未写入内存和寄存器中。当开始执行<code>je dest</code>时，在时钟周期起点③处，由于时钟变为了高电平，所以会将<code>addq %rdx, %rbx</code>计算的结果写入寄存器和内存中，此时就会指向<code>je dest</code>指令，但是逻辑电路还没还是计算，到了时钟周期结尾④处时，就会计算得到该条指令的结果，但是还没写入内存和寄存器中。</p><h3 id="SEQ的HCL表达式"><a href="#SEQ的HCL表达式" class="headerlink" title="SEQ的HCL表达式"></a>SEQ的HCL表达式</h3><p>​        我们首先对指令进行编码</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816673-84f7a512-aa39-4cbe-9815-5da72fbba4cf.jpeg" alt="image"></p><h4 id="取址阶段"><a href="#取址阶段" class="headerlink" title="取址阶段"></a>取址阶段</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463817523-f4a92a47-b9e2-4af8-a481-f80b896aaede.jpg" alt="image"></p><p>​        该部分访问<strong>内存硬件单元</strong>。首先以PC作为第一个字节的地址，一次从内存中读取10个字节。灰色部分是我们需要确定的HCL表达式</p><ul><li><code>icode</code>为第一字节的高4位，当指令地址越界时，指令内存会返回<code>imem_error</code>信号，此时直接将其表示为<code>nop</code>指令，否则获得高4位值</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word icode = [</span><br><span class="line">  imem_error : INOP;</span><br><span class="line">  <span class="number">1</span>          : imem_icode;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li><code>ifun</code>为第一字节的低4位，当出现<code>imem_error</code>信号时，会使用默认功能码，否则获得低4位值</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word ifun = [</span><br><span class="line">  imem_error : FNONE;</span><br><span class="line">  <span class="number">1</span>          : imem_ifun;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li><code>instr_valid</code>表示是否为合法指令</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool instr_valid = icode in &#123;</span><br><span class="line">  INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>need_regids</code>表示该指令否包含寄存器指示符字节，如果指令不含有寄存器指示符字节，则会将其赋值为<code>0xFF</code>。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_regids = icode in &#123;</span><br><span class="line">  IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>need_valC</code>表示该指令是否含有常数字节</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_valC = icode in &#123;</span><br><span class="line">  IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PC增加器会根据PC值、<code>need_valC</code>和<code>need_regids</code>来确定<code>valP</code>值，则</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valP = PC+<span class="number">1</span>+need_regids+<span class="number">8</span>*need_valC</span><br></pre></td></tr></table></figure><h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><p>这两个阶段都涉及<strong>寄存器文件</strong>，会根据<code>icode</code>、条件信号<code>Cnd</code>、<code>rA</code>和<code>rB</code>来设置写入的目的和读取的源。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816702-91b90c6d-da3a-4a2f-be03-4424ad901c84.jpg" alt="image"></p><ul><li>写入的目的<code>dstE</code>和<code>dstM</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word dstE = [</span><br><span class="line">  icode in &#123;IRRMOVQ&#125; &amp;&amp; Cnd             : rB; #cmovXX指令，可以将其看成是rrmovq和条件信号Cnd的组合 </span><br><span class="line">  icode in &#123;IIRMOVQ, IOPQ&#125;              : rB;</span><br><span class="line">  icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP; #获取%rsp</span><br><span class="line">  <span class="number">1</span>                                     : RNONE;</span><br><span class="line">];</span><br><span class="line">word dstM = [</span><br><span class="line">  icode in &#123;IMRMOVQ, IPOPQ&#125; : rA;</span><br><span class="line">  <span class="number">1</span>                         : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>读取的源<code>srcA</code>和<code>srcB</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word srcA = [</span><br><span class="line">  icode in &#123;IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ&#125; : rA;</span><br><span class="line">  icode in &#123;IPOPQ, IRET&#125;                    : RRSP;</span><br><span class="line">  <span class="number">1</span>                                         : RNONE;</span><br><span class="line">];</span><br><span class="line">word srcB = [</span><br><span class="line">  icode in &#123;IOPQ, IRMMOVQ, IMRMOVQ&#125;     : rB;</span><br><span class="line">  icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP;</span><br><span class="line">  <span class="number">1</span>                                     : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>​        该部分包括<strong>ALU</strong>。该部分逻辑主要根据<code>icode</code>来设置进入ALU进行计算的两个数字<code>aluA</code>和<code>aluB</code>，会根据<code>ifun</code>来设置需要ALU进行的计算。其中根据<code>ifun</code>和条件码计算得到的条件信息<code>Cnd</code>是通过cond硬件模块。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816646-b86ed8f0-1c45-437a-bd54-45a22913e5d2.jpg" alt="image"></p><ul><li>进入ALU进行计算的两个值<code>aluA</code>和<code>aluB</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word aluA = [</span><br><span class="line">  icode in &#123;IRRMOVQ, IOPQ&#125;             : valA; #包含两个寄存器时，aluA为寄存器的值valA</span><br><span class="line">  icode in &#123;IIRMOVQ, IRMMOVQ, IMRMOVQ&#125; : valC; #当出现立即数、偏移量时，aluA为常数值</span><br><span class="line">  icode in &#123;ICALL, IPUSHQ&#125;             : -<span class="number">8</span>; #入栈需要将栈顶地址下移<span class="number">8</span>字节</span><br><span class="line">  icode in &#123;IRET, IPOPQ&#125;               : <span class="number">8</span>; #出栈需要将栈顶地址上移<span class="number">8</span>字节</span><br><span class="line">];</span><br><span class="line">word aluB = [</span><br><span class="line">  icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ&#125; : valB;</span><br><span class="line">  icode in &#123;IRRMOVQ, IIRMOVQ&#125;                                   : <span class="number">0</span>;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>设置ALU进行的函数<code>alufun</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word alufun = [</span><br><span class="line">  icode == IOPQ : ifun;</span><br><span class="line">  <span class="number">1</span>             : ALUADD;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>获得是否设置条件码<code>set_cc</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc = icode in &#123;IOPQ&#125;;</span><br></pre></td></tr></table></figure><h4 id="访存阶段"><a href="#访存阶段" class="headerlink" title="访存阶段"></a>访存阶段</h4><p>​        这部分包含<strong>数据内存</strong>，设计从从数据内存读写程序数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816748-ef2b1171-70b9-42da-a645-76be9888974e.jpg" alt="image"></p><ul><li>确定是从内存中读取数据还是写入数据</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool mem_read = icode in &#123;IMRMOVQ, IPOPQ, IRET&#125;;</span><br><span class="line">bool mem_write = icode in &#123;IRMMOVQ, IPUSHQ, ICALL&#125;;</span><br></pre></td></tr></table></figure><ul><li>获得内存地址<code>mem_addr</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem_addr = [</span><br><span class="line">  icode in &#123;IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ&#125; : valE; #IPUSHQ和ICALL设计栈地址计算，IRMMOVQ和IMRMOVQ设计内存引用计算，所以都是ALU的计算结果</span><br><span class="line">  icode in &#123;IPOPQ, IRET&#125;                     : valA; #这部分没涉及ALU计算</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>获得输入内存的数据<code>mem_data</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word mem_data = [</span><br><span class="line">  icode in &#123;IRMMOVQ, IPUSHQ&#125; : valA; #从寄存器获得值</span><br><span class="line">  icode == ICALL             : valP; #当调用函数时，会将返回地址写入内存中</span><br><span class="line">  #默认不写入任何信息</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li><strong>确定程序状态<code>Stat</code></strong></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Stat = [</span><br><span class="line">  imem_error || dmem_error: ASDR;</span><br><span class="line">  !instr_valid            : SINS;</span><br><span class="line">  icode == IHALT          : SHLT;</span><br><span class="line">  <span class="number">1</span>                       : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h4 id="更新PC阶段"><a href="#更新PC阶段" class="headerlink" title="更新PC阶段"></a>更新PC阶段</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816727-43b872a5-c97d-4a76-9405-875a8d516fe7.jpg" alt="image"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word new_pc = [</span><br><span class="line">  icode == ICALL       : valC; #调用函数时，会直接将PC更新为目标函数的地址</span><br><span class="line">  icode == IJXX &amp;&amp; Cnd : valC; #当条件跳转指令满足时，会跳转到目标地址</span><br><span class="line">  icode == IRET        : valM; #ret会从内存中读取返回地址，所以是valM</span><br><span class="line">  <span class="number">1</span>                    : valP; #默认为valP</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="SEQ性能"><a href="#SEQ性能" class="headerlink" title="SEQ性能"></a>SEQ性能</h3><p>​        我们通过将指令执行过程划分成了若干个阶段，使得我们能通过统一框架来描述各个指令执行的过程，也能进一步减少需要的硬件。但是由于每次时钟变为高电平时需要写入数据，使得需要在一个时间周期内完成所有步骤，所以我们要求时钟周期特别慢。</p><p>​        比如执行<code>ret</code>时，当前PC指向<code>ret</code>指令的地址，当时钟变为高电平时，我们需要在下一次时钟变为高电平之前，完成：两次从寄存器文件读取<code>%rsp</code>内容，通过ALU计算<code>%rsp</code>上移8字节的地址，根据<code>%rsp</code>从内存中获得返回地址，然后将新的<code>%rsp</code>值写回寄存器文件中（此时由于时钟还是低电平，所以还没有真实写入，只是设置为了值）。由此能够保证在下一个时钟变为高电平时，能够把正确的<code>%rsp</code>值写回寄存器文件中。</p><p>​        而且我们可以发现，指令执行的不同阶段是在处理器的不同硬件部分，所以完全可以让不同指令同时运行，只要求他们处于不同阶段，这也是下一章中流水线的主要思想。</p><h1 id="流水线实现"><a href="#流水线实现" class="headerlink" title="流水线实现"></a>流水线实现</h1><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><h3 id="流水线基本原理"><a href="#流水线基本原理" class="headerlink" title="流水线基本原理"></a>流水线基本原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594078776358-9b342cfd-7722-41e7-a5e6-77a1fce48cca.jpg" alt="image"></p><p>​        我们将从头到尾执行一条指令所需的时间称为<strong>延迟（Delay）</strong>，则这里延迟为320ps。我们将系统在单位时间内能执行的指令数目称为**吞吐量（Throughput）。<br><img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594078889094-d4ca63b1-2db3-4f51-a524-6948d249f5aa.svg" alt="image"></p><p>​        意味着一秒能执行3.12G条指令。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594078862266-ee665c12-8f12-49ed-82db-cdd2b87ceb8e.jpg" alt="image"></p><p>​        对于每个阶段，我们需要100ps的组合逻辑计算时间以及20ps加载到寄存器的时间，所以我们这里能将时钟周期设定为120ps。并且我们可以发现每过一个时钟周期就有一条指令完成，所以吞吐量变为了8.33GIPS，提高了2.67倍。但是每条指令需要经过3个时钟周期，所以延迟为360ps，变为原来的1.12倍。</p><p>​        所以<strong>流水线特点</strong>为：提高系统的吞吐量，但是会轻微增加延迟。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594078993527-c9f9728b-981b-4d32-b2a3-dd2a79d06089.jpeg" alt="image"></p><p>​        上图是其中一段时间详细过程。</p><ol><li>239ps时，<code>I2</code>经过组合逻辑A的计算到达寄存器A，<code>I1</code>经过组合逻辑B的计算到达寄存器B，此时时钟还处于低电平，则流水线寄存器还未读取组合逻辑计算的结果，还保持着原来的值。</li><li>241ps时，时钟已经变成高电平了，此时寄存器就会读取组合逻辑计算的结果，将其保存到寄存器中。则寄存器A保存<code>I2</code>在组合逻辑A中计算的结果，寄存器B保存<code>I1</code>在组合逻辑B中计算的结果。</li><li>300ps时，寄存器中的值已经输入到下一阶段的逻辑电路一段时间了，则该输入信号会以不同的速率在逻辑电路中传播，形成了图中所示的<strong>波阵面（Curved Wavafront）</strong>。</li><li>359ps时，又重复到了1中相似的状态。</li></ol><p>​        <strong>时钟周期的影响：</strong>时钟周期用来控制流水线寄存器的读取频率，用来将不同阶段分隔开来，互不干扰。如果时钟周期太快，组合逻辑的计算还未完成，就会使得非法的值保存到寄存器中。如果时钟周期太慢，不会导致计算错误，只是效率会比较低。</p><h3 id="流水线局限性"><a href="#流水线局限性" class="headerlink" title="流水线局限性"></a>流水线局限性</h3><h4 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h4><p>​        处理器中的某些硬件单元，比如ALU或内存，是无法划分成多个延迟较小的单元的，这使得我们划分的不同阶段的组合逻辑具有不同的延迟。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079372802-9d316417-dcff-4455-b9ae-f42dc024d223.jpeg" alt="image"></p><p>​        如上图所示，其中组合逻辑B需要150ps进行计算。由于整个系统共用一个时钟周期，为了保证组合逻辑B能在一个时钟周期内计算出正确结果，使得保存到流水线寄存器中，我们就需要将时钟周期设定为150+20=170ps，这使得系统吞吐量变为5.88GIPS，而运行一条指令需要的延迟为3*170=510ps。</p><p>​        <strong>注意：</strong>想要吞吐量最大，我们需要使得时钟周期尽可能小，而时钟周期受到最慢的组合逻辑的限制，所以我们可以将最大的组合逻辑的时间加上一个寄存器的时延作为时钟周期。想要延迟最小，就不使用流水线。</p><h4 id="流水线过深，收益下降"><a href="#流水线过深，收益下降" class="headerlink" title="流水线过深，收益下降"></a>流水线过深，收益下降</h4><p>​        我们将每个组合逻辑进一步划分成更小的部分，构建更深的流水线</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079486756-6ba66012-b252-4075-8497-6c67ac27eee2.jpeg" alt="image"></p><p>​        这里时钟周期变为70ps，则吞吐量为14.29GIPS。这里我们可以发现，虽然我们将组合逻辑分成了更小的单元，使得组合逻辑的时延缩小了两倍，但是吞吐量的性能并没有提升两倍。这是由于更深的流水线，会扩大寄存器时延的影响，在70ps的时钟周期中，寄存器的时延就占了28.6%，意味着更深的流水线的吞吐量会依赖于寄存器时延的性能。</p><h3 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h3><p>​        真实系统中，指令之间存在两种形式的相关：</p><ul><li><p><strong>数据相关</strong>：下一条指令会用到这条指令计算出来的结果</p></li><li><p><strong>控制相关</strong>：一条指令要确定下一条指令的位置</p></li></ul><p>​        这些相关可能会导致流水线产生计算错误，称为<strong>冒险（Hazard）</strong>，包括：<strong>数据冒险（Data Hazard）</strong>和<strong>控制冒险（Control Hazard）</strong>。</p><h2 id="Y86-64流水线实现"><a href="#Y86-64流水线实现" class="headerlink" title="Y86-64流水线实现"></a>Y86-64流水线实现</h2><h3 id="SEQ-和PIPE"><a href="#SEQ-和PIPE" class="headerlink" title="SEQ+和PIPE-"></a>SEQ+和PIPE-</h3><p>​        为了平衡一个流水线系统各个阶段的延迟，需要使用<strong>电路重定时（Circuit Retiming）</strong>在不改变逻辑行为的基础上，修改系统的状态表示。如下图所示，顺序实现的SEQ中，更新PC阶段是在时钟周期结束时才执行的，通过组合电路计算得到的<code>icode</code>、<code>Cnd</code>、<code>valC</code>、<code>valM</code>和<code>valP</code>通过组合电路计算得到新的PC，将其保存到PC的时钟寄存器中。但是这些值是在不同阶段中计算出来的，所以SEQ+新增了一系列状态寄存器来保存之前计算出来的结果，然后将更新PC阶段放到了时钟周期开始执行，这样在每个阶段时钟周期变成高电平时就会将该阶段计算出来的值保存到状态寄存器中，然后PC逻辑电路就能根据当前的状态寄存器的值来预测下一步的PC值。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594079905309-a95d82cd-dd0e-46ab-a6e2-35c0c200a7aa.jpg" alt="image"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079747281-ae93ddc1-32dd-4033-b7cc-67b544a8631c.jpeg" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079775213-83cebbab-a388-43ee-8de6-9a3ab84eec32.jpeg" alt="image"></p><p>​        SEQ与SEQ+对比，更新PC阶段移到了时钟周期开始</p><p>​        我们可以在各个阶段中加入流水线寄存器，并将信号重新排列来将SEQ+转换成初步的流水线处理器PIPE-，硬件结构如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594080040911-d1a087fd-2f45-4165-ad86-2b3a22fe472d.jpeg" alt="image"></p><ul><li>分别插入了5个流水线寄存器用来保存后续阶段所需的信号，编号为<code>F</code>、<code>D</code>、<code>E</code>、<code>M</code>和<code>W</code>。我们可以发现在<code>D</code>和<code>E</code>中都有<code>stat</code>信号，分别表示为<code>D_stat</code>和<code>E_stat</code>。在取指阶段和访存阶段都有通过逻辑计算得到<code>stat</code>信号，分别表示为<code>f_stat</code>和<code>m_stat</code>。</li><li>在SEQ+中，在译码阶段通过逻辑电路计算得到<code>dstE</code>和<code>dstM</code>，会直接将其连接到寄存器文件的写端口的地址输入，当计算出<code>valE</code>和<code>valM</code>时直接写回到对应寄存器中。但是<code>dstE</code>和<code>dstM</code>是在译码阶段计算出来的，而<code>valE</code>是在执行阶段计算得到，<code>valM</code>是在访存阶段获得的，在流水线系统PIPE-中各个阶段是相互独立的，当某条指令运行到写回阶段时，得到了<code>valE</code>和<code>valM</code>，但是当前的<code>dstE</code>和<code>dstM</code>是处于译码阶段的指令计算出来的，会出现错误，所以需要将<code>dstE</code>和<code>dstM</code>一直保存到后续的流水线寄存器中。<strong>通用规则：</strong>通过合并信号来减少寄存器状态和线路的数量。<strong>通用规则：</strong>我们要保存处于一个流水线阶段中的指令的所有信息。</li><li>我们可以发现，只有<code>call</code>指令需要将<code>valP</code>保存到内存中，即我们为了<code>call</code>指令需要将取指阶段得到的<code>valP</code>一直保存到后续的流水线寄存器中，直到访存阶段将其保存到内存中。但是我们发现<code>call</code>指令只使用<code>valB</code>保存<code>%rsp</code>的值，并不会使用<code>valA</code>，所以我们可以通过PIPE-中的<code>selectA</code>模块将<code>valP</code>保存到<code>valA</code>，由此就不需要保存<code>valP</code>了。同理条件跳转指令，当不选择跳转分支时，后面也需要<code>valP</code>，也可以将其保存到<code>valA</code>中，由此也不需要保存<code>valP</code>了。<strong>通用规则：</strong>我们要保存处于一个流水线阶段中的指令的所有信息。</li></ul><h3 id="处理控制相关"><a href="#处理控制相关" class="headerlink" title="处理控制相关"></a>处理控制相关</h3><p>​        对于<code>call</code>和<code>jmp</code>指令，下一条指令的地址就是<code>valC</code>，而除了条件分支和<code>ret</code>指令外，下一条指令的地址就是<code>valP</code>，这些指令不存在控制相关，使得流水线处理器能够每个时钟周期就处理一条指令。如果出现了条件分支，则需要该指令运行到执行阶段后才知道是否选择该分支，如果出现了<code>ret</code>指令，则需要该指令运行到访存阶段，才知道返回地址，此时就存在了控制相关，使得处理器要经过几个时钟周期才知道要运行的下一条指令的地址，所以<strong>控制冒险只会出现在**</strong>条件分支**<strong>和**</strong><code>ret</code>指令**<strong>中</strong>，我们可以通过预测下一条PC来处理这个问题。</p><ul><li><p><strong>条件分支：</strong>我们可以通过<strong>分支预测</strong>技术来预测分支方向，并根据预测开始取值。常见的技术包括：</p></li><li><ul><li><strong>总是选择（always taken，AT）：</strong>总是预测处理器选择了条件分支，因此预测PC值为<code>valC</code>，成功率大约为60%。</li><li><strong>从不选择（never taken，NT）：</strong>总是预测处理器不选择条件分支，因此预测PC值为<code>valP</code>，成功率大约为40%。</li><li><strong>反向选择、正向不选择（backward taken, forward not-taken，BTFNT）：</strong>条件分支通常用于循环操作，当跳转地址比下一条指令地址小，说明进入了循环，否则退出循环，而循环通常会执行多次，因此当跳转地址比下一条指令地址低就选择分支，否则就不选择分支， 成功率大约为65%。</li></ul></li><li><p><code>ret</code>指令：常见的技术包括</p></li><li><ul><li>暂停处理新指令，直到<code>ret</code>指令通过写回阶段知道下一条指令的地址</li><li>在取指单元中放入一个硬件栈，保存过程调用指令产生的返回地址</li></ul></li></ul><p>​        当预测PC出现错误时出现控制冒险，会执行错误的指令，所以会极大影响流水线处理器的性能，后面再讨论这个问题。</p><p>​        在本文中，条件分支使用AT策略，<code>ret</code>指令使用第一条策略。从PIPE-硬件结构中可知，在取值阶段首先根据<code>icode</code>从<code>valP</code>和<code>valC</code>中选出预测的PC值，对于<code>call</code>和分支使用<code>valC</code>，其他指令使用<code>valP</code>。然后<code>Select PC</code>逻辑电路再从<code>predPC</code>、<code>M_valA</code>和<code>W_valM</code>中进行选择。我们推测为什么是这样的</p><ul><li><strong>条件分支：</strong>首先条件分支在取指阶段会直接选择条件分支，使得<code>predPC</code>为<code>valC</code>，则当条件分支执行到译码阶段时，<code>valC</code>对应的指令就会在取指阶段开始执行。当条件分支执行到执行阶段时，可以通过<code>CC</code>知道是否真的要选择条件分支，如果真的选择分支，则继续执行，否则条件分支的下一条指令地址应该是<code>valP</code>，此时该条件分支对应的<code>valP</code>保存在<code>M_valA</code>中，所以可以让<code>Select PC</code>选择<code>M_valA</code>来重新执行条件分支的部分。</li><li><strong><code>ret</code>指令：</strong>当执行<code>ret</code>指令时，会暂停传入新的指令，知道<code>ret</code>指令执行到访存阶段时，才从内存中读取了下一条指令的返回地址，保存在<code>W_valM</code>中，所以<code>Select PC</code>可以选择<code>W_valM</code>来执行返回地址对应的指令。</li></ul><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>​        流水线冒险主要包含数据冒险和控制冒险，当程序状态的读写<strong>不处于同一阶段</strong>，就可能出现数据冒险，当出现分支预测错误或<code>ret</code>指令时，会出现控制冒险。</p><p>​        程序寄存器的读取处于译码阶段，而写入处于写回阶段，因此程序寄存器会出现数据冒险的可能。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594081587950-ad6e1798-fb62-4f42-b4fd-6cdc55bf909d.jpeg" alt="image"></p><p>​        我们在代码中插入了<strong>三行<code>nop</code>指令</strong>，则当<code>addq %rdx, %rax</code>处于译码阶段读取寄存器时，第一行和第二行指令已经完成了对寄存器<code>%rdx</code>和<code>%rax</code>的写入操作，因此该代码不会出现数据冒险，但是如果减少<code>nop</code>指令，第一行和第二行指令还没完成对寄存器的写入操作时，<code>addq %rdx, %rax</code>已经处于译码阶段读取寄存器了，此时就会读取到错误的值而出现数据冒险。由于读取操作和写入操作相差3个时钟周期，所以如果一条指令的操作数被它前面三条指令中的任何一条修改时，就会出现数据冒险。</p><p>​        而内存的读写都处于访存阶段、条件码寄存器的读写都处于执行阶段因此它们不会出现数据冒险的情况，而我们为每个阶段都在流水线寄存器中保留了stat值，所以当异常发生时，处理器就能有条理地停止。</p><p>​        所以这里我们主要探讨程序寄存器数据冒险和控制冒险。</p><h4 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h4><p>​        我们可以在执行阶段中插入一段自动产生的<code>nop</code>指令，来保持寄存器、内存、条件码和程序状态不变，使得当前指令停在译码阶段，并且会控制程序计数器不变，使得下一条指令停在取指阶段，直到产生指令的源操作数的指令通过了写回阶段。（相当于产生类似上图的指令序列）</p><p>​        该方法指令要停顿最少一个最多三个时钟周期，严重降低整体的吞吐量。</p><h4 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h4><p>​        对于以下代码我们可以发现，<code>I1</code>处于访存阶段而<code>I2</code>处于执行阶段，都还没有将<code>valE</code>保存在<code>%rdx</code>和<code>%rax</code>中，所以<code>I3</code>的译码阶段无法从寄存器文件中读取到正确的<code>%rax</code>和<code>%rdx</code>。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594082041108-51f4ddc7-23d4-49ac-8997-740ac1df8e2f.jpg" alt="image"></p><p>​        但是即使还没有将<code>valE</code>保存到对应的寄存器文件中，其实<code>I1</code>在执行阶段已经将<code>%rdx</code>的值保存到流水线寄存器M中<code>M_valE</code>，而<code>I2</code>在执行阶段通过ALU计算得到了<code>%rax</code>的值<code>e_valE</code>，所以即使没有写入对应的寄存器文件中，已经能从<code>M_valE</code>和<code>e_valE</code>得到<code>%rax</code>和<code>%rbx</code>的值了</p><p>​        所以<code>I3</code>的译码阶段可以从以下形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA &#x3D; R[%rdx]</span><br><span class="line">valB &#x3D; R[%rax]</span><br></pre></td></tr></table></figure><p>​        变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA &#x3D; M_valE</span><br><span class="line">valB &#x3D; e_valE</span><br></pre></td></tr></table></figure><p>​        此时就不存在数据冒险，以及暂停了。</p><p>​        除了通过ALU的计算结果来转发，还能通过内存来进行转发，并且通过当前阶段的<code>dstE</code>和<code>dstM</code>与目标指令的<code>srcA</code>和<code>srcB</code>进行判断来决定是否转发。在处理器中，<code>valA</code>和<code>valB</code>一共有5个转发源：</p><ul><li><p><code>e_valE</code>：在执行阶段，ALU中计算得到的结果<code>valE</code>，通过<code>E_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令相邻需要访问非内存读取到寄存器寄存器的情况）</strong></p></li><li><p><code>M_valE</code>：将ALU计算的结果<code>valE</code>保存到流水线寄存器M中，通过<code>M_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空一个需要访问非内存读取到寄存器的寄存器的情况）</strong></p></li><li><p><code>m_valM</code>：在访存阶段，从内存中读取的值<code>valM</code>，通过<code>M_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空一个需要访问内存中读取到寄存器的寄存器的情况）</strong></p></li><li><p><code>W_valM</code>：将内存中的值<code>valM</code>保存到流水线寄存器W中，通过<code>W_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空两个需要访问内存中读取到寄存器的寄存器的情况）</strong></p></li><li><p><code>W_valE</code> ：将ALU计算的结果<code>valE</code>保存到流水线寄存器W中，通过<code>W_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空两个需要访问非内存读取到寄存器的寄存器的情况）</strong></p><p>​    数据转发需要在基本的PIPE-的硬件结构基础上增加一些额外的数据连接和控制逻辑，则PIPE的硬件结构如下图所示</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594082330068-06001aea-a9fd-4be0-a5de-c70779ae9fcb.jpeg" alt="image"></p><h4 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h4><p>​        <code>%rbx</code>的值通过转发技术可以从<code>M_valE</code>中获得，但是<code>%rax</code>的值需要<code>0x028</code>指令执行到访存阶段，才能从内存中读取到<code>%rax</code>的值，但是当前<code>0x028</code>指令处于执行阶段，所以无法通过转发技术来解决这个数据冒险。<strong>（两条指令相邻需要访问从内存读取到寄存器寄存器的情况）</strong></p><p>​        我们可以通过<strong>加载互锁（Load Interlock）</strong>方法来处理这种加载/使用数据冒险，其实就是引入了暂停，如下图所示，当<code>0x032</code>指令执行到译码阶段时，对该指令暂停一个时钟周期，此时<code>0x028</code>指令就能执行到访存阶段，此时就能从<code>m_valM</code>中获得<code>%rax</code>的值。</p><p>​        <strong>结合加载互锁和转发技术足以解决所有类型的数据冒险</strong>，并且对模型的吞吐量不会造成很大的影响。</p><h4 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h4><p>​        控制冒险只会出现在<code>ret</code>指令和跳转指令预测错方向时产生。</p><ul><li><code>ret</code>指令</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594083235880-a5ebcb1f-e832-4e69-8d1d-1133c75dccab.jpg" alt="image"></p><p>​        对于以上代码，对应的流水线图为</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083235859-68c9327e-9c37-468c-b66b-ba5aed8ddc4b.jpeg" alt="image"></p><p>​        可以发现，当执行<code>call proc</code>时，在取指阶段就能获得<code>valC</code>表示下一条指令的地址，所以会取到<code>ret</code>指令。而<code>ret</code>指令只有运行到访存阶段时才能获得返回地址<code>valM</code>，并且在写回阶段的时钟电平变高时，才会写入PC寄存器中，所以需要在<code>ret</code>指令后添加3个bubble。</p><ul><li>跳转指令</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083260527-b35c2ca5-3143-433a-a561-11ca27386ae0.jpeg" alt="image"></p><p>​        对于以上代码，对应的流水线图为</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083260542-c187d378-3bc0-4a6e-ba2b-eb87651ed09d.jpeg" alt="image"></p><p>​        首先对于跳转分支，我们采用AT策略，所以在执行<code>jne target</code>的取指阶段时获得的<code>valC</code>会直接作为下一条指令的地址。当跳转指令运行执行阶段时，就会通过<code>CC</code>和<code>ifun</code>得知是否预测正确，此时已经将下一条指令运行到译码阶段，第二条指令运行到了取指阶段，如果预测错误，就会分别插入两个bubble，避免运行到后续阶段，改变程序员可见状态，会浪费两个时钟周期。（相当于两个bubble）</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​        异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。当前的ISA包含三种内部产生的异常：1. halt指令；2. 非法指令码和功能码组合的指令；3. 取值或数据读写访问非法地址。外部产生的异常包括：接收到一个网络接口受到新包的信号、点击鼠标的信号等等。</p><p>​        在我们的ISA中，希望处理器遇到异常时，会停止并设置适当的状态码。<strong>要求：</strong>异常指令之前的所有指令已经完成，后续的指令都不能修改条件码寄存器和内存。流水线系统包含以下问题：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594083506935-d4896daf-77f0-4345-943b-c2097071acc4.jpg" alt="image"></p><ol><li>当同时多条指令引起异常时，处理器应该向操作系统报告哪个异常？<strong>基本原则：</strong>由流水线中最深的指令引起的异常，优先级最高，因为指令在流水线中越深的阶段，表示该指令越早执行。</li><li>在分支预测中，当预测分支中出现了异常，而后由于预测错误而取消该指令时，需要取消异常。</li></ol><p>在PIPE硬件架构中，我们对每个流水线寄存器中都设置了一个<code>stat</code>信号，用来保存当前阶段的异常信号，随着流水线的进行，就能解决以上问题：</p><ol><li><code>stat</code>信号只是简单存放在流水线寄存器的状态字段中，不会对流水线中的指令流有任何影响，保证了异常指令之前的指令都能完成，但是要<strong>禁止流水线中后面的指令不能更新条件码寄存器和内存</strong>。</li><li>当出现异常的指令到达写回阶段时，由于流水线中的指令是顺序执行的，所以能保证当前异常是最早出现的异常。</li><li>当条件分支预测错误时，直接取消该指令后，<code>stat</code>信号就不会保存下去了。</li><li>最终流水线寄存器W中的<code>stat</code>信号会被记录为程序状态。</li></ol><h2 id="PIPE的HCL代码"><a href="#PIPE的HCL代码" class="headerlink" title="PIPE的HCL代码"></a>PIPE的HCL代码</h2><p>​        从各个逻辑块开始设置</p><h3 id="PC选择和取指阶段"><a href="#PC选择和取指阶段" class="headerlink" title="PC选择和取指阶段"></a>PC选择和取指阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083933704-b0003a5f-c160-449f-b4fb-60d5d22c1c4a.jpeg" alt="image"></p><p>​        当前阶段需要完成选择程序计数器的值，并且预测下一个PC值。</p><p>​        预测PC值时，对于<code>call</code>指令时，会直接将<code>valC</code>作为下一个PC值，对于条件分支指令，我们选择AT策略，所以也会直接将<code>valC</code>作为下一个PC值，其他除了<code>ret</code>指令外，都是使用<code>valP</code>作为下一个PC值。在图中为<code>Predict PC</code>模块，对应的HCL代码为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word f_predPC = [</span><br><span class="line">  f_icode in &#123;IJXX, ICALL&#125; : f_valC;</span><br><span class="line">  <span class="number">1</span>                        : f_valP;</span><br><span class="line">];<span class="comment">//预测分支</span></span><br></pre></td></tr></table></figure><p>​        <strong>注意：</strong>这里需要用前缀表明使用了哪个阶段的值，比如<code>f_valC</code>表示使用了取指阶段中计算出来的<code>valC</code>，如果是<code>D_valC</code>表示保存在流水线寄存器D中的<code>valC</code>值。</p><p>​        选择PC值时主要分以下三种情况：</p><ol><li>当条件分支运行到执行阶段时，会知道是否出现预测错误，如果出现预测错误，则需要将PC值设置为<code>valP</code>值，而当前的<code>valP</code>值保存在<code>M_valA</code>中</li><li>当出现<code>ret</code>指令时，会暂停后续指令，直到<code>ret</code>指令运行到访存阶段时，从内存读取出了返回地址才是PC值，而当前返回地址保存在<code>W_valM</code>中</li><li>对于其他指令，直接使用预测的PC值<code>F_predPC</code>就行了</li></ol><p><strong>注意：</strong><code>f_predPC</code>表示当前阶段预测的下一个PC值，而<code>F_predPC</code>表示前一条指令预测的当前指令的PC值。</p><p>​        在图中为<code>Select PC</code>模块，对应的HCL代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word f_pc = [</span><br><span class="line">  #通过M_icode知道是否为条件分支指令，并且在执行阶段会根据ifun和计算结果设置信号Cnd</span><br><span class="line">  M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">  #通过W_icode知道是否为ret指令</span><br><span class="line">  W_icode == IRET           : W_valM;</span><br><span class="line">  #默认</span><br><span class="line">  <span class="number">1</span>                         : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>​        其他部分和SEQ的HCL代码类似</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#确定指令的icode</span><br><span class="line">word f_icode = [</span><br><span class="line">  imem_error : INOP;</span><br><span class="line">  <span class="number">1</span>          : imem_icode;</span><br><span class="line">];</span><br><span class="line">#确定指令的ifun</span><br><span class="line">word f_ifun = [</span><br><span class="line">  imem_error :INOP;</span><br><span class="line">  <span class="number">1</span>          : imem_ifun;</span><br><span class="line">];</span><br><span class="line">#判断指令是否合法</span><br><span class="line">bool instr_valid = f_icode in&#123;</span><br><span class="line">  INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ</span><br><span class="line">&#125;;</span><br><span class="line">#判断取指阶段的状态</span><br><span class="line">word f_stat = [</span><br><span class="line">  imem_error       : SADR;</span><br><span class="line">  !instr_valid     : SINS;</span><br><span class="line">  f_icode == IHALT : SHLT;</span><br><span class="line">  <span class="number">1</span>                : SAOK;</span><br><span class="line">];</span><br><span class="line">#判断是否需要寄存器</span><br><span class="line">bool need_regids = f_icode in &#123;</span><br><span class="line">  IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ </span><br><span class="line">&#125;;</span><br><span class="line">#判断是否包含valC</span><br><span class="line">bool need_valC = f_icode in &#123;</span><br><span class="line">  IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="译码和写回阶段-1"><a href="#译码和写回阶段-1" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594084455733-e47fefd8-f5bf-4418-a1ae-e4ce0863fcbe.jpeg" alt="image"></p><p>在译码阶段，比较复杂的逻辑单元与转发逻辑和合并信号相关</p><ul><li><strong>合并信号：</strong>我们可以发现只有<code>call</code>指令和条件跳转指令在后面阶段需要<code>valP</code>，前者用于压入栈中，后者用于预测错误时跳回，并且该两种指令都不需要从寄存器文件A端口读取数据，所以对于这两种指令，可以将<code>valA</code>的值设置为<code>valP</code>的值，减少流水线寄存器需要保存的信号。</li><li><strong>转发逻辑：</strong>由于对寄存器文件的读写不在同一阶段，所以可能会造成数据冒险，可以直接使用流水线寄存器中保存的或者每个阶段中计算出来的值，而无需要求从寄存器文件中读取。一共包含5中转发源：<code>e_valE</code>、<code>m_valM</code>、<code>M_valE</code>、<code>W_valM</code>和<code>W_valE</code>，为了保证能读取到最新指令的结果，应该设置转发源满足从左到右依次降低的优先级。</li></ul><p>由此我们可以完成译码阶段的HCL代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#设置从寄存器文件中读取的源</span><br><span class="line">word d_srcA &#x3D; [</span><br><span class="line">  D_icode in &#123;IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ&#125; : D_rA; #这些指令需要从寄存器rA中读取数据</span><br><span class="line">  D_icode in &#123;IPOPQ, IRET&#125;                    : RRSP; #需要设置栈顶指针，所以需要读取栈值</span><br><span class="line">  1                                           : RNONE;</span><br><span class="line">];</span><br><span class="line">word d_srcB &#x3D; [</span><br><span class="line">  D_icode in &#123;IOPQ, IRMMOVQ, IMRMOVQ&#125;     : D_rB; #从内存中读取时需要从寄存器中读取偏移量</span><br><span class="line">  D_icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP;</span><br><span class="line">  1                                       : RNONE;</span><br><span class="line">];</span><br><span class="line">#设置写入寄存器文件的目的</span><br><span class="line">#注意：在译码阶段并不会进行写入，只是先计算出当前指令需要的目的寄存器地址，保存到流水线寄存器中，而后在写回阶段才使用</span><br><span class="line">word d_dstE &#x3D; [</span><br><span class="line">  D_icode in &#123;IRRMOVQ, IIRMOVQ, IOPQ&#125;     : D_rB;</span><br><span class="line">  D_icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP;</span><br><span class="line">  1                                       : RNONE;</span><br><span class="line">];</span><br><span class="line">word d_dstM &#x3D; [</span><br><span class="line">  D_icode in &#123;IMRMOVQ, IPOPQ&#125; : D_rA;</span><br><span class="line">  1                           : RNONE;</span><br><span class="line">];</span><br><span class="line">#通过合并信息和转发机制设置valA的值</span><br><span class="line">word d_valA &#x3D; [</span><br><span class="line">  #合并信息</span><br><span class="line">  D_icode in &#123;ICALL, IJXX&#125; : D_valP;</span><br><span class="line">  #按照转发源的优先级设置转发源</span><br><span class="line">  d_srcA &#x3D;&#x3D; e_dstE         : e_valE;</span><br><span class="line">  d_srcA &#x3D;&#x3D; M_dstM         : m_valM;</span><br><span class="line">  d_srcA &#x3D;&#x3D; M_dstE         : M_valE;</span><br><span class="line">  d_srcA &#x3D;&#x3D; W_dstM         : W_valM;</span><br><span class="line">  d_srcA &#x3D;&#x3D; W_dstE         : W_valE;</span><br><span class="line">  #默认都是从寄存器文件中读取的</span><br><span class="line">  1                        : d_rvalA;</span><br><span class="line">];</span><br><span class="line">#通过转发机制设置valB的值</span><br><span class="line">word d_valB &#x3D; [</span><br><span class="line">  d_srcB &#x3D;&#x3D; e_dstE         : e_valE;</span><br><span class="line">  d_srcB &#x3D;&#x3D; M_dstM         : m_valM;</span><br><span class="line">  d_srcB &#x3D;&#x3D; M_dstE         : M_valE;</span><br><span class="line">  d_srcB &#x3D;&#x3D; W_dstM         : W_valM;</span><br><span class="line">  d_srcB &#x3D;&#x3D; W_dstE         : W_valE;</span><br><span class="line">  1                        : d_rvalB;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在写回阶段时，我们要写入的寄存器文件目的是<code>W_dstE</code>和<code>W_dstM</code>的值。</p><p>​        当指令运行到最终的写回阶段时，因为流水线寄存器中的<code>stat</code>信号表示最近完成指令的处理器状态，所以就可以用来设置处理器的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word Stat &#x3D; [</span><br><span class="line">  W_stat &#x3D;&#x3D; SBUB : SAOK; #特殊情况，当写回阶段时bubble时</span><br><span class="line">  1              : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="执行阶段-1"><a href="#执行阶段-1" class="headerlink" title="执行阶段"></a>执行阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594084741531-41fbde30-04be-4927-8e96-12120c27e4a1.jpeg" alt="image"></p><p>在执行阶段中和SEQ的类似，只是要注意，当前面的指令出现异常时，需要保证条件码寄存器不进行修改，对应的HCL代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc &#x3D; E_icode &#x3D;&#x3D; IOPQ &amp;&amp; #首先要保证当前指令是算数指令，才会设置CC</span><br><span class="line">  !m_stat in &#123;SADR, SINS, SHLT&#125; &amp;&amp; #保证上一条处在访存阶段的指令没有出现异常</span><br><span class="line">  !W_stat in &#123;SADR, SINS, SHLT&#125;; #保证上两条指令没有出现异常</span><br></pre></td></tr></table></figure><p>其他部分与SEQ的类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#设置进入ALU的值</span><br><span class="line">word aluA &#x3D; [</span><br><span class="line">  E_icode in &#123;IRRMOVQ, IOPQ&#125;             : E_valA; #直接从寄存器中读取的值</span><br><span class="line">  E_icode in &#123;IIRMOVQ, IRMMOVQ, IMRMOVQ&#125; : E_valC; #包含立即数的值</span><br><span class="line">  E_icode in &#123;ICALL, IPUSHQ&#125;             : -8; #入栈，修改栈顶指针</span><br><span class="line">  E_icode in &#123;IRET, IPOPQ&#125;               : 8; #出栈，修改栈顶指针</span><br><span class="line">];</span><br><span class="line">word aluB &#x3D; [</span><br><span class="line">  E_icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ &#125; : E_valB;</span><br><span class="line">  E_icode in &#123; IRRMOVQ, IIRMOVQ &#125;                                  : 0;</span><br><span class="line">];</span><br><span class="line">#设置ALU进行的运算</span><br><span class="line">word alufun &#x3D; [</span><br><span class="line">  E_icode &#x3D;&#x3D; IOPQ : E_ifun;</span><br><span class="line">  1               : ALUADD;</span><br><span class="line">];</span><br><span class="line">#根据ALU计算的结果设置条件转移</span><br><span class="line">word e_dstE &#x3D; [</span><br><span class="line">  E_icode &#x3D;&#x3D; IRRMOVQ &amp;&amp; !e_Cnd :RNONE; #当为寄存器之间移动时，这里时条件转移</span><br><span class="line">  1                            : E_dstE;</span><br><span class="line">];</span><br><span class="line">#call指令需要的valP保存在valA中，在访存阶段需要使用</span><br><span class="line">#并且在取指阶段，还会通过当前的M_Cnd来判断跳转指令预测是否正确，再使用M_valA返回</span><br><span class="line">#所以需要将e_val传递下去</span><br><span class="line">word e_valA &#x3D; E_valA;</span><br></pre></td></tr></table></figure><h3 id="访存阶段-1"><a href="#访存阶段-1" class="headerlink" title="访存阶段"></a>访存阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594084741559-09c2f277-e2d8-44bf-9a63-79b924b84923.jpeg" alt="image"></p><p>这部分的HCL代码和SEQ的类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#设置内存地址</span><br><span class="line">word mem_addr &#x3D; [</span><br><span class="line">  M_icode in &#123;IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ&#125; : M_valE;</span><br><span class="line">  M_icode in &#123;IPOPQ, IRET&#125;                     : M_valA;</span><br><span class="line">];</span><br><span class="line">#设置读写的控制信号</span><br><span class="line">bool mem_read &#x3D; M_icode in &#123;IMRMOVQ, IPOPQ, IRET&#125;;</span><br><span class="line">bool mem_write &#x3D; M_icode in &#123;IRMMOVQ, IPUSHQ, ICALL&#125;;</span><br><span class="line">#由于当前阶段可能出现内存地址错误，所以还需要设置状态</span><br><span class="line">word m_stat &#x3D; [</span><br><span class="line">  dmem_error :SADR;</span><br><span class="line">  1          : M_stat;</span><br><span class="line">];</span><br><span class="line">#将其他需要的值传递下去</span><br><span class="line">word w_dstE &#x3D; W_dstE;</span><br><span class="line">word w_valE &#x3D; W_valE;</span><br><span class="line">word w_dstM &#x3D; W_dstM;</span><br><span class="line">word w_valM &#x3D; W_valM;</span><br></pre></td></tr></table></figure><h2 id="流水线控制逻辑"><a href="#流水线控制逻辑" class="headerlink" title="流水线控制逻辑"></a>流水线控制逻辑</h2><p>​        会讨论流水线中低级机制，使得流水线控制逻辑能将指令阻塞在流水线寄存器或往流水线中插入一个气泡。并且在流水线中，还有些特殊情况是其他机制不能处理的，包括：加载/使用冒险、处理<code>ret</code>、预测错误的分支、异常等情况。</p><h3 id="暂停和气泡"><a href="#暂停和气泡" class="headerlink" title="暂停和气泡"></a>暂停和气泡</h3><p>​        暂停和气泡是流水线中低级的机制，<strong>暂停</strong>能将指令阻塞在某个阶段，往流水线中插入<strong>bubble</strong>能使得流水线继续运行，但是不会改变当前阶段的寄存器、内存、条件码或程序状态。这两个状态决定了当时钟电平变高时，如何修改流水线寄存器。</p><p>​        对于正常状态，即不是用暂停和bubble时，只要时钟电平变高，就会将流水线寄存器的状态修改为输入值，并作为新的输出。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594084926353-b5c8bed6-9a34-462f-b0f7-70ea95b08c6b.jpg" alt="image"></p><ul><li><strong>暂停</strong></li></ul><p>​        通过加入流水线寄存器，我们将指令的执行划分成了不同的阶段，并且每个阶段的输入就是流水线寄存器中的内容，所以如果我们想要将指令暂停在某个阶段时，我们可以直接将该阶段的流水线寄存器固定不变，使得该阶段的输入信息保持不变，就能在该阶段反复地执行指令，<strong>就是的指令阻塞在当前阶段了。</strong></p><p>​        所以将指令暂停在某个阶段，就是当时钟电平变高时，保持该阶段的流水线寄存器的状态不变。暂定都是一段全部暂停</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594084939046-df0e3b6f-a4ae-4400-8211-ef4993fe071b.jpg" alt="image"></p><ul><li><strong>bubble</strong></li></ul><p>​        当时钟电平变高时，上一阶段指令的执行结果会保存到当前阶段的流水线寄存器，执行当前阶段后就会修改程序员可见状态，当我们想要保持程序员可见状态不变，可以插入一个bubble，使得寄存器状态设置成某个固定的复位配置，得到一个等效于<code>nop</code>指令的状态，<strong>相当于取消指令的运行</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594084970263-5e4facaf-701a-4f32-9e0b-d7bf7ffb7ffa.jpg" alt="image"></p><h3 id="加载-使用冒险"><a href="#加载-使用冒险" class="headerlink" title="加载/使用冒险"></a>加载/使用冒险</h3><p>​        <code>mrmovq</code>和<code>popq</code>指令<code>I1</code>会从内存中读取值保存到寄存器中，但是是在访存阶段才会读取到内存的值，所以如果下一条指令<code>I2</code>会读取这个寄存器的值，就会出现加载/使用冒险，因为当<code>I2</code>处于译码阶段读取寄存器值时，<code>I1</code>还是处于执行阶段，所以无法读取到内存的值。</p><p>​        <strong>理想处理方式</strong>为：固定流水线寄存器D和F，使得指令<code>I2</code>和下一条指令<code>I3</code>能分别阻塞在译码阶段和取指阶段，然后在译码阶段后面插入一个时钟周期的bubble，使得<code>I1</code>和前面的指令可以继续向后执行一个时钟周期，则<code>I1</code>此时处于访存阶段，就能读取到内存的值了。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085096048-06e4bd6a-3662-4f53-8a16-c91f2dc4fc92.png" alt="image"></p><p>​        所以当触发了加载/使用冒险时，流水线寄存器会如下设置一个时钟周期</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085096050-9032c291-4c70-483c-9ba8-273eaa3a25d0.png" alt="image"></p><h3 id="处理ret指令"><a href="#处理ret指令" class="headerlink" title="处理ret指令"></a>处理ret指令</h3><p>​        执行<code>ret</code>指令时，会从栈中读取返回地址作为下一条指令的地址，所以当<code>ret</code>执行到访存阶段时，才能读取到下一条指令的地址，然后在写回阶段的时钟电路变成高电平时，才会将其写入流水线寄存器M中，然后将<code>M_valM</code>传回去到<code>Select PC</code>逻辑模块。<strong>触发条件</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRET in &#123;D_icode, E_icode, M_icode&#125;</span><br></pre></td></tr></table></figure><p>​        <strong>理想处理方式</strong>为：当<code>ret</code>执行到译码阶段时，会触发触发条件，此时就固定流水线寄存器F，就能保持不断读取下一条指令<code>I2</code>，并且后面在译码阶段插入3个时钟周期的bubble（根据取指阶段的HCL，会不断执行<code>valP</code>的错误指令，但是通过插入bubble，使得它只能执行到取指阶段），使得<code>ret</code>指令能向后执行3个时钟周期到达写回阶段，此时就能直接通过<code>W_valM</code>获得下一个PC的地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594085361782-cc511581-3468-4348-b28d-45d86ea557c4.jpeg" alt="image"></p><p>​        所以当触发了<code>ret</code>指令时，流水线寄存器会如下设置3个时钟周期</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085361778-a0dcd3f3-7435-4db2-8941-3d2184b6c46d.png" alt="image"></p><h3 id="预测错误的分支"><a href="#预测错误的分支" class="headerlink" title="预测错误的分支"></a>预测错误的分支</h3><p>​        我们采用AT分支预测策略，所以当遇到条件分支指令<code>I1</code>时，会直接跳转到对应的地址开始执行，只有当<code>I1</code>执行到执行阶段时，才能通过<code>e_Cnd</code>判断是否发生跳转，此时已经执行了后续的两个指令<code>I2</code>和<code>I3</code>，分别处于译码阶段和取指阶段。预测错误的<strong>触发条件</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E_icode &#x3D;&#x3D; IJXX &amp;&amp; !e_Cnd</span><br></pre></td></tr></table></figure><p>​        当出现预测错误时，说明我们并不需要执行已经执行了的<code>I2</code>和<code>I3</code>指令，<strong>理想的处理方式</strong>为：直接在译码阶段插入bubbl中断<code>I3</code>，在执行阶段插入bubble中断<code>I2</code>，然后将正确的指令放入取指阶段开始执行，所以分支预测错误最多损耗两个时钟周期。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594085574182-000819b3-0465-4061-a83a-a8ce48f766cd.jpeg" alt="image"></p><p>​        所以当触发了预测错误的分支时，流水线寄存器就会如下设置一个时钟周期</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085574189-abfbe31c-89ff-460f-886e-3b8ab5cada28.png" alt="image"></p><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3><p>​        当出现<code>halt</code>指令、错误的指令码和函数码组合的指令或内存地址错误时，就会出现异常，所以异常通常在取指阶段和访存阶段被发现，对于异常<strong>理想的处理方式</strong>为：异常指令之前的指令都能完成，之后的指令都不会修改程序员可见状态，异常指令到达写回阶段时停止执行。</p><p>​        但是存在以下<strong>困难：</strong>异常在取指阶段和访存阶段被发现，程序员可见状态在执行阶段、访存阶段和写回阶段被修改。</p><p>​        我们首先在所有阶段的流水线寄存器中都包含一个程序状态信号<code>stat</code>，即使出现了异常，也只是将其当做普通信号传到下一阶段。当异常指令到达访存阶段时，后续的三条指令分别处于执行阶段、译码阶段和取指阶段，只有处于执行阶段的指令会修改条件码寄存器，所以要禁止执行阶段中的指令设置条件码。并且在访存阶段插入bubble，使得异常指令执行到写回阶段时，下一条指令就阻塞在执行阶段，不会到达访存阶段来修改内存。由于流水线处理器是按顺序处理指令的，所以第一次在写回阶段检测到异常指令就是最新的异常，所以只要在写回阶段检测到异常指令，就暂停写回，并暂停流水线。</p><p><strong>触发条件</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_stat in &#123;SADR, SINS, SHLT&#125; || W_stat in &#123;SADR, SINS, SHLT&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊情况组合"><a href="#特殊情况组合" class="headerlink" title="特殊情况组合"></a>特殊情况组合</h3><p>​        以上讨论都假设了一个时钟周期只发生一种特殊情况，我们还需要讨论在一个时钟周期中是否可能发生同时出现多个特殊情况。</p><p>​        下图为出现各种特殊情况是流水线寄存器的情况，我们可以大多数情况中特殊情况的触发条件都是互斥的，但是有两种组合可能会出现。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594085954302-1299dcdc-7522-4144-806d-add0cf901af1.jpg" alt="image"></p><ul><li><strong>组合A：</strong>所以预测错误可能和<code>ret1</code>同时出现。</li></ul><p>​        当执行阶段为条件分支，而译码阶段为<code>ret</code>时，由于预测分支采用了AT策略，说明<code>ret</code>指令是条件分支跳转后的第一条指令。此时由于预测错误，说明我们不应该执行<code>ret</code>指令，则理想的处理方式是对执行阶段插入bubble来取消<code>ret</code>的执行。并且当预测错误时，PC选择逻辑会选择<code>E_valA</code>，所以不用考虑流水线寄存器F采取的动作。</p><p>​        我们组合两种特殊情况的流水线控制动作，可以发现在E中使用了bubble符合理想的处理方式，并且在取指阶段使用暂停不会造成影响。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594086098481-df94d89b-2319-49e4-b5f3-d4ad1b671ff7.jpg" alt="image"></p><ul><li><strong>组合B：</strong>加载/使用冒险和<code>ret1</code>的组合</li></ul><p>​        <code>ret</code>指令在译码阶段会读取<code>%rsp</code>的值，如果我们上一条指令是从内存中读取值来设置<code>%rsp</code>，则会出现加载/使用冒险和<code>ret1</code>的组合。</p><p>​        我们需要优先保证处理加载/使用冒险，来对<code>%rsp</code>进行设置，然后再处理<code>ret</code>指令，所以需要将<code>ret</code>指令阻塞在译码阶段，所以对流水线寄存器D需要使用暂停。我们组合两种特殊情况的流水线控制动作</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594086147771-a80b4f4a-545a-47da-9e5e-18a762a3fd8f.jpg" alt="image"></p><h3 id="流水线逻辑的HCL代码"><a href="#流水线逻辑的HCL代码" class="headerlink" title="流水线逻辑的HCL代码"></a>流水线逻辑的HCL代码</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594086195581-996f40ce-809c-4e9b-9af3-e76a8e3eaecf.jpeg" alt="image"></p><p>​        如上图所示是流水线控制逻辑的整体结构，我们依次来说明对应的HCL代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#取指阶段</span><br><span class="line">##是否对F进行暂停</span><br><span class="line">bool F_stall &#x3D; </span><br><span class="line">  #出现加载&#x2F;使用冒险时</span><br><span class="line">  E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125; || #加载&#x2F;使用冒险的触发条件</span><br><span class="line">  #出现ret指令时</span><br><span class="line">  IRET in &#123;D_icode, E_icode, M_icode&#125;; #ret的触发条件</span><br><span class="line">##F是不会插入bubble的</span><br><span class="line">bool F_bubble &#x3D; 0;</span><br><span class="line">#译码阶段</span><br><span class="line">##是否对D进行暂停</span><br><span class="line">bool D_stall &#x3D; </span><br><span class="line">  #出现加载&#x2F;使用冒险时</span><br><span class="line">  E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125;;</span><br><span class="line">##是否对D插入bubble</span><br><span class="line">bool D_bubble &#x3D; </span><br><span class="line">  #出现预测错误时</span><br><span class="line">  (E_icode &#x3D;&#x3D; IJXX &amp;&amp; !e_Cnd) || #预测错误的触发条件</span><br><span class="line">  #出现了ret，但是没有出现加载&#x2F;使用冒险，（组合B）</span><br><span class="line">  !(E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125;) &amp;&amp;</span><br><span class="line">  IRET in &#123;D_icode, E_icode, M_icode&#125;;</span><br><span class="line">#执行阶段</span><br><span class="line">##因为没有特殊情况对E进行暂停，所以直接为0</span><br><span class="line">bool E_stall &#x3D; 0;</span><br><span class="line">##是否对E插入bubble</span><br><span class="line">bool E_bubble &#x3D; </span><br><span class="line">  #出现预测错误时</span><br><span class="line">  (E_icode &#x3D;&#x3D; IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">  #出现加载&#x2F;使用冒险时</span><br><span class="line">  E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125;;</span><br><span class="line">##当出现异常时，我们需确保后续指令不会对条件码寄存器进行修改</span><br><span class="line">bool set_cc &#x3D; E_icode &#x3D;&#x3D; IOPQ &amp;&amp; #首先要保证当前指令是算数指令，才会设置CC</span><br><span class="line">  !m_stat in &#123;SADR, SINS, SHLT&#125; &amp;&amp; #保证上一条处在访存阶段的指令没有出现异常</span><br><span class="line">  !W_stat in &#123;SADR, SINS, SHLT&#125;; #保证上两条指令没有出现异常</span><br><span class="line">#访存阶段</span><br><span class="line">##没有指令会在访存阶段进行暂停</span><br><span class="line">bool M_stall &#x3D; 0;</span><br><span class="line">##当之前的指令出现异常时，我们需要插入bubble来取消指令，防止对内存进行修改</span><br><span class="line">bool M_bubble &#x3D; m_stat in &#123;SADR, SINS, SHLT&#125; || W_stat in &#123;SADR, SINS, SHLT&#125;;</span><br><span class="line">#写回阶段</span><br><span class="line">#没有指令会插入bubble</span><br><span class="line">bool W_bubble &#x3D; 0;</span><br><span class="line">#当出现异常时，会在写回阶段暂停</span><br><span class="line">bool W_stall &#x3D; W_stat in &#123;SADR, SINS, SHLT&#125;;</span><br></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>​        我们通过计算PIPE执行一条指令所需的平均时钟周期来衡量系统的性能，该指标为<strong>CPI（Cycles Per Instruction）</strong>。而影响该指标的因素是流水线中插入bubble的数目，因为插入bubble时就会损失一个流水线周期。</p><p>​        我们可以在处理器中运行某个基准程序，然后统计执行阶段中运行的指令数 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232374-d3618b7b-2aa8-4721-8ddd-03c30a05dc04.svg" alt="image"> 和bubble数 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232387-3f0fc473-5c71-4329-9b30-955ca7808af1.svg" alt="image"> ，就得到对应的CPI指标</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232442-c5f92a86-5f5c-4b3e-bf25-d3d526a3c835.svg" alt="image"></p><p>​        由于只有三种特殊请款（加载/使用冒险、预测错误、<code>ret</code>指令）会插入bubble，所以我们可以将惩罚项 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232435-b2eb5867-663b-4ff1-84c4-1252628feec8.svg" alt="image"> 分为三部分，<code>lp</code>表示加载/使用冒险插入bubble的平均数，<code>mp</code>表示预测错误插入bubble的平均数，<code>rp</code>表示<code>ret</code>指令插入bubble的平均数，则CPI可变为</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232446-af49e018-dbf6-42da-ac6c-11e1e1808a98.svg" alt="image"></p><p>​        我们可以根据指令出现的频率以及出现特殊情况的频率对CPI进行计算</p><ul><li><code>mrmovq</code>和<code>popq</code>占所有执行指令的25%，其中20%会导致加载/使用冒险</li><li>条件分支指令栈所有执行指令的20%，使用AT策略会有60%的成功率</li><li><code>ret</code>指令栈所有执行指令的2%</li></ul><p>​        由此我们可以得到三种特殊情况的惩罚</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594086232420-8ced6e79-dc1f-4634-87fb-8566c3a3e320.jpeg" alt="image"></p><h2 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h2><h3 id="多周期指令"><a href="#多周期指令" class="headerlink" title="多周期指令"></a>多周期指令</h3><p>​        我们提供的Y86-64指令集只有简单的操作，在执行阶段都能在一个时钟周期内完成，但是如果要实现整数乘法和除法以及浮点数运算，我们首先要增加额外的硬件来执行这些计算，并且这些指令在执行阶段通常都需要多个时钟周期才能完成，所以执行这些指令时，我们需要平衡流水线各个部分之间的关系。</p><p>​        实现多周期指令的简单方法是直接暂停取指阶段和译码阶段，直到执行阶段执行了所需的时钟周期后才恢复，这种方法的性能通常比较差。</p><p>​        常见的方法是使用独立于主流水线的特殊硬件功能单元来处理复杂的操作，通常会有一个功能单位来处理整数乘法和除法，还有一个功能单位来处理浮点数运算。在译码阶段中遇到多周期指令时，就可以将其发射到对应的功能单元进行运算，而主流水线会继续执行其他指令，使得多周期指令和其他指令能在功能单元和主流水线中并发执行。但是如果不同功能单元以及主流水线的指令存在数据相关时，就需要暂停系统的某部分来解决数据冒险。也同样可以使用暂停、转发以及流水线控制。</p><h3 id="与存储系统接口的关系"><a href="#与存储系统接口的关系" class="headerlink" title="与存储系统接口的关系"></a>与存储系统接口的关系</h3><p>​        我们假设了取指单元和数据内存都能在一个时钟周期内读写内存中的任意位置，但是实际上并不是。</p><ol><li>处理器的存储系统是由多种硬件存储器和管理虚拟内存的操作系统共同组成的，而存储系统包含层次结构，最靠近处理器的一层是<strong>高速缓存（Cache）存储器</strong>，能够提供对最常使用的存储器位置的快速访问。典型系统中包含一个用于读指令的cache和一个用于读写数据的cache，并且还有一个<strong>翻译后备缓冲器（Translation Look-aside Buffer，TLB）</strong>来提供从虚拟地址到物理地址的快速翻译。将TLB和cache结合起来，大多数时候能再一个时钟周期内读指令并读写数据。</li><li>当我们想要的引用位置不在cache中时，则出现高速缓存<strong>不命中（Miss）</strong>，则流水线会将指令暂停在取指阶段或访存阶段，然后从较高层次的cache或处理器的内存中找到不命中的数据，然后将其保存到cache中，就能恢复指令的运行。这通常需要3~20个时钟周期。</li><li>如果我们没有从较高层次的cache或处理器的内存中找到不命中的数据，则需要从磁盘存储器中寻找。硬件会先产生一个<strong>缺页（Page Fault）</strong>异常信号，然后调用操作系统的异常处理程序代码，则操作系统会发起一个从磁盘到主存的传送操作，完成后操作系统会返回原来的程序，然后重新执行导致缺页异常的指令。其中访问磁盘需要数百万个时钟周期，操作系统的缺页中断处理程序需要数百个时钟周期。</li></ol><h3 id="当前的微处理器设计"><a href="#当前的微处理器设计" class="headerlink" title="当前的微处理器设计"></a>当前的微处理器设计</h3><p>​        我们采用的五阶段流水线设计，吞吐量都现在最多一个时钟周期执行一条指令，CPI测量值不可能小于1.0。较新的处理器支持<strong>超标量（Superscalar）</strong>操作，能够在取值、译码和执行阶段并行处理多条指令，使得CPI测量值小于1.0，通常会使用IPC（每个周期执行的指令数）来测量性能。更新的处理器会支持<strong>乱序（Out-of-order）</strong>技术，对指令执行顺序进行打乱来并行执行多条指令。</p>]]></content>
      
      
      <categories>
          
          <category> 细读经典 </category>
          
          <category> 《CSAPP》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 程序的机器级表示</title>
      <link href="%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/csapp-3/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/"/>
      <url>%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/csapp-3/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>​        对应书中3.1～3.5，主要包含X86指令系统中基础的指令。</p><hr><p><strong>小点：</strong></p><ul><li>生成四字节的数据指令会把高位4个字节置0.</li><li>寄存器内存引用需要使用64位寄存器</li><li>局部变量只需要保存在寄存器中</li><li>对于程序而言，缓存是不可见的</li></ul><hr><h2 id="机器级表示"><a href="#机器级表示" class="headerlink" title="机器级表示"></a>机器级表示</h2><p>​        高级语言知识低级语言的抽象，最后都需要转化成对应机器的机器语言。低级语言我们可以看到更多机器细节的数据。</p><ul><li><p>程序计数器<strong>（PC）</strong>：显示下一条指令地址</p></li><li><p>程序使用的寄存器<strong>（Register）</strong>：保存变量</p></li><li><p>只有几位的<strong>状态码（Condition Codes）</strong>：指示指令的运行结果</p><ul><li><p><strong>ZF：</strong>零标志，最近的操作得到的结果是否为0。</p></li><li><p><strong>无符号数：</strong></p><ul><li><strong>CF：</strong>进位标志，最近的操作使得<strong>最高位产生进位</strong>。可用来检查无符号数是否存在溢出。</li></ul></li><li><p><strong>补码：</strong></p><ul><li><p><strong>SF：</strong>符号标志，最近的操作得到的<strong>结果为负数</strong>。</p></li><li><p><strong>OF：</strong>溢出标志，最近的操作导致补码溢出（<strong>可以通过符号位进一步判断是正溢出还是负溢出</strong>）。</p></li></ul></li></ul></li></ul><p>  对于机器级编程，有两个抽象：</p><ul><li><p>由<strong>指令集体系结构</strong>或<strong>指令集架构（Instruction Set Architecture，ISA）</strong>来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA都将程序的行为描述为按顺序执行每条指令。这是编译器的目标，提供一系列指令告诉机器要做什么。而<strong>微结构（Microarchitecture）</strong>是指这个架构的实现。</p></li><li><p>机器级程序使用的内存地址是虚拟内存地址，使得内存模型看上去是一个很大的连续字节数组。然后由操作系统将其转换为真实的物理内存地址。在任意给定的时刻，只有有限的一部分虚拟地址是合法的。</p></li></ul><p>  本文是基于<strong>x86-64</strong>体系结构，属于<strong>CISC复杂指令集</strong>。另一种主流体系结构<strong>ARM</strong>属于<strong>RICS精简指令集</strong>。</p><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>  ​    计算机直接执行机器代码，所以需要将源代码转化为机器代码：</p><pre><code>1. **预处理**：扩展源文件，插入所有`#include`指令的文件，扩展所有用`#define`声明指定的宏。2. **编译**：输出汇编代码3. **汇编**：将汇编代码转化为二进制文件，也叫**可重新定位目标文件**，其中全局地址还没有填入。4. **链接器**：将目标代码文件和库函数合并，填入全局地址，形成**可执行代码文件**。</code></pre><p><img src="https://i.loli.net/2020/10/17/DIK4LhBPyMck6A9.jpg" alt="1596246571373-0c5d9ef2-7959-43ef-9cca-438c9d04cc44.jpg"></p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>​        文件<code>mstore.c</code>包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y,<span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x,y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过<code>gcc -Og -s mstore.c将其编译成汇编代码，得到</code>mstore.s`，其中：</p><ul><li><code>-Og</code>,是生成机器代码的优化等级，这个表示编译器会生成符合原始C代码整体结构的机器代码，这是用于调试的级别，便于我们学习观察。其他的<code>-O1</code>或<code>-O2</code>会得到更好的程序性能，但是机器代码和源代码的关系就比较难以理解。</li><li><code>-S</code>：只生成到汇编代码</li></ul><p><img src="https://i.loli.net/2020/10/17/q1jNgCZExT5RuDJ.jpg" alt="1596246571396-de693f7c-6997-4a2c-8af1-ab0155184c88.jpg"></p><p>​        所有开头几行都是知道汇编器和链接器的伪指令，汇编代码从<code>multstore：</code>开始。</p><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><p>​        我们可以运行<code>gcc -Og -c mstore.c</code>来进行编译和汇编，会生成二进制文件<code>mstore.o</code>，它是对一系列指令的编码，机器直接执行这些字节序列，对源代码一无所知。</p><p>​        我们可以通过<strong>反汇编器（Disassembler）</strong>来将机器代码转化为类似汇编代码的格式，在Linux中，我们可以运行<code>objdump -d mstore.o</code>，可以得到：</p><p><img src="https://i.loli.net/2020/10/17/7AFXQuzWpOJiq8k.jpg" alt="1596246571371-864fd884-6591-4bd0-a817-1c614c0c924a.jpg"></p><ul><li>每个指令需要的字节数不同</li><li>每个指令有自己对应的编码</li></ul><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>​        使用链接器将目标代码格式转化为可执行代码，<strong>要求</strong>：目标代码中必须含有<code>main.c</code>主函数作为程序的入口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = a*b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后运行命令<code>gcc -Og -o prog main.c mstore.c</code>将main.c和mstore.c链接起来，并添加启动和终止程序的代码，以及用来与操作系统交互的代码生成可执行代码，生成最终的可执行文件<code>prog</code>。我们通过对其反汇编，可以得到如下内容</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571372-c7389431-f144-45ad-8d8a-34fbde610106.jpeg" alt="image"></p><p>可以发现和汇编器生成的<strong>区别有</strong>：</p><ol><li>链接器将代码移到了新的地址范围内。</li><li>第4行中，链接器补充了调用函数<code>mult2</code>需要使用的地址。</li><li>多了两行<code>nop</code>，可以使得函数代码变成16字节，更好放置下一个代码。</li></ol><p>大概了解后，我们需要开始学习汇编代码了，</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>​        在x84-64中C语言数据类型的大小如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571435-8418dc0c-5d7d-494d-b265-b0f7e619d533.jpeg" alt="image"></p><p>​        大多数GCC生成的汇编代码指令都有一个表示操作数大小的后缀。<strong>注意：</strong>汇编代码使用<code>l</code>表示4字节整数和 8字节双精度浮点数，由于浮点数使用完全不同的指令和寄存器，所以不会产生冲突。</p><h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>​        一个x86-64的CPU中包含16个存储64位的寄存器，可用来存储<strong>整数数据和指针</strong>，有些寄存器有特殊用途：</p><ul><li>栈指针：<code>%rsp</code>来存储栈顶</li><li>比如<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>和<code>%r9</code>用来保存函数的参数</li><li><code>%rip</code>用来保存当前执行指令的地址</li><li><code>%rax</code>用来存放函数的返回值</li></ul><p>​        在大部分情况下这些寄存器都可用来保存程序数据。并且有一组标准编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值，以及存储局部和临时数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571434-0f63c725-20b9-4d46-a79c-30b42758ed60.jpeg" alt="image"></p><p>​        我们可以对这些寄存器的低位字节中存放的不同大小的数据进行操作，<code>%r</code>表示64位、<code>%e</code>表示32位。</p><p>​        对于生成小于8字节结果的指令，<strong>有两条规则：</strong></p><ol><li>生成1字节或2字节数据的指令会保持剩下的字节内容不变；</li><li><strong>生成4字节数据的指令会把高位 4个字节置零。</strong></li></ol><h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>​        大多数指令由一个或多个操作数（Operand），指示出一个操作中要使用的元数据值，以及放置结果的目的位置。x86-64支持的操作数格式如下</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571570-b95e003d-0b8e-423a-9660-a73ad10eb597.jpeg" alt="image"></p><p>​        其中包含三种类型：</p><ul><li><strong>立即数（Immediate）：</strong>用来表示常数值，书写格式是在<code>$</code>后面跟一个标准C表示法表示的整数。</li><li><strong>寄存器（Register）：</strong>表示某个寄存器的内容。</li><li><strong>内存引用：</strong>它会根据计算出来的地址访问某个内存位置。有不同的寻址模式，最常用的是 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571430-c4ea36e3-2c3b-4a3c-bb51-a38c0e508437.svg" alt="image"> ，其中，<strong>要求寄存器大小都是64位的</strong>，才能完整索引整个虚拟内存空间，并且不能使用<code>%rsp</code>。</li></ul><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>​        最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。</p><h4 id="源和目的大小匹配"><a href="#源和目的大小匹配" class="headerlink" title="源和目的大小匹配"></a>源和目的大小匹配</h4><p>​        该类数据传送指令将数据从一个位置复制到另一个位置，不做任何变化。不同类型指令指定了不同的数据大小（一个字为两个字节）。<strong>源操作数</strong>是一个立即数，可以保存在寄存器或内存中；<strong>目的操作数</strong>是一个位置，可以是寄存器或内存位置。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596246571430-a0cfb4ec-f13e-4512-9850-de2979cd8495.jpg" alt="image"></p><p><strong>注意：</strong></p><ul><li>两个操作数不能同时为内存地址。如果要在两个内存位置传输数据，必须用一个寄存器进行中转。</li><li>使用到的寄存器大小一定要和指令最后一个字符指定的大小匹配。</li><li><code>movl</code>以寄存器为目的时，会将寄存器的高位4字节置0。</li><li>如果用<code>movq</code>来传输立即数时，该立即数只能表示为<strong>32位补码，然后扩展到64位的值</strong>。而<code>movabsq</code>能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571422-7e08d379-dcd5-4401-bcf9-d710a0b6f68a.jpeg" alt="image"></p><h4 id="源寄存器小于目的寄存器"><a href="#源寄存器小于目的寄存器" class="headerlink" title="源寄存器小于目的寄存器"></a>源寄存器小于目的寄存器</h4><p>​        在将较小的源值复制到较大的目的时，提供两个类<code>MOVZ</code>和<code>MOVS</code>。<code>MOVZ</code>是将目的中剩余的字节填充0，<code>MOVS</code>是将目的剩余的字节填充符号位的值。它们每条指令后面吗都有两个字符，分别表示源大小和目的大小。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571394-65c9a956-e217-499f-adeb-3fe36784f3c9.jpeg" alt="image"></p><p><strong>注意：</strong></p><ul><li><p>不存在<code>movzlq</code>，可以直接使用<code>movl</code>。因为当使用<code>movl</code>传输数据到32位目的寄存器中时， 会自动将目的寄存器的高位4字节置零。</p></li><li><p><code>cltq</code>没有操作数，总是以<code>%eax</code>作为源寄存器，以<code>%rax</code>作为目的寄存器，等价于<code>movslq %eax,%rax</code>。</p><p><strong>当源寄存器大于目的寄存器时，会报错。</strong></p></li></ul><p><strong>例1：</strong></p><p>​        给定代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exchange</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        其中，<code>xp</code>保存在<code>%rdi</code>中，<code>y</code>保存在<code>%rsi</code>中，补充以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exchange:</span><br><span class="line">    ______________</span><br><span class="line">    ______________</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>​        首先，像<code>x</code>这样的局部变量，通常会保存在寄存器而不是内存中，因为访问寄存器会比内存快很多。所以第一行就是将<code>*xp</code>移到一个寄存器中，因为<code>xp</code>保存在<code>%rdi</code>中，而指针<code>xp</code>保存的是存储数据的内存地址，所以要用<code>(%rdi)</code>来访问对应的内存数据来作为源，而<code>long</code>数据类型保存的是64位数据，所以需要使用<code>movq</code>来传输。所以第一行是<code>movq (%rdi),%rax</code>。接下来将<code>y</code>中的数据保存到指针对应的内存地址中就行了，所以是<code>movq %rsi,(%rdi)</code>。</p><p><strong>例2：</strong></p><p>​        有以下强制类型转换代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src_t *sp;</span><br><span class="line">dest_t *dp;</span><br><span class="line">*dp &#x3D; (dest_t) *sp;</span><br></pre></td></tr></table></figure><p>​        其中<code>sp</code>和<code>dp</code>分别保存在寄存器<code>%rdi</code>和<code>%rsi</code>中。对于不同的<code>src_t</code>和<code>dest_t</code>，我们推测它的汇编指令。</p><ul><li><code>long</code>–&gt; <code>long</code>： 由于两个类型相同，照理说是可以直接<code>movq (%rdi), (%rsi)</code>，但是x86-64限制不能在内存地址间传输，所以需要先经过一个寄存器，所以汇编指令为：<code>movq (%rdi), %rax</code>，<code>movq %rax, (%rsi)</code>。</li><li><code>char</code>–&gt; <code>int</code>：两个都是有符号数，而<code>char</code>时1个字节，<code>int</code>是4个字节，所以要先对数据进行有符号扩展，即<code>movsbl (%rdi), %eax</code>。然后将其转到对应的内存地址<code>movl %eax, (%rsi)</code>。</li><li><code>char</code>–&gt; <code>unsigned</code>：当大小和符号同时改变时，C中是先改变大小，再改变符号的。而<code>char</code>是有符号数，所以先对其进行有符号扩展<code>movsbl (%rdi), %eax</code>。由于有符号数和无符号数之间的位向量是相同的，所以直接将其保存到对应的内存地址就行，即<code>movl %eax, (%rsi)</code>。</li><li><code>unsigned char</code>–&gt; <code>long</code>：由于<code>long</code>是64位的，而且对<code>unsigned char</code>进行无符号扩展时是补充0，所以我们可以直接对低32位赋值，这样高4字节也会自动变成零，即<code>movzbl (%rdi),%eax</code>。然后将其整个转到对应的内存地址<code>movq %rax, (%rsi)</code>。</li><li><code>int</code>–&gt; <code>char</code>：因为<code>int</code>是32位的，而<code>char</code>是8位的，所以要直接对其进行截断。这里是先将其整个移到寄存器中，然后再将部分保存到内存中，即<code>movl (%rdi), %eax</code>，<code>movb %al, (%rsi)</code>。</li><li><code>unsigned</code>–&gt; <code>unsigned char</code>： 上同。</li><li><code>char</code>–&gt; <code>short</code>：<code>movbw (%rdi), %ax</code>，<code>movw %ax, (%rsi)</code>。</li></ul><p><strong>综上：</strong></p><ol><li>两个指针之间进行传输，由于是直接对内存进行操作的，所以需要先经过一个寄存器。</li><li>小的数据类型转换到大的数据类型，是根据前面的数据类型决定是<code>MOVZ</code>还是<code>MOVS</code>。</li><li>大的数据类型转换到小的数据类型时，先将其保存得到寄存器中，再将部分保存到内存中。</li></ol><h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><p>​        栈在处理过程调用中起着至关重要的作用，在内存中栈顶位于较小的内存地址中。入栈时，就需要先将栈顶地址增加，由此指向了要放数据的地址，然后将数据存入对应的内存中。出栈时，先从内存中取出对应的数据，然后再将栈地址减小，来指向当前的栈顶地址。</p><p>​        这里使用一个特殊的寄存器<code>%rsp</code>来保存栈顶内存地址。并且提供两个操作指令<code>PUSH</code>和<code>POP</code>分别对应入栈和出栈，以操作64位数据为例，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596246571443-7e5a47f2-693a-4b30-8530-2b86412b4bee.jpg" alt="image"></p><p>​        （这里的8是指8个字节）</p><p>​        因为栈和程序代码和其他的程序数据都放在同一内存中，所以我们可以根据<code>%rsp</code>来访问栈中的任意位置。假设栈顶元素是8字节的，则<code>movq 8(%rsp), %rdx</code>表示将第二个元素保存在寄存器<code>%rdx</code>中。</p><h2 id="算数和逻辑运算"><a href="#算数和逻辑运算" class="headerlink" title="算数和逻辑运算"></a>算数和逻辑运算</h2><p>​        以下列出了x86-64中的一些算数和逻辑操作，除了<code>leaq</code>以外，其他都有对不同大小数据的指令。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571419-0e7de786-d619-43f8-837f-a0b22286a693.jpeg" alt="image"></p><ul><li><code>leaq S D</code>是将S计算出的地址付给寄存器D。通常会被用来执行加法和有限形式的乘法。比如对于比例变址寻址 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571478-f4f9ae60-a150-403a-82e7-91c88d313feb.svg" alt="image"> ，得到的地址会是 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571462-26241dd9-81c1-4aac-8697-b20f020c2f9e.svg" alt="image"> ，所以<code>leaq Imm(%rax, %rbx, s), %rcx</code>就是将<code>Imm+%rax+s*%rbx</code>保存到<code>%rcx</code>。<strong>注意：</strong>目的操作数只能是寄存器。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1596246571554-3b0b746e-a2c4-45d3-a6f3-4f79ebc5ece6.png" alt="image"></p><ul><li><strong>一元操作符</strong>中，操作数可以是寄存器也可以是内存地址。</li><li><strong>二元操作符</strong>中，第一个操作数可以是立即数、寄存器或内存地址；第二个操作数可以是寄存器或内存地址。</li><li><strong>移位操作</strong>中，第一个操作数可以是立即数或放在<strong>寄存器<code>%cl</code>**中，第二个操作数可以是寄存器或内存位置。</strong>注意：**如果我们对w位的数据进行移位，则只考虑<code>%cl</code>中 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571514-3501c99d-d521-42c5-8e75-d2063f2325bb.svg" alt="image"> 位，保证不会将数据移出边界。 比如<code>salb</code>只会考虑低3位的值，<code>salw</code>只会考虑低4位的值，以此类推。</li></ul><p><strong>注意：</strong></p><ul><li>以上操作除了右移以外，在无符号数和补码间都是通用的，也体现了补码的优势。</li><li>可以使用<code>xorl %edx, %edx</code>来对寄存器<code>%rdx</code>置零。</li></ul><h2 id="特殊计算操作"><a href="#特殊计算操作" class="headerlink" title="特殊计算操作"></a>特殊计算操作</h2><h3 id="128位除法"><a href="#128位除法" class="headerlink" title="128位除法"></a>128位除法</h3><p>​        在3-10中我们并没有看到除法操作，它是使用比较特殊的指令进行计算的，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571632-7460a4f9-1337-426f-97a4-20c0b5ae94ae.jpeg" alt="image"></p><p>​        其中<code>R[%rdx]:R[%rax]</code>表示将两个寄存器的值拼接起来作为一个数，其中寄存器<code>%rdx</code>是高八字节，<code>%rax</code>是低八字节。它这里只有一个操作数表示除数，而被除数保存在<code>%rax</code>和<code>%rdx</code>中。</p><p>​        <strong>有符号数除法：</strong></p><ol><li><p>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</p></li><li><p>将被除数中的64位<code>mov</code>到<code>%rax</code>中</p></li><li><p>如果被除数是64位的，则要用<code>cqto</code>根据<code>%rax</code>中的最高有效位对<code>%rdx</code>进行符号扩展；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</p></li><li><p>使用<code>idiv</code>进行计算。</p><p><strong>无符号数除法：</strong></p></li><li><p>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</p></li><li><p>将被除数中的64位<code>mov</code>到<code>%rax</code>中</p></li><li><p>如果被除数是64位的，则使用<code>xorq %rdx, %rdx</code>将高64位置零；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</p></li><li><p>使用<code>div</code>进行计算。</p></li></ol><h3 id="128位乘法"><a href="#128位乘法" class="headerlink" title="128位乘法"></a>128位乘法</h3><p>​        普通的imulq二元操作符乘法是64位乘以64位产生一个64位的结果。</p><p>​        我们知道，64位数乘上64位数会得到128位的数，x86-64提供了这种乘法的指令，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1596246571442-5c45d36e-617b-49ae-a0ba-d8e2f3bbb13f.png" alt="image"></p><p>​        我们可以发现，指令<code>imul</code>和图3-10中的普通乘法指令是一样的，但是这个128位乘法只有一个操作数，普通乘法有两个操作数，汇编器会通过操作数的数目来判断是执行哪条指令。</p><ol><li>将占用<code>%rax</code>的数据<code>mov</code>到别的寄存器中</li><li>将其中一个乘数<code>mov</code>到<code>%rax</code>中</li><li>如果是有符号乘法，就使用<code>imul</code>，如果是无符号乘法，就是用<code>mul</code></li><li>对结果进行保存，比如保存在<code>(%rdi)</code>中：如果是在小端机器中，则为<code>movq %rax, (%rdi)</code>，<code>movq %rdx, 8(%rdi)</code>；如果是打断机器中，则为<code>movq %rax, 8(%rdi)</code>，<code>movq %rdx, (%rdi)</code>。</li></ol><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>​        对应于书本3.6</p><hr><p><strong>小点：</strong></p><ul><li><p>大多数情况下，机器对有符号数和无符号数都使用一样的指令，因为大多数算数运算对无符号数和补码都是相同的位级行为。但是在右移、除法和乘法指令以及条件码组合中，需要区分无符号数和补码。</p></li><li><p>保存在64位寄存器中的数据类型，除了<code>long</code>和<code>unsigned long</code>以外，还可以是指针（对于64位操作系统而言）。</p></li><li><p>条件跳转只能是直接跳转。</p></li><li><p>当<code>switch</code>的分支跨度很大，并且很稀疏时，会保存很大的跳转表，可能影响性能，编译器可能会将其构建成树的结构。此时建议使用<code>if-else</code>语句。</p></li><li><p>这一节比较重要的概念：条件jump、条件mov以及跳转表的思想</p></li></ul><hr><p>​        之前介绍的只是指令一条条顺序执行的，也就是对应于直线代码的行为。当出现条件语句、循环语句等，就需要有条件地执行指令。机器代码通过测试数据值，然后根据测试的结果来改变控制流或者数据流。</p><h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>​        除了之前介绍的保存整数和指针的16个64的寄存器以外，CPU还维护了一组单个位的<strong>条件码（Condition Code）寄存器</strong>，我们不会直接对条件码进行设置，而是根据最近的算数、逻辑或者测试的结果，自动设置这些条件码寄存器的值。</p><p><strong>条件码包括：</strong></p><ul><li><p><strong>ZF：</strong>零标志，最近的操作得到的结果是否为0。</p></li><li><p><strong>无符号数：</strong></p><ul><li><strong>CF：</strong>进位标志，最近的操作使得<strong>最高位产生进位</strong>。可用来检查无符号数是否存在溢出。</li></ul></li><li><p><strong>补码：</strong></p></li><li><p><strong>SF：</strong>符号标志，最近的操作得到的<strong>结果为负数</strong>。</p><ul><li><strong>OF：</strong>溢出标志，最近的操作导致补码溢出（<strong>可以通过符号位进一步判断是正溢出还是负溢出</strong>）。</li></ul></li></ul><p>​      当我们执行如下操作时，不仅目的寄存器会发生改变，同时会设置这些条件码寄存器。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249171960-3be4721e-7321-4016-9f1c-0d7406283c58.jpeg" alt="image"></p><p><strong>注意：</strong></p><ul><li><p><code>lea</code>不会设置条件码，因为它只是单纯计算地址。</p></li><li><p>逻辑操作的CF和OF会设置为0。</p></li><li><p>移位操作CF为最后一个被移出的位，OF=0。</p></li><li><p>INC和DEC会设置OF和ZF，不会改变CF。</p><p>x86-64提供了另外两类指令，<strong>只会设置条件码而不会改变目的寄存器</strong>：</p></li><li><p><code>CMP S1, S2</code>：用来比较<code>S1</code>和<code>S2</code>，根据<code>S2-S1</code>的结果来设置条件码。主要用来比较两个数的大小。CMP命令和SUB的命令行为是一样的，只是CMP命令只设置条件码不改变寄存器。</p></li><li><p><code>TEST S1, S2</code>：用来测试<code>S1</code>和<code>S2</code>，根据<code>S1 &amp; S2</code>的结果来设置条件码。可以将一个操作数作为掩码，用来指示哪些位用来测试。TEST命令和AND命令是一样的，只是TEST命令只设置条件码，不改变寄存器。比如<code>testq %rax, %rax</code>就可以检查<code>%rax</code>是正数、负数还是0。</p><p><strong>注意：</strong>使用<code>CMP</code>进行比较时，要注意顺序是相反的。比如<code>CMP S1, S2</code>得到大于的结果，则表示<code>S2</code>大于<code>S1</code>。</p></li></ul><p>我们可以执行这两个指令后，自己根据条件码的组合来比较或测试结果，但是这里提供了一类<code>SET</code>指令，能够自动根据条件码的组合来得到结果，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249171965-cd40de33-10bc-45d5-8a79-764df72a7d02.jpeg" alt="image"></p><p>这里的目的操作数是<strong>低位单字节寄存器</strong>，或者一个字节的内存位置。如果要得到32位或64位结果，我们可以使用<code>MOVZ</code>对其进行传输。</p><p><strong>注意：</strong>这里无符号数和补码的条件码组合不同，所以需要使用不同的<code>SET</code>指令，所以可以通过<code>SET</code>指令来判断所操作的数是无符号的还是补码的。</p><p>所以常见的<strong>使用顺序</strong>为：</p><ol><li>使用<code>CMP</code>进行比较或<code>TEST</code>进行测试，来设置条件码。</li><li>根据条件码组合或者<code>SET</code>将结果保存在单字节寄存器中。</li><li>使用<code>movbl</code>将结果保存在32位寄存器中，并且会自动设置高4字节为0。</li></ol><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>​        之前介绍的都是顺序执行指令的代码，而<strong>跳转（Jump）指令</strong>能够改变指令执行的顺序，跳转到新的指令后继续顺序执行。而跳转指令我们可以分成<strong>不同的类型：</strong></p><ul><li><p><strong>根据提供跳转目标的方式：</strong></p></li><li><ul><li><strong>直接跳转：</strong>跳转目标作为指令的一部分进行编码。汇编语言中，跳转目标通常用一个<strong>标号（Label）</strong>指明，比如下面汇编代码里的<code>.L1</code>就是标号。在产生目标代码时，汇编器以及链接器会确定跳转目标的适当编码，并将其编码为跳转指令的一部分。</li><li><strong>间接跳转：</strong>跳转目标从寄存器或内存位置中读取出来。需要在前面添加一个<code>*</code>，比如<code>jmp *%rax</code>就是跳转到寄存器<code>%rax</code>中保存的地址；<code>jmp *(%rax)</code>就是跳转到内存地址<code>(%rax)</code>中保存的地址。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span> <span class="number">$0</span>, %rax</span><br><span class="line">  <span class="keyword">jmp</span> .L1</span><br><span class="line">  <span class="keyword">movq</span> (%rax), %rdx</span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  popq %rdx</span><br></pre></td></tr></table></figure><ul><li><p><strong>根据跳转的条件：</strong></p></li><li><ul><li><strong>无条件跳转：</strong>没有任何条件，看到<code>jmp</code>就直接跳转。</li><li><strong>有条件跳转：</strong>根据条件码组合来判断是否进行跳转。</li></ul></li></ul><p>​         常见的所有跳转指令如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249172105-cccdbe35-88dd-4a8b-821a-109f184963be.jpeg" alt="image"></p><p>​        <strong>注意：</strong>条件跳转只能是直接跳转。</p><p>​        对于直接跳转的跳转目标的编码，有<strong>两种编码方式：</strong></p><ul><li><p><strong>PC相对的（PC-relative）：</strong>跳转目标地址减去跳转指令下一条指令的地址的差。编码长度可以为1、2或4字节。</p></li><li><p><strong>绝对地址：</strong>用4/8字节直接给定目标地址。</p><p>​    对于如下代码，我们使用PC相对编码</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249171961-a528e373-9c10-45ce-9bcb-5f7278fca6da.jpg" alt="image"></p><p>​        我们反汇编汇编器的结果和链接器的结果，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172128-3913f643-0074-49b7-abab-6ecb906a38ba.jpg" alt="image"></p><p>​        可以发现，无论是汇编器的反汇编结果，还是偏移到新的地址空间的链接器的反汇编结果，第二行的<code>jmp</code>的编码都是<code>eb 03</code>，其中<code>eb</code>是<code>jmp</code>的编码，而<code>03</code>就是计算出来的差值，而第5行的<code>jg</code>的编码都是<code>7f f8</code>，其中<code>7f</code>是<code>jg</code>的编码，而<code>f8</code>是计算出来的结果。所以<strong>即使偏移到新的地址空间，使用PC相对的编码方式也不用修改<code>jmp</code>的编码。</strong></p><p>​        <strong>通过看<code>jmp</code>的编码，就能知道跳转的地址的差值。</strong></p><p>​        通过跳转指令，就能实现条件执行和不同循环结构。</p><h2 id="使用跳转指令实现条件执行和循环结构"><a href="#使用跳转指令实现条件执行和循环结构" class="headerlink" title="使用跳转指令实现条件执行和循环结构"></a>使用跳转指令实现条件执行和循环结构</h2><h3 id="用条件控制实现条件分支"><a href="#用条件控制实现条件分支" class="headerlink" title="用条件控制实现条件分支"></a>用条件控制实现条件分支</h3><p>​        实现条件操作的传统方法是通过使用控制的条件转移，当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。对于条件分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">  proc1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  proc2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        其中x保存在<code>%rdi</code>，y保存在<code>%rsi</code>，可以定义对应的汇编语言</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmpq %rsi, %rdi</span><br><span class="line">  <span class="keyword">jge</span> .L1</span><br><span class="line">  PROC2</span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  PROC1</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h3 id="用条件传送实现条件分支"><a href="#用条件传送实现条件分支" class="headerlink" title="用条件传送实现条件分支"></a>用条件传送实现条件分支</h3><p>​        以上方法的性能并不是很优越。</p><p>​        处理器在执行一条指令时，会经历一系列过程，而每个过程执行所需操作的一小部分，通过重叠连续指令可以提高性能，比如当前指令执行计算时，下一条指令可以执行取指阶段，这个方法称为<strong>流水线（Pipelining）</strong>。但是当遇到条件需要跳转时，只有知道跳转结果才能确定指令顺序，才能使用流水线，现在处理器采用<strong>分支预测</strong>的方法来预测跳转的结果，即处理器会预测当前跳转的结果，然后将预测的指令进行流水线，如果预测正确则会提高性能，如果预测错误，就需要把之前流水线清空，然后在正确的分支重新开始流水线，会损失很多性能。</p><blockquote><p><strong>分支预测处罚计算：</strong>预测错误概率为p，预测正确时代码执行时间为TOK，而预测错误的处罚为TMP。则执行代码的平均时间为TAVG(p)=(1-p)TOK+p(TOK+TMP)=TOK+pTMP，所以TMP=(TAVG(p)-TOK)/p。</p></blockquote><p>​        上一节的用<strong>条件控制</strong>的方法就会存在这个问题，由于存在不确定的跳转，所以处理器会通过分支预测来将填满流水线，如果分支预测错误，就使得性能受损。</p><p>​        而用<strong>条件传送</strong>来实现条件分支，不会先判断跳转，而是先将两个分支的结果进行计算，将结果分别保存在两个寄存器中，然后再通过**条件传送指令<code>CMOV</code>**将正确结果传送到输出的寄存器中。</p><p>​        比如以下的计算x和y的差的绝对值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;y)</span><br><span class="line">    <span class="keyword">return</span> y-x;</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        使用条件控制的方法实现的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">absdiff:</span></span><br><span class="line">  cmpq %rsi, %rdi //y-x</span><br><span class="line">  <span class="keyword">jl</span> .L1</span><br><span class="line">  <span class="keyword">movq</span> %rdi, %rax           //y&gt;=x</span><br><span class="line">  subq %rsi, %rax</span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  <span class="keyword">movq</span> %rsi, %rax</span><br><span class="line">  subq %rdi, %rax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>​        这里在第二行中会直接执行一个<code>cmp</code>，所以就存在不确定的分支，处理器为了能够流水线执行指令，就会先预测结果，如果预测错误，就会很损伤性能。</p><p>使用条件传送方法实现的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">absdiff:</span></span><br><span class="line">  <span class="keyword">movq</span> %rsi, %rax</span><br><span class="line">  subq %rdi, %rax  //y-x</span><br><span class="line">  <span class="keyword">movq</span> %rdi, %rdx</span><br><span class="line">  subq %rsi, %rdx  //x-y</span><br><span class="line">  cmpq %rsi, %rdi</span><br><span class="line">  <span class="keyword">cmovge</span> %rdx, %rax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>​        这里会直接将两个分支的计算结果<code>x-y</code>和<code>y-x</code>分别保存在寄存器<code>%rdx</code>和<code>%rax</code>中，然后最后通过<code>cmovge</code>判断如果<code>x&gt;y</code>就将<code>x-y</code>的结果保存在<code>%rax</code>。这里就不需要进行分支预测，性能就十分稳定。</p><p>​        x86-64上提供了一些<strong>条件传送指令<code>CMOV</code>**，只有在满足条件时，才会将源数据传送到目的中，如下图所示，其中源值可以从寄存器也可以从内存地址获取，而目的只能是寄存器。并且这里</strong>不支持单字节**。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249171994-abea0a94-e102-4a93-8551-8564bc7d5ce1.jpeg" alt="image"></p><p>​        但是条件传送也实现的条件分支也存在<strong>局限性</strong>：</p><ol><li>如果条件判断是里面执行语句的可行性判断时，使用条件传送实现条件分支就会出现错误。比如对于指针<code>xp</code>，有个条件分支为<code>xp?*xp:0</code>，如果使用条件传送来实现，就会先运行<code>*xp</code>，如果该指针不存在，就会报错。</li><li>如果执行语句需要大量计算时，由于条件传送会先全部计算后再进行选择，则会浪费一些时间。</li></ol><p>​        所以只有当两个执行语句很简单时，才会使用条件传送来实现条件分支。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><p>​        比如代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n<span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(n&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对应的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fact_do:</span></span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq <span class="number">$1</span>, %rdi</span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jg</span> .L1</span><br><span class="line">  <span class="keyword">rep</span><span class="comment">; ret</span></span><br></pre></td></tr></table></figure><p>​        可以发现，在跳转标号<code>.L1</code>之前是循环的初始化，跳转标号之后就是循环体，然后最后要判断是否继续循环体。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>​        有两种实现while循环的方法，在实现初始测试的方法不同。</p><p>​        对于以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_while</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Jump-to-middle"><a href="#Jump-to-middle" class="headerlink" title="Jump-to-middle"></a>Jump-to-middle</h4><p>​        类似于do-while，只是需要在最开始就跳转到后面的判断语句</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fact_while:</span></span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line">  <span class="keyword">jmp</span> .JUDGE</span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq <span class="number">$1</span>, %rdi</span><br><span class="line"><span class="symbol">.JUDGE:</span></span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jg</span> .L1</span><br><span class="line">  <span class="keyword">rep</span><span class="comment">; ret</span></span><br></pre></td></tr></table></figure><p>​        <strong>特点：</strong>一开始就有一个无条件跳转指令。</p><h4 id="guarded-to"><a href="#guarded-to" class="headerlink" title="guarded-to"></a>guarded-to</h4><p>​        当使用较高优化等级时，比如<code>-O1</code>时，GCC会使用这种策略</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fact_while:</span></span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jle</span> .L1</span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq <span class="number">$1</span>, %rdi</span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jne</span> .L2</span><br><span class="line">  <span class="keyword">rep</span><span class="comment">; ret</span></span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>​        这里是直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>​        for循环可以转化为while循环，然后根据优化等级，GCC会为其产生的代码是while循环的两种方法之一。比如对于代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_for</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    result *= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以将其转化为while语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_for_while</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">    result *= i;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        由此就能使用4.2中介绍的两种方法进行翻译了。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>​        <code>switch</code>语句可以根据一个整数索引数值进行多重分支。通常使用<strong>跳转表（Jump Table）</strong>数据结构使得实现更加高效，它是一个数组，每个元素是对应的代码块起始地址，根据整数索引得到对应的代码地址后，就可以直接跳转到对应的代码块。相比很长的<code>if-else</code>语句的<strong>优势在于</strong>：执行<code>switch</code>语句的时间与分支数目无关。比如有很长的分支语句，如果用<code>if-else</code>实现，则可能需要经过若干个<code>if-else</code>才能跳转到目的代码块，而使用<code>switch</code>能根据跳转表直接获得代码块地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172132-b7d14408-e8b0-44de-823c-c9240d0f1cc6.jpg" alt="image"></p><p>​        如下图所示的C语言代码</p><p><img src="https://pic1.zhimg.com/80/v2-ff0086df487d98b5f05861b6598bc336_720w.jpg" alt="image"></p><p>​        我们首先看GCC提供对跳转表支持后的C语言代码</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172152-b2ec64f5-a25c-4d0d-920d-a5880ad1a3fd.jpg" alt="image"></p><p>​        里面有一个跳转表数组<code>jt</code>，GCC提供了一个新的运算<code>&amp;&amp;</code>，能够创建一个指向代码位置的指针。首先在第9行中，计算输入值<code>x</code>和<code>switch</code>的最小值的差，并将其保存到无符号数中。然后将其作为跳转表的索引，直接在第16行中跳转到索引的代码位置。</p><p>​        <strong>注意：</strong>这里使用无符号数的原因在于，即使你输入比<code>switch</code>中最小值还小的值，则相减会得到负数，由于无符号数会将负数溢出到很大的正数，所以还是会跳转到<code>default</code>。所以汇编代码会使用<code>ja</code>对其使用无符号数的判断，判断是小于0还是大于最大值。</p><p>​        <strong>注意：</strong>跳转表中会创建从最小值到最大值的代码位置，对于重复的情况，比如<code>104</code>和<code>106</code>，就会跳转到相同的代码位置；对于缺失的情况，比如<code>101</code>和<code>105</code>，就会直接跳转到<code>default</code>。</p><p>​        我们可以看一下对应的汇编代码</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249172137-3a0d33ef-5b81-4988-9b42-c65f429a5e89.jpeg" alt="image"></p><p>​        <strong>注意：</strong>通过第2行可以知道<code>switch</code>的最小值，第3行可以知道<code>switch</code>的最大值，第4行可以知道<code>default</code>的标号。</p><p>​        这里首先将计算结果保存在<code>%rsi</code>中，然后在第4行中<code>jmp *.L4(, %rsi, 8)</code>利用了跳转表，<strong>跳转表的内容由编译器自动生成填写</strong>，其声明如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172086-3e3688ca-d47b-4130-9c19-cd574793f436.jpg" alt="image"></p><p>​        <code>.rodata</code>表示这是只读数据（Read-Only Data），<code>.align 8</code>表示将元素地址与8对其，<code>.L4</code>就定义了一个跳转表，其枚举了从最小值到最大值的跳转目标。对于<code>*.L4(, %rsi, 8)</code>，首先根据<code>.L4</code>可以获得该跳转表的初始位置，然后因为该跳转表每个元素占8个字节，所以计算<code>(, %rsi, 8)</code>，即<code>8*%rsi</code>，就能得到对应的跳转目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172140-a99160c1-f865-4112-87d4-2ce64a8a66ae.jpg" alt="image"></p><p>​        由于以上跳转表的性质，所以当出现跨度很大，并且很稀疏的分支情况时，建议使用<code>if-else</code>。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>​        对应于书的3.7节</p><hr><p><strong>小点：</strong></p><ul><li>C中的取地址符<code>&amp;</code>返回的是内存地址，所以一定要保存在内存中。</li><li>保存到内存中进行参数传输时，要求每个参数大小为8字节的倍数，即要求相对<code>%rsp</code>的偏移量为8的倍数</li><li>不会显示地操作程序计数器寄存器<code>%rip</code>，没有指令可以对其操作，只能通过类似<code>call</code>或<code>ret</code>间接对其操作。</li><li>栈顶指针<code>%rsp</code>是随着函数运行不断变化的。</li><li>函数可以假设“被调用者保存寄存器”的值是不变的，而可以用“调用者保存寄存器”来保存临时值。</li><li>某个函数要永久使用的值，要么保存在“被调用者保存寄存器”中，要么保存在内存中。</li><li>当函数需要使用“被调用者保存寄存器”时，就直接将其<code>push</code>到栈中，使用过后再<code>pop</code>重置。</li><li>无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过<code>%rsp</code>将这些区域释放掉，这是动态的过程，使得一个函数运行完时，<code>%rsp</code>指向的就是返回地址，就能直接通过<code>ret</code>返回到调用者的断点处。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596250833201-cd60eeaf-304f-4cbd-932d-8fe622ce8ef2.jpeg" alt="image"></p><ul><li>进入一个函数时，首先将要使用的“被调用者保存寄存器”<code>push</code>到栈中，然后<strong>通过<code>%rsp</code>来申请一段固定大小的空间</strong>，用来存放局部变量和参数构造区，最后再释放申请的空间。</li></ul><p>​        要提供对函数的机器级支持，必须处理许多不同的属性。我们假设函数P调用函数Q，Q执行后返回P。这个过程包括以下一个或多个<strong>机制：</strong></p><ul><li><strong>传递控制：</strong>在进入函数Q的时候，程序计数器要设置为Q的代码的起始位置。从函数Q返回时，要把程序计数器设置为P中调用Q后面那条指令的地址，即从P中的断点处继续执行。</li><li><strong>传递数据：</strong>函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。</li><li><strong>分配和释放内存：</strong>开始时，函数Q可能需要为局部变量分配空间，而在返回前，又要释放这些存储空间。</li></ul><p>​        要想详细了解这些机制，我们首先要知道在内存中是如何保存函数的。</p><hr><h2 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h2><p>​        栈帧：当函数需要的存储空间超出寄存器能够存放的大小，或者调用别的函数需要保存额外数据时，就会在栈上分配一个空间，这个空间称为函数的<strong>栈帧（Stack Frame）</strong>。相对的，当某个函数的所有局部变量都能保存在寄存器中，并且不会调用任何的函数时，就无需开辟该函数的栈帧了。当给一个函数创建栈帧时，编译器会给函数分配<strong>所需</strong>的<strong>定长</strong>的栈帧，在函数开始时就分配好后就不会改变了，所以栈顶指针<code>%rsp</code>就知道当函数返回时，需要释放多少空间。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593831663269-efd6cd27-05ba-4b0e-9584-34ca4c1aeab6.jpg" alt="image"></p><p>​        栈帧包括：被保存的寄存器 –&gt; 局部变量 –&gt; 参数构造区 –&gt; 返回地址</p><p>​        其中除了返回地址，其他都不是必须要用的，只有到需要的时候才创建。</p><h3 id="被保存的寄存器"><a href="#被保存的寄存器" class="headerlink" title="被保存的寄存器"></a>被保存的寄存器</h3><p>​        我们对除了栈指针<code>%rsp</code>外的所有寄存器分成两类：</p><ul><li><strong>被调用者保存寄存器：</strong><code>%rbx</code>、<code>%rbp</code>和<code>%r12</code>~<code>%r15</code>。这部分寄存是由被调用者，即Q保存的。如果Q改变了这部分寄存器的值，就需要将其保存在Q自己栈帧中的<strong>“被保存的寄存器”</strong>中。当Q返回时，再将这部分寄存器的值根据内存复原。所以函数P可以假设“被调用者保存寄存器”的值是始终不变的。</li><li><strong>调用者保存寄存器：</strong>除了上面的寄存器外，都属于被调用者保存寄存器。 任何函数都能修改这些寄存器的值，并且不会保存在“被保存的寄存器”中，所以P要自己将这部分寄存的内容保存起来。所以函数P可以假设“调用者保存寄存器”的值是变化的，需要自己保存，可以用这部分寄存器保存临时值。</li></ul><p>​        <strong>调用步骤</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//<span class="number">1</span>.函数一进来，就需要通过<span class="keyword">push</span>指令将自己要使用的“被调用者保存寄存器”保存在自己的栈帧中</span><br><span class="line">//比如使用了%rbx和%rbp</span><br><span class="line">  pushq %rbx    //保存%rbx到栈帧中</span><br><span class="line">  pushq %rbp    //保存%rbp到栈帧中</span><br><span class="line">... //可以使用“被调用者保存寄存器”来保存值</span><br><span class="line">//<span class="number">2</span>.当“被调用者保存寄存器”不够保存当前函数的值时，需要开辟局部变量空间保存其他值</span><br><span class="line">//比如保存<span class="number">8</span>字节值</span><br><span class="line">  subq <span class="number">$8</span>, %rsp //将栈指针下移<span class="number">8</span>个字节</span><br><span class="line">  <span class="keyword">movq</span> %rdi, (%rsp)  //将需要保存的值保存到栈上</span><br><span class="line">//<span class="number">3</span>.调用别的函数</span><br><span class="line">  <span class="keyword">call</span> func //调用函数func，则“被调用者保存寄存器”会保存在函数func的栈帧中</span><br><span class="line">... //可以继续使用“被调用者保存寄存器”，因为函数func返回时会重置这些寄存器到原始值</span><br><span class="line">//<span class="number">4</span>.释放局部变量空间</span><br><span class="line">  addq <span class="number">$8</span>, %rsp</span><br><span class="line">//<span class="number">5</span>.重置“被调用者保存寄存器”的值，注意顺序要相反</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rbx</span><br></pre></td></tr></table></figure><p>​        <strong>综上所述：</strong></p><ol><li>将要使用的“被调用者保存寄存器”<code>push</code>到栈中。（存储调用当前函数的函数的值）</li><li>将除了“被调用者保存寄存器”的其他寄存器保存在空闲的“被调用者保存寄存器”中，如果保存不下，就将其保存在内存的“局部变量”区域</li><li>调用其他函数</li><li>释放 “局部变量”区域</li><li>将“被调用者保存寄存器”的值通过<code>pop</code>从栈中恢复。注意：顺序要和<code>push</code>时相反</li></ol><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>​        当函数需要保存的数据不多时，就会将数据保存在“被调用者保存寄存器”中。但是以下情况必须<strong>保存在内存中</strong>，该部分称为该函数的<strong>局部变量：</strong></p><ul><li><p>“被调用者保存寄存器”不足以保存所有的本地数据</p></li><li><p>当一个局部变量使用取地址符&amp;时，指的是返回该变量在内存中的地址，就必须将其保存在内存中</p></li><li><p>当局部变量是数组或结构时</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593832934958-03a6a743-3a1c-4841-b7de-d26b42c325de.jpg" alt="image"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">call_proc:</span></span><br><span class="line">  //<span class="number">1</span>. 因为x1、x2、x3和x4都有取地址符，所以都是保存在内存中的，首先要通过%rsp分配存储空间</span><br><span class="line">  subq <span class="number">$32</span>, %rsp       //将栈顶指针%rsp下移<span class="number">32</span>，扩展了<span class="number">32</span>字节空间</span><br><span class="line">  //<span class="number">2</span>. 将数据保存在内存中</span><br><span class="line">  <span class="keyword">movq</span> <span class="number">$1</span>, <span class="number">24</span>(%rsp)    //因为x1为long，所以需要<span class="number">8</span>字节空间，所以将<span class="number">1</span>保存在<span class="number">24</span>(%rsp)处</span><br><span class="line">  movl <span class="number">$2</span>, <span class="number">20</span>(%rsp)    //因为x2为<span class="keyword">int</span>，所以需要<span class="number">4</span>字节空间</span><br><span class="line">  movw <span class="number">$3</span>, <span class="number">18</span>(%rsp)    //因为x3为short，所以需要<span class="number">2</span>字节空间</span><br><span class="line">  movb <span class="number">$4</span>, <span class="number">17</span>(%rsp)    //因为x4为char，所以需要<span class="number">1</span>字节空间</span><br><span class="line">  //<span class="number">3</span>. 依次根据proc传入参数的顺序保存在内存和寄存器中</span><br><span class="line">  //因为总共要传入<span class="number">8</span>个参数，超过了<span class="number">6</span>个参数，所以要将最后的x4和&amp;x4保存在内存中，这里要求和<span class="number">8</span>字节对齐</span><br><span class="line">  leaq <span class="number">17</span>(%rsp), %rax  //获取&amp;x4，因为不能直接在内存间<span class="keyword">mov</span>，所以需要先保存到寄存器%rax</span><br><span class="line">  <span class="keyword">movq</span> %rax, <span class="number">8</span>(%rsp)   //参数<span class="number">8</span>：将&amp;x4保存在内存<span class="number">8</span>(%rsp)中，这里要求是<span class="number">8</span>的倍数</span><br><span class="line">  movl <span class="number">$4</span>, (%rsp)      //参数<span class="number">7</span>：将x4保存在内存(%rsp)中</span><br><span class="line">  leaq <span class="number">18</span>(%rsp), %r9   //参数<span class="number">6</span>：将&amp;x3保存在%r9中</span><br><span class="line">  movl <span class="number">$3</span>, %r8d        //参数<span class="number">5</span>：将x3保存在%r8中</span><br><span class="line">  leaq <span class="number">20</span>(%rsp), %rcx  //参数<span class="number">4</span>：将&amp;x2保存在%rcx中</span><br><span class="line">  movl <span class="number">$2</span>, %edx        //参数<span class="number">3</span>：将x2保存在%rdx中</span><br><span class="line">  leaq <span class="number">24</span>(%rsp), %rsi  //参数<span class="number">2</span>：将&amp;x1保存在%rsi中</span><br><span class="line">  movl <span class="number">$1</span>, %edi        //参数<span class="number">1</span>：将x1保存在%rdi中</span><br><span class="line">  //<span class="number">4</span>. 调用函数</span><br><span class="line">  <span class="keyword">call</span> proc</span><br><span class="line">  //<span class="number">5</span>. 根据%rsp将保存在内存中的数据进行计算</span><br><span class="line">...</span><br><span class="line">  //<span class="number">6</span>. 删除空间</span><br><span class="line">  addq <span class="number">$32</span>, %rsp</span><br></pre></td></tr></table></figure><p>​        可以将其总结为以下几步：</p><ol><li>申请局部空间，通过对栈顶指针<code>%rsp</code>减掉一个值</li><li>根据数据大小，通过<code>%rsp</code>索引将数据保存在内存空间中</li><li>根据传入参数顺序，将其保存到内存和寄存器中。<strong>注意：</strong>参数大小要为8字节的倍数。</li><li>释放局部空间，通过对栈顶指针<code>%rsp</code> 加上<code>1.</code>中的值</li></ol><h3 id="参数构造区"><a href="#参数构造区" class="headerlink" title="参数构造区"></a>参数构造区</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1593833317142-76d172f9-aa22-42b8-83ee-3606f41d3b9c.jpeg" alt="image"></p><p>​        如果某个函数要传递超过6个参数的话，就需要将第7个到第n个参数保存在<strong>栈</strong>中，然后通过<strong>栈顶指针<code>%rsp</code>**进行索引其中第7个参数在栈顶位置。要求每个参数的大小要为8字节的倍数。这部分区域称为</strong>参数构造区**。保存在寄存器中的参数访问起来比保存在内存中快很多。</p><h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><p>​        主要任务：记录函数返回地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1593833387368-a4b1150b-409d-43ec-b76d-251b7f1d6670.jpeg" alt="image"></p><ul><li><p><code>call</code>：可以直接将函数名作为跳转目标，其编码的计算方式和<code>jmp</code>相同。相当于<code>push</code>和设置<code>%rip</code>的组合。</p></li><li><ul><li>将栈指针减8，留出保存返回地址的空间</li><li>将紧跟<code>call</code>指令后面那条指令的地址作为返回地址，保存到栈中。</li><li>将程序计数器设置为调用函数的地址。</li></ul></li><li><p><code>ret</code>：从当前函数返回，不需要操作数。相当于设置<code>%rip</code>和<code>pop</code>的组合。</p></li><li><ul><li>将程序计数器设置为栈顶元素。</li><li>将栈指针加8。</li></ul></li></ul><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul><li>（被保存的寄存器）函数P将要使用的“被调用者保存寄存器”通过<code>push</code>保存在函数的栈帧中。</li><li>（局部变量）如果函数P使用了“调用者保存寄存器”，就需要将其保存在栈中，才能调用函数Q。并且函数P根据需要申请空间来保存其他局部变量。</li><li>（参数构造区）函数P将参数保存在寄存器中，如果超过6个参数，就申请空间保存到内存中。</li><li>（返回地址）函数P使用<code>call</code>指令调用函数Q，会将<code>call</code>的下一行指令的地址压入栈中，并将程序计数器指向函数Q的第一条指令的地址。</li><li>当函数Q运行时会随着使用动态申请和释放局部变量，当函数Q运行完时，首先使用栈“被调用者保存寄存器”的值，然后使用<code>ret</code>指令返回将程序计数器设置为栈顶的返回地址，最后将栈顶的返回地址弹出。</li></ul><p>​        我们可以发现有趣的一点是，无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过<code>%rsp</code>将这些区域释放掉，这是动态的过程，使得一个函数运行完时，<code>%rsp</code>指向的就是返回地址，就能直接通过<code>ret</code>返回到调用者的断点处。</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>​        对应于书3.8、3.9。</p><hr><p><strong>小点：</strong></p><ul><li>当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称。而当你声明一个指针时，你所分配的只有指针本身的空间。</li><li>当程序要用一个常数作为数维度或者缓冲区大小时，最好通过<code>#define</code>声明将这个常数与一个名字联系起来，后面就一直使用这个名字代替常数的数值。</li><li>在<code>struct</code>和<code>union</code>中的对象，都是保存在内存中的。</li><li>定义结构体时，按照对象K值的大小，<strong>从大到小声明</strong>，可以减少填充的空间，节省整个结构体的大小。</li></ul><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><p>​        对于一个数组声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[N];</span><br></pre></td></tr></table></figure><p>​        主要经历两个步骤：</p><ol><li><p>根据数据类型<code>T</code>的大小<code>L</code>字节，先在内存空间中分配一个大小为<code>L*N</code>的连续空间；</p></li><li><p>将<code>A</code>作为这个连续内存空间的起始指针，即A的值<code>xA</code>就是该内存空间的起始地址。</p><p><strong>注意</strong>：<strong>当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称</strong>。<strong>而当你声明一个指针时，你所分配的只有指针本身的空间</strong>，所以如果没有初始化指针，直接对其进行解引用可能会出现错误。</p></li></ol><p>​        如果我们将该数组的起始地址<code>xA</code>和索引值<code>i</code>保存在寄存器中，就能通过“比例变址寻址”的方式获得对应内存地址的数据。比如我们将起始地址保存在寄存器<code>%rdx</code>，将索引值保存在寄存器<code>%rcx</code>中，假设数据类型为<code>int</code>4字节，则访问该位置的汇编代码为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl (%rdx, %rcx, <span class="number">4</span>), %eax</span><br></pre></td></tr></table></figure><h3 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T D[R][C]</span><br></pre></td></tr></table></figure><p>​        其中，<code>R</code>是行数，<code>C</code>是列数。数组按照行优先保存。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593835497216-2041404d-e596-4262-8d0c-bbd8d53e6389.jpg" alt="image"></p><p>​        所以当该数组的起始地址为<code>x</code>，<code>T</code>的大小为<code>L</code>时，<code>D[i][j]</code>的地址为<code>x+L(Ci+j)</code>。类似一元数组，我们也可以很容易地通过“比例变址寻址”的方式进行索引。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593835522867-61c19daf-3f3e-42b2-8052-dc0dd8127642.jpg" alt="image"></p><h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>​        当我们使用<code>#define</code>定义一个变量<code>N</code>为常量后，再用<code>N</code>来确定数组大小，则该数组是一个定长数组。</p><h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>​        过去C要求数组的大小要在编译时就确定，才能生成对应的汇编代码。如果需要变长数组，就需要程序员自己对数组分配存储空间。ISO-C99允许数组的维度为表达式，在数组被分配时才计算出来，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[exp1][exp2];</span><br></pre></td></tr></table></figure><p>​        只要求<code>exp1</code>和<code>exp2</code>定义在上面那个声明之前。</p><p>​        我们接下来对比下定长数组和变长数组在索引时汇编代码的区别：</p><ul><li>定长数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fix_matrix[<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fix_ele</span><span class="params">(fix_matrix A, <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对应的汇编代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fix_ele:</span><br><span class="line">  leaq (%rsi, %rsi, 2), %rax    #compute 3i</span><br><span class="line">  leaq (%rdi, %rax, 4), %rax    #compute A+12i</span><br><span class="line">  movl (%rax, %rdx, 4), %eax    #read fomr M[A+12i+4j]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><ul><li>变长数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">var_ele</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> A[n][n], <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对应的汇编代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var_ele:</span><br><span class="line">  imulq %rdx, %rdi             <span class="meta">#compute ni</span></span><br><span class="line">  leaq  (%rsi, %rdi, <span class="number">4</span>), %rax  <span class="meta">#compute A+4ni</span></span><br><span class="line">  movl  (%rax, %rcx, <span class="number">4</span>), %eax  <span class="meta">#read from M[A+4ni+4j]</span></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>​        看汇编代码可以发现以下区别：</p><ul><li>增加了参数n，使得寄存器的使用改变了，</li><li>用了乘法指令来计算<code>ni</code>，而不是用<code>leaq</code>来计算<code>3i</code>，乘法会导致无法避免的性能损失</li></ul><h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>​        c语言提供两种将不同对象组合到一起的数据结构</p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>​        C语言中，可以用<code>struct</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p><ul><li><strong>定义：</strong>可以将不同类型的对象聚合到一个对象中，并使用名字来引用结构中的各个组成部分。</li><li><strong>存储：</strong>结构的所有组成部分都存放在内存中一段<strong>连续的</strong>区域内，指向结构的<strong>指针</strong>是结构第一字节的地址。</li><li><strong>获得元素：</strong>编译器会维护关于每个结构类型的信息，了解每个字段的偏移量，由此作为内存引用指令的唯一，来对结构元素进行引用。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1593837007125-2960fbfd-82dc-4ca1-8fa3-58462b86e932.png" alt="image"></p><p>​        所以结构的各个字段的选取完全是在编译时处理的，机器代码不包含关于字段申明或字段名字的信息。</p><h4 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h4><p>​        <strong>对齐原则</strong>是任何K字节的基本对象的地址必须是K的倍数</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593837157485-ebf4e6e4-cedd-4444-8cae-4d77d1be6969.jpg" alt="image"></p><p>​        在<code>struct</code>中两个连续的对象，编译器可能中间会插入间隙，来满足各自对内存地址的要求。并且还有<strong>两个额外的要求：（对齐要求最大为8）</strong></p><ul><li>要求结构的初始地址一定是结构体中最大对象大小的倍数，使得偏移量加上初始地址才是真的满足倍数关系的。</li><li>在结构体末尾填充，使其是结构体中最大对象大小的倍数，使得结构数组中下一个元素的地址也是成倍数关系的。</li></ul><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>​        C语言中，可以用<code>union</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p><ul><li><strong>定义：</strong>允许以多种类型来引用一个对象。</li><li><strong>存储：</strong>保存在<strong>公共的</strong>一块内存中，通过不同对象的类型来赋予这块内存不同的含义。<strong>内存大小为最大字段的大小。</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593837408508-862da1fe-e4d5-4ec4-9989-f07b97a326e6.jpg" alt="image"></p><p>​        主要应用有：</p><ul><li>如果我们事先知道两个不同字段是互斥的，就能将其定义在一个union中，就能节省内存空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;N_LEAF, N_INTERNAL&#125; <span class="keyword">nodetype_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span>&#123;</span></span><br><span class="line">  <span class="keyword">nodetype_t</span> type;</span><br><span class="line">  <span class="keyword">union</span> node_u&#123;</span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">      <span class="keyword">union</span> node_u *left;</span><br><span class="line">      <span class="keyword">union</span> node_u *right;</span><br><span class="line">    &#125; internal;</span><br><span class="line">  &#125; info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>访问相同位模式下不同数据类型的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">double2long</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">  &#125; temp;</span><br><span class="line">  temp.d = d;</span><br><span class="line">  <span class="keyword">return</span> temp.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong><code>struct</code>和<code>union</code>的区别：</strong><code>struct</code>为每个对象分配了单独的内存空间，而<code>union</code>分配了共用的内存空间。</p><p>​        <strong>什么时候用<code>union</code>什么时候用<code>struct</code>：</strong>当你要信息同时存在时，就需要分配到不同的内存中，就要用<code>struct</code>，否则用<code>union</code>。</p><p>​        <strong>计算struct和union嵌套的数据类型的内存分布：</strong></p><ul><li>如果是包裹在struct内的，就按顺序按照对象大小依次排列下来</li><li>如果是包裹在union内的，就看最大的对象大小，直接分配一块内存就行。</li></ul><h1 id="控制和数据结构"><a href="#控制和数据结构" class="headerlink" title="控制和数据结构"></a>控制和数据结构</h1><p>​        对应于书中的3.10小节。</p><h2 id="x86-64内存分布"><a href="#x86-64内存分布" class="headerlink" title="x86-64内存分布"></a>x86-64内存分布</h2><p>​        真实物理内存通过操作系统将其映射虚拟内存</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593931911264-0bd9f222-7d32-4672-9b01-62bf96abfea5.jpg" alt="image"></p><ul><li><strong>Stack：</strong>在Linux中，将栈放置在整个地址空间的最顶部，用于函数调用，及<strong>局部变量</strong>的存储，这样随着函数的运行，栈顶就能向低地址不断扩展。常用系统中栈的大小是8MB，可通过命令<code>limit</code>查看，如果用栈指针访问超过8MB范围的地址，就会出现<strong>段错误（Segmentation Fault）</strong>。 相同程序的栈的分配是固定的。</li><li><strong>Shared Libraries：</strong>类似于<code>printf</code>和<code>malloc</code>的这类<strong>库函数</strong>平时是被存储在磁盘上的，当我们程序需要使用库函数时，就会在程序开始执行时，将它们加载到你的程序中，这称为<strong>动态加载（Dynamic Linking</strong>）。</li><li><strong>Heap：</strong>用来存放通过**<code>malloc</code>、<code>callc</code>或<code>new</code>**等申请的变量，这些变量在程序运行时会动态变化。当你不断通过<code>malloc</code>申请空间又没释放时，堆顶的指针就不会断向高地址增加，使得占用的内存不断变多。堆在分配时是具有随机性的。</li><li><strong>Data：</strong>该数据区用来存放程序开始时分配的数据，你声明的<strong>全局变量、静态变量或字符常量等</strong>都在这个数据段中。</li><li><strong>Text：</strong>根据可执行目标文件的内容进行初始化，是放置你的<strong>可执行程序</strong>的位置。这部分区域是只读的。</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>​        指针类型不是机器代码的一部分，而是C语言提供的关于内存地址的抽象，指针的值存储的是对象的地址，可以直接通过指针来间接对内存进行访问，避免程序员寻址错误。特殊的<code>NULL(0)</code>表示该指针不指向任何值。如果指针通过<code>&amp;</code>创建，表示获得某个对象的地址，在机器代码中对应于<code>leaq</code>。如果指针通过<code>*</code>进行访问，表示访问该指针指向的对象的值，在机器代码中对应于内存引用。</p><p>​        指针类型确定访问多少个字节。</p><p>​        指针类型还影响指针运算的伸缩。</p><p>​        我们同样可以声明<strong>函数指针</strong>，表示指向函数在机器代码中的第一条指令的内存地址。</p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​        对数组的引用超出了边界。缓冲区溢出会被用于网络攻击。    </p><p>​        函数P调用函数Q后，会先在栈中写入返回地址A，对应于函数P中的断点位置。而在函数Q中，首先会为buf申请一段空间，如果我们写入一些攻击代码，比如转化为字节形式的指令，并且将返回地址A覆盖为该buf的起始位置。这样当函数Q运行完后，只是通过移动栈指针来释放空间，但是我们注入的代码还保存在栈中，并且<code>ret</code>会调用返回地址B，就返回到了我们注入代码的起始位置，就会开始执行我们注入的代码了。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593933331397-6257fcf5-9d23-410a-85bd-3dcc43f1961c.jpg" alt="image"></p><h3 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h3><h4 id="不使用具有缓冲溢出的函数"><a href="#不使用具有缓冲溢出的函数" class="headerlink" title="不使用具有缓冲溢出的函数"></a>不使用具有缓冲溢出的函数</h4><p>​        fgets 代替 gets strncpy代替strcpy</p><h4 id="地址空间布置随机化"><a href="#地址空间布置随机化" class="headerlink" title="地址空间布置随机化"></a>地址空间布置随机化</h4><p>​        攻击代码要插入指向攻击代码的指针，需要知道代码放置的位置。对此，使用地址空间布局随机化（ASLR），每次运行程序时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据都会加载到内存的不同区域，使得代码位置不是很好获得。</p><p>​        破解方法是空操作雪橇（Nop Sled），在代码前插入nop指令，只要攻击者能猜到一个nop就能滑倒攻击指令。</p><p>​        ASLR中栈随机化技术比较常用，在栈前分配n字节的随机大小空间。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1593933863248-ea6edf94-ba43-43f0-a905-0d218c79da36.png" alt="image"></p><p>​        比如我们使用重复运行以下代码获得栈地址范围</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> local;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,&amp;local);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        假设获得最小地址为<code>0xFFFFB754</code>，最小地址为<code>0xFFFFD754</code>，则随机化的空间为8192个字节。如果我们构建一个128字节的nop sled，则只要尝试<code>8192/128=64</code>次就能成功，所以随机化程度不能太小，同时也别太大占用程序的空。</p><h4 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h4><p>​        标记栈是不可执行的。</p><h4 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h4><p>​        GCC首先会尝试确定一个函数是否容易受到栈溢出攻击，比如函数中有局部char类型缓冲区时，就会使用一种<strong>栈保护者（Stack Protector）机制</strong>，通过在该函数栈帧中的局部变量区与栈状态（返回地址和寄存器保存区）之间存入一个随机的<strong>金丝雀值（Canary）</strong>，然后在恢复寄存器状态和返回返回地址之前，会检测该值是否发生变化，如果发生变化，则程序异常终止。</p><p>​        <strong>技巧：</strong>将缓冲区放在靠近金丝雀值的位置，防止其他局部变量被修改。</p><h2 id="支持边长帧"><a href="#支持边长帧" class="headerlink" title="支持边长帧"></a>支持边长帧</h2><p>​        有些函数，需要的局部变量是变长的。需要实现边长帧</p><p>​        为了管理变长栈帧，x86-64代码使用<code>%rbp</code>作为<strong>帧指针（Frame Pointer）</strong>。进入函数时，先将其存入到“保存寄存器区”，然后将当前的栈指针<code>%rsp</code>的值赋予<code>%rbp</code>，则函数最后可直接通过将<code>%rbp</code>的值赋予<code>%rsp</code>就能释放变长的栈帧，并且通过“保存寄存器区”来重置<code>%rbp</code>的值。</p><p>​        以以下代码为例：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593935160286-c34bc2d3-5818-40eb-96aa-b8609dd172e9.jpg" alt="image"></p><p>​        这里使用了<code>*p[n]</code>申请了一块变长的存储空间，对应的汇编代码为</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1593935174972-37adfd01-269a-43a5-8349-3a6799cf7c4f.jpeg" alt="image"></p><p>​        我们逐行进行解析</p><ol><li><p>函数入口</p></li><li><p>由于在变长栈帧中要使用<code>%rbp</code>作为初始地址，而且<code>%rsp</code>是“被调用者保存寄存器”，所以要先将其压入栈中保存原始值</p></li><li><p>将当前的栈指针<code>%rsp</code>保存到<code>%rbp</code>中，用于后续的释放空间</p></li><li><p>由于代码中对<code>i</code>访问了地址，所以需要将<code>i</code>保存到内存中，所以申请了一段16个字节大小的内存空间，用于存放<code>i</code></p></li><li><p>用<code>%rax</code>保存<code>8n+22</code></p></li><li><p><code>$-16</code>的十六进制表示为<code>0xFFFFFFFFFFFFFFF0</code>，将它和<code>%rax</code>进行与操作，相当于将<code>8n+22</code>变为16的倍数，如果n是奇数，则为<code>8n+8</code>，如果n是偶数，则为<code>8n+16</code>。</p></li><li><p>用<code>%rax</code>计算的值申请存储<code>p</code>的空间。这里涉及到了对齐操作，由于<code>p</code>中保存的元素都是8字节大小的指针，则要求整个存储该字节的整个空间大小是8的倍数，而通过5.中的计算，能够保证<code>%rax</code>是8的倍数。</p></li><li><p>由于我们要找到8的倍数用来存储指针，这里需要对其进行舍入处理，使其能够向上舍入，这里计算的就是偏移量</p></li><li><p>计算得到最近的8倍数，用来开始保存数组<code>p</code></p><p>​    最后的<code>leave</code>指令，等价于</p></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span> %rbp, %rsp #释放之前申请的变长栈帧</span><br><span class="line">popq %rbp       #重置%rbp的值</span><br></pre></td></tr></table></figure><p>​        所以变长栈帧的申请，会自动进行对齐操作，并且使用<code>%rbp</code>作为初始地址，在函数返回时释放存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 细读经典 </category>
          
          <category> 《CSAPP》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK、JRE、JVM作用与联系</title>
      <link href="jdk%E3%80%81jre%E3%80%81jvm%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%81%94%E7%B3%BB/Java_SE/Java/Java-SE/"/>
      <url>jdk%E3%80%81jre%E3%80%81jvm%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%81%94%E7%B3%BB/Java_SE/Java/Java-SE/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序的执行"><a href="#Java程序的执行" class="headerlink" title="Java程序的执行"></a>Java程序的执行</h1><p><code>Java</code>源文件的执行过程为：</p><ol><li><p>使用编辑器编写<code>Java</code>源文件<code>main.java</code></p></li><li><p>程序编译为字节码文件，<code>javac</code>编译源文件为<code>main.class</code></p></li><li><p>类文件在任意操作系统上由<code>JVM</code>运行</p></li><li><p><code>JVM</code>将字节码翻译成及其可以执行的机器码（0，1二进制）</p></li></ol><p><img src="https://i.loli.net/2020/10/07/E3s59nouImeTp2f.png" alt="Java-Execution-Flow.png"></p><h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>​        <code>JVM</code>是<code>java</code>虚拟机的缩写。所有<code>Java</code>程序首先被编译为*<em><code>.class</code><strong>的类文件，然后这类文件只能在虚拟机上运行，通过虚拟机间接与操作系统交互，将虚拟机程序解释给本地执行。<code>JVM</code>是<code>java</code>平台的基础，和实际的及其一样，他有自己的指令集，并且在</strong></em>运行时候操作不同的内存区域。***</p><p>​        <code>JVM</code>主要工作就是解释自己的指令集（字节码）到CPU的指令集或操作系统对应的系统调用，保护用户被恶意程序骚扰。<code>JVM</code>使用了许多高级的技术提高<code>java</code>性能，包括先进的<strong>内存模型</strong>，<strong>GC</strong>垃圾回收机制，<strong>自适应优化器</strong>。</p><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p><img src="https://i.loli.net/2020/10/07/T9MUcXgl6vqOs35.png" alt="JVM-Architecture.png"></p><h3 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h3><p>​        类装载器是用于加载文件的一个子系统，功能有：<code>loading</code>，<code>linking</code>，<code>initialization</code></p><ul><li><code>Loading</code><ol><li>加载类，三招加载方式：<code>Bootstrap</code>,<code>extension</code>,<code>application</code>；</li><li>当加载类文件时，<code>JVM</code>会找到某个任意类的依赖项；</li><li>第一个引导类载入器试图查找类，它会扫描lib文件夹下的rt.jar文件</li><li>如果没有找到类，则<code>extension</code>类加载器会在<code>lib\ext</code>文件下查找该类、<code>application</code>类加载器会在系统<code>classpath</code>环境变量中查询所有的Jar文件和类。</li><li>如果找不到类，抛出异常：<code>ClassNotFoundException</code></li></ol></li><li><code>Linking</code><ol><li>类加载完后，执行<code>Linking</code>，一个字节码验证器将验证生成的字节码是否正确，如果验证失败，得到一个验证错误。此时还将内存分配给类中的静态变量和静态方法。</li></ol></li><li><code>Initialization</code><ol><li>左后所有静态变量被赋予初始值，并执行静态代码块。</li></ol></li></ul><h3 id="JVM-Memory-Areas"><a href="#JVM-Memory-Areas" class="headerlink" title="JVM Memory Areas"></a>JVM Memory Areas</h3><p>​        <code>JVM</code>内存区域被分割成多个部分来存储应用程序数据的特定部分。</p><ul><li><em>Method Area</em>:存储像元数据，常量运行池，方法代码的结构</li><li><code>Heap</code>（堆区）：存储程序运行时被创建的所有对象；</li><li><code>Stack</code>（栈区）：存储本地变量和中间结果。所有这些变量都是创建他们的线程的本地变量。每个<strong>线程</strong>都有自己的JAVA stack，在创建线程时该区域被创建，所有这些本地变量被称为：<strong>线程本地变量</strong>；</li><li>PC register<strong>程序计数器</strong>：存储当前正在执行语句的物理内存地址，在<code>Java</code>中每一个线程都有自己独立的PC register</li><li><code>Java</code>支持并可以使用本地代码。许多底层代码由C/C++编写。本地方法栈保存本地代码的指令。</li></ul><h2 id="JVM-Execution-Engine（执行引擎）"><a href="#JVM-Execution-Engine（执行引擎）" class="headerlink" title="JVM Execution Engine（执行引擎）"></a>JVM Execution Engine（执行引擎）</h2><p>​        所有分配给<code>JVM</code>的代码都有Execution Engine（执行引擎）执行，执行引擎读取字节码并逐个执行。它使用两个内置的解释器和<code>JIT</code>编译器将字节码转换成机器码并执行它。</p><p><img src="https://i.loli.net/2020/10/07/SpBwu5TIezvUjPJ.png" alt="OS-Specific-Interpreters.png"></p><h3 id="Interpreter-解释器"><a href="#Interpreter-解释器" class="headerlink" title="Interpreter(解释器)"></a>Interpreter(解释器)</h3><p>​    通过查找预定义的<code>JVM</code>指令到机器指令的映射，<code>JVM</code>解释器可以将每个字节码指令转换成相应的本地指令。它直接执行字节码，不执行任何优化。</p><h3 id="JIT-Compiler（即时编译器）"><a href="#JIT-Compiler（即时编译器）" class="headerlink" title="JIT Compiler（即时编译器）"></a>JIT Compiler（即时编译器）</h3><ul><li>为了提高效率，<code>JIT Compiler</code>在运行时与JVM交互，并且适当将字节码序列编译为本地机器代码。典型的，<code>JIT Compiler</code>执行一段代码，优化代码，并将其翻译为机器代码。</li><li><code>JIT Compiler</code>是默认开启的，可以禁用。</li></ul><h1 id="什么是JRE"><a href="#什么是JRE" class="headerlink" title="什么是JRE"></a>什么是JRE</h1><p>​    JRE是一个捆绑了<code>JVM</code>和<code>libraries</code>的软件包。任何执行<code>Java</code>的程序，都需要在机器上装<code>JRE</code>，这是最低要求。</p><h1 id="什么是JDK"><a href="#什么是JDK" class="headerlink" title="什么是JDK"></a>什么是JDK</h1><p>​        <code>JDK</code>是<code>JRE</code>的超集，<code>JDk</code>包含了<code>JRE</code>的所有开发，调试和监视应用程序的工具。当要开发<code>Java</code>应用程序时，需要安装<code>JDK</code>。</p><h1 id="Jdk-JRE-JVM之间的差异"><a href="#Jdk-JRE-JVM之间的差异" class="headerlink" title="Jdk JRE JVM之间的差异"></a>Jdk JRE JVM之间的差异</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JRE = JVM + libraries to run Java Application</span><br><span class="line">JDK = JRE + tools to develop Java Application</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/07/2lfKqG1wFZ3UVaD.png" alt="JDK-JRE-JVM.png"></p><h1 id="JDK-JRE-JVM面试题"><a href="#JDK-JRE-JVM面试题" class="headerlink" title="JDK JRE JVM面试题"></a>JDK JRE JVM面试题</h1><ul><li><p><code>Jav</code>a中的类加载器有几种</p><ol><li><code>Bootstrap</code></li><li><code>extendsion</code></li><li><code>application</code></li></ol></li><li><p>类加载如何工作的`</p><p>​    类加载器扫描预定义的jar文件和类的位置。他们扫描路径中的所有类文件并寻找所需的类。如果发现则加载类，链接并初始化类文件。</p></li><li><p><code>JRE</code>和<code>JVM</code>的不同</p><p>JVM是运行时环境的规范，它执行<code>Java</code>应用程序。<code>Hotspot JVM</code>就是这种规范的一种实现。</p></li><li><p><code>interpreter</code>和<code>JIT compiler</code>的不同</p><p><code>interpreter</code>逐行解释字节码并按顺序执行，这会导致性能低下。<code>JIT compiler</code>通过在块中分析代码并在这过程中添加优化，然后编译为更优化的机器码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从此我爱上的人的人都很像你</title>
      <link href="%E4%BB%8E%E6%AD%A4%E6%88%91%E7%88%B1%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E4%BA%BA%E9%83%BD%E5%BE%88%E5%83%8F%E4%BD%A0/love_letter/%E9%9A%8F%E7%AC%94/%E5%BD%B1%E8%AF%84/"/>
      <url>%E4%BB%8E%E6%AD%A4%E6%88%91%E7%88%B1%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E4%BA%BA%E9%83%BD%E5%BE%88%E5%83%8F%E4%BD%A0/love_letter/%E9%9A%8F%E7%AC%94/%E5%BD%B1%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h1><blockquote><p>也许时间的洪荒里，每一次遇见都是一场盛大的告别；而在最好最蠢的年龄里喜欢上的那一个人，会成为最深刻的东西吧。就像影片最后的书签，泛黄了，还是年轻的笔迹青春的容颜，不会变，不会忘，也不会拥有。</p></blockquote><hr><p>​进入大学以后，偌大的校园逛了两遍，很显然，并没几个认识的人。最后还是钻进图书馆，里面很大很安静，采光良好，冬暖夏凉。据说这座图书馆是“西南第一馆”，设计感极强。</p><p>​然而对我来说，还是不够深刻，我的图书馆在一所中学里，很小，书不多，只能被称作“阅览室”。高三的时候，每次考试结束，都会躲在阅览室里，或许为了逃避结果，翻看各种各样的“闲书”。等到夜深得浓墨重彩的时候，踩着路灯拉长的影子回到租住的屋子。那样的阅读时光无疑是苦涩的隐忍的，但也同样美好难忘，那是我最寂寞的日子里最深刻的抚慰。</p><p>​也许念念不忘的，常常是最简单的。</p><p>于是无缘由的，想到一部老电影。在那部电影里，图书馆总是金黄的、诱人的，散发出一种稍纵即逝的凄凉美感。 </p><h1 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h1><p>​藤井树和藤井树，写在课桌上被人捉弄的的名字。</p><p>男孩藤井树大概是最典型的青春片男主角：帅气，恶作剧，漫不经心，会用拳头教训捉弄他的人。会在心里装一个人，忍受变迁的荒凉。</p><p>​无疑他暗恋着那个和他同名的女孩，但那样的暗恋也单纯得让人心疼，在图书馆借没人看的书，一本一本登记下他们共同的名字；站在窗台看书，眼睛不由自主；在上学路上从背后给自行车上的女孩罩上纸袋……恶作剧，是那个年龄的男孩表达情感最普遍隐晦的方式，羞涩又漫不经心，笨拙又温柔。</p><p>​而这种压抑胆怯感情也总是绵延悠远的吧，以至于离开以后也无法忘怀，爱上博子，一个和那个人如此相似的女孩。有的时候，时间并不会使人遗忘，反而使有的事成为心头的一颗朱砂痣，念念不忘，回眸浮生。也许时间的洪荒里，每一次遇见都是一场盛大的告别；而在最好最蠢的年龄里喜欢上的那一个人，会成为最深刻的东西吧。就像影片最后的书签，泛黄了，还是年轻的笔迹青春的容颜，不会变，不会忘，也不会拥有。也许有时候，有的人活在回忆里，就足够长情。忍不住引用那句被用过千万次的话：</p><p>​        <strong>“青梅枯萎，竹马老去，从此我爱上的人都很像你。”</strong></p><p>​而女藤井树呢，虽然不说，也一定是喜欢着那个男孩吧。所以在图书馆不经意望向他常常倚靠站立的窗棂，看到空空飘摇的纯白窗帘，暗自叹气；所以在夜晚摇着自行车踏板交换拿错的试卷，夜漆黑，灯光明亮；所以在很多年以后还会发现被自己整整齐齐叠在箱底的，他的试卷。</p><p>​而那时呢，都是最蠢最羞涩的年纪吧，被同学捉弄红着脸回避，在图书馆也总呆在距离最遥远的两个角落。可是后来男孩缠着绷带跑步，大家一片哄笑，而她脸上笑着，相机镜头却移不开他的影子；心事重重却不敢说。</p><p>​最后她听说他的死，那天下着雪，她在寒风中推着自行车，不住的咳嗽，眼泪也忍不住的落；最后她收到那张借书卡，写了他们共同的名字，背面有她的素描，笑着落泪着，像那时一样羞涩的想把相片藏起来，一封情书会花多少年才能送达呢？但至少最后她知道，有个傻瓜，在最好的年华里，爱过她。</p><p>​她想起与他的最后一面，也是雪天，她的父亲刚刚去世，他前来还书，没人看的《追忆似水年华》，男孩木木地对她说：“请你节哀。”然后推着自行车在雪地里走远，男孩回头，女孩在门口站着，对他甜美一笑。</p><p>贯彻一生。</p><p>也许真是这样，有的人你仅仅是遇见就用光了所有的运气。</p><h1 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h1><p>​生和死，守望与前行。</p><p>​博子大概是最苦的一个吧，不得不面对死亡、面对孤独、面对爱情幻想的寂灭、面对回忆的翻涌。寄了一封给亡灵的信件，却引出一大段与她无关的往事。</p><p>博子被回忆吞噬了，一直被秋叶拖拽着前行，一直不能从往事里脱身，一直念念不忘，四处找寻，她的爱是固执又坚忍的，她到小樽去找那个回信的人；她去藤井树的学校，用他的方式走过从前别人走过一圈又一圈的操场；歌词里说，思念一个人的滋味，就像是喝下一杯冰冷的水，然后用很长很长的时间，一颗一颗熬成热泪。</p><p>​女藤井树的父亲、藤井树、博子，都面临着同一个话题：死亡。也许这部电影从一开始就在讨论一个更宏大话题：生与死。</p><p>​父亲死去，从前的少年也死去，发了高烧在大雪淋漓的深夜里狂奔，忘不了的亡者，不敢承认的爱情…每个人，在生死面前，都孱弱渺小，都无可奈何。</p><p>不过还好，俊二给了我们一些美好的后来；</p><p>​后来，博子和秋叶一起登山，对着茫茫雪山，她大声的温柔的喊话：“你好吗？我很好。”世界用回声作答。</p><p>​后来，女藤井树平安出院，爷爷指着一棵树说那是她的守护精灵。</p><p>​后来女藤井树收到一封情书，偷走了好多不言而喻的时间。</p><p>​就像那棵和她同龄的树如今已亭亭如盖，四季轮回，万物生长。  </p><p>万世洪荒，初生与寂灭必是最残忍的故事，不过还好：</p><p>​<strong>爱和陪伴的绵延温婉会化解这种本源的痛感，我们会大步向前，对每一朵花微笑。</strong></p><hr><div align=center><font size=4 color=FF0000><strong>祝大家中秋快乐</strong></font></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 影评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的红黑树</title>
      <link href="linux%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/linux_rbtree/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
      <url>linux%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/linux_rbtree/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/</url>
      
        <content type="html"><![CDATA[<p>​        红黑树是一种Linux中广泛使用的数据结构，通常用于高精度计时器组织定制请求，文件系统管理目录，虚拟存储系统进行虚拟内存空间管理。</p><hr><h1 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h1><p>​        红黑树是一种自平衡二叉搜索树。Linux中主要使用的二叉搜索树就是红黑树。除了二叉搜索树的要求意外，红黑树还加入了一下性质：</p><blockquote><ol><li><p>所有节点要么是红色要么是黑色</p></li><li><p>所有叶子节点都是黑色</p></li><li><p>所有非叶子节点都有两个子节点</p></li><li><p>如果一个节点是红色，那他的子节点是黑色</p></li><li><p>任意一个子节点其每个叶子节点的所有简单路径都包含相同数目的黑色节点。</p></li><li><p>叶子节点不包含数据</p></li></ol></blockquote><p>​        上述条件保证了<strong>最深叶子节点的深度不会大于两倍最浅叶子节点的深度</strong>。所以，红黑树总是平衡的。为什么会这样呢。首先<code>任意一个子节点其每个叶子节点所有简单路径都包含相同数目的黑色节点</code>保证了树中最长路径是黑红交替，最短路径是全黑，所以<strong>最长路径不会超过最短路径的两倍</strong>。</p><p><img src="https://i.loli.net/2020/10/11/tsYOdQ6NgfycCiE.png" alt="image.png"></p><p>​        红黑树动画<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">演示</a></p><h1 id="Linux中的红黑树"><a href="#Linux中的红黑树" class="headerlink" title="Linux中的红黑树"></a>Linux中的红黑树</h1><p>​        Linux中文件系统声明在<code>include\linux\rbtree.h</code>中，实现在<code>lib\rbtree.c</code>中。</p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>​        Linux根节点由<code>rb_root</code>描述，创建一个红黑树，我们能要分配一个新的<code>rb_root</code>结构，并且需要初始化为特殊值<code>RB_ROOT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        其他节点由<code>rb_node</code>描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  rb_parent_color;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_RED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_BLACK 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure><p>​        注意: <code>rb_parent_color</code>成员其实是存储了<strong>父节点的地址</strong>和<strong>节点本身的颜色</strong>。</p><p>​        实现一个变量存储两种信息的关键是: <code>__attribute__((aligned(sizeof(long))))</code>, 指定该结构体对齐长度为<code>sizeof(long)</code>, 在32位机中,长度为4字节, 在64位机中长度为8字节，最后一位地址为一定是0，所以可以用来存储颜色值，想要得到地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r) ((struct rb_node *)((r)-&gt;rb_parent_color &amp; ~3))</span></span><br></pre></td></tr></table></figure><h2 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h2><p>​        与<code>rb_parent_color</code>最后一位颜色为有关的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r) ((struct rb_node *)((r)-&gt;rb_parent_color &amp; ~3))    <span class="comment">// 获取父节点地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_color(r) ((r)-&gt;rb_parent_color &amp; 1)                          <span class="comment">// 获取该节点的颜色信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_is_red(r) (!rb_color(r))                                     <span class="comment">// 判断该节点是否为红色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_is_black(r) rb_color(r)                                      <span class="comment">// 判断该节点是否为黑色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_set_red(r) do &#123; (r)-&gt;rb_parent_color &amp;= ~1; &#125; while (0)      <span class="comment">// 设置节点颜色为红色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_set_black(r) do &#123; (r)-&gt;rb_parent_color |= 1; &#125; while (0)     <span class="comment">// 设置节点颜色为黑色</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_set_parent</span><span class="params">(struct rb_node *rb, struct rb_node *p)</span> <span class="comment">// 设置父节点 &#123;</span></span></span><br><span class="line">rb-&gt;rb_parent_color = (rb-&gt;rb_parent_color &amp; 3) | (unsigned long)p; // 先清空父节点地址,再或上新的父节点地址</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_set_color</span><span class="params">(struct rb_node *rb, <span class="keyword">int</span> color)</span>          <span class="comment">// 设置节点颜色 &#123;</span></span></span><br><span class="line">rb-&gt;rb_parent_color = (rb-&gt;rb_parent_color &amp; ~1) | color;           // 先清空颜色信息, 再或上新颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        与节点有关的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_ROOT(struct rb_root) &#123; NULL, &#125;                         <span class="comment">//初始根节点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_entry(ptr, type, member) container_of(ptr, type, member)<span class="comment">//包含ptr的结构体指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_EMPTY_ROOT(root) ((root)-&gt;rb_node == NULL)              <span class="comment">//判断树是否空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_EMPTY_NODE(node) (rb_parent(node) == node)              <span class="comment">//判断节点是否空，父亲是否等于自身</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_CLEAR_NODE(node) (rb_set_parent(node, node))            <span class="comment">//设置节点为空，父亲等于自身</span></span></span><br></pre></td></tr></table></figure><p>​        container_of本身也是一个宏，定义在<code>kernel.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;                \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);           <span class="comment">//把ptr转化为type中member类型的指针__mptr</span></span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)          <span class="comment">//__mptr再减去偏移量就是type的地址</span></span><br></pre></td></tr></table></figure><p>​        <code>offsetof</code>定义在<code>stddef.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)     <span class="comment">//0作为首地址，找到member的地址就是偏移量</span></span></span><br></pre></td></tr></table></figure><h2 id="红黑树插入操作逻辑"><a href="#红黑树插入操作逻辑" class="headerlink" title="红黑树插入操作逻辑"></a>红黑树插入操作逻辑</h2><p>​        具体<a href="https://naotu.baidu.com/file/c0fa8088fa5643598484bae7e81fbb49?token=cc0609045c2ebee9">脑图</a></p><p><img src="https://i.loli.net/2020/10/11/KBygYGEclbvsDrV.png" alt="image.png"></p><blockquote><ul><li>首先建立的节点N都是红的节点</li><li>如果节点N父节点P是红色节点,</li><li>如果叔父节点U也是红色,则只需要更改父节点P和叔父节点P的颜色,再更改祖父节点G的颜色,再动态调整祖父节点G</li><li>如果叔父节点U是红色或者缺失,判断是LL,RR,LR,RL型,并进行相应的旋转</li></ul></blockquote><h2 id="红黑树删除操作逻辑"><a href="#红黑树删除操作逻辑" class="headerlink" title="红黑树删除操作逻辑"></a>红黑树删除操作逻辑</h2><p>​        具体<a href="https://naotu.baidu.com/file/70158a0693b8421b3bd0fe56cde6e361?token=6e76ac0c14851a5b">脑图</a></p><p>​        比较复杂,暂时不写</p><h1 id="Linux中关于红黑树的函数"><a href="#Linux中关于红黑树的函数" class="headerlink" title="Linux中关于红黑树的函数"></a>Linux中关于红黑树的函数</h1><p>​        Linux中关于红黑树重要的函数有:<code>__rb_rotate_left()</code>,<code>__rb_rotate_right()</code> ,<code>rb_link_node()</code>,<code>rb_insert_color()</code>,<code>rb_erase()</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __rb_rotate_left(struct rb_node *node, struct rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">right</span> = <span class="title">node</span>-&gt;<span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">rb_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;rb_right = right-&gt;rb_left))                   <span class="comment">//node的右指针指向node右孩子的左孩子</span></span><br><span class="line">        rb_set_parent(right-&gt;rb_left, node);                 <span class="comment">//node右孩子的左孩子的父亲指定为node</span></span><br><span class="line">    right-&gt;rb_left = node;</span><br><span class="line"></span><br><span class="line">    rb_set_parent(right, parent);                            <span class="comment">//node右孩子祖父指定为node原父亲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)                                              <span class="comment">//node原父亲存在，即原node不是根结点,需要修改原node父结点的指向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == parent-&gt;rb_left)</span><br><span class="line">            parent-&gt;rb_left = right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;rb_right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    <span class="comment">//原node是根结点</span></span><br><span class="line">        root-&gt;rb_node = right;</span><br><span class="line">    rb_set_parent(node, right);                             <span class="comment">//node现任父亲指定为node原右孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __rb_rotate_right(struct rb_node *node, struct rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> = <span class="title">node</span>-&gt;<span class="title">rb_left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">rb_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;rb_left = left-&gt;rb_right))                   <span class="comment">//node的左指针指向node左孩子的右孩子</span></span><br><span class="line">        rb_set_parent(left-&gt;rb_right, node);                <span class="comment">//node的左孩子的右孩子的父亲指定为node</span></span><br><span class="line">    left-&gt;rb_right = node;</span><br><span class="line"></span><br><span class="line">    rb_set_parent(left, parent);                            <span class="comment">//node左孩子的祖父指定为node原父亲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)                                             <span class="comment">//node原父亲存在,即原node不是根结点,需要修改原node父结点的指向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == parent-&gt;rb_right)</span><br><span class="line">            parent-&gt;rb_right = left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;rb_left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    </span><br><span class="line">        root-&gt;rb_node = left;                               <span class="comment">//node是根节点</span></span><br><span class="line">    rb_set_parent(node, left);                              <span class="comment">//node现任父亲指点为node原右孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        有了左转, 右转的定义,可以进程插入删除操作了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rb_insert_color</span><span class="params">(struct rb_node *node, struct rb_root *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>, *<span class="title">gparent</span>;</span></span><br><span class="line">    <span class="comment">//情况1,2：node不是根结点，即有父结点P且P是红色的</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; rb_is_red(parent))</span><br><span class="line">    &#123;</span><br><span class="line">        gparent = rb_parent(parent);</span><br><span class="line">        <span class="comment">//P是祖父G的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (parent == gparent-&gt;rb_left)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">uncle</span> = <span class="title">gparent</span>-&gt;<span class="title">rb_right</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; rb_is_red(uncle)) <span class="comment">//情况3：node的叔父结点是红色的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rb_set_black(uncle);</span><br><span class="line">                    rb_set_black(parent);</span><br><span class="line">                    rb_set_red(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况4：node和父结点P是LR型(变成LL型)</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;rb_right == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">                __rb_rotate_left(parent, root);</span><br><span class="line">                tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况5：node和父结点P是LL型</span></span><br><span class="line">            rb_set_black(parent);</span><br><span class="line">            rb_set_red(gparent);</span><br><span class="line">            __rb_rotate_right(gparent, root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//P是祖父G的右孩子，与上述情况对调</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> struct rb_node *uncle = gparent-&gt;rb_left;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; rb_is_red(uncle))</span><br><span class="line">                &#123;</span><br><span class="line">                    rb_set_black(uncle);</span><br><span class="line">                    rb_set_black(parent);</span><br><span class="line">                    rb_set_red(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;rb_left == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">                __rb_rotate_right(parent, root);</span><br><span class="line">                tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rb_set_black(parent);</span><br><span class="line">            rb_set_red(gparent);</span><br><span class="line">            __rb_rotate_left(gparent, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若node是根结点||node的父结点P是黑色的，则把根结点-&gt;黑色</span></span><br><span class="line">    rb_set_black(root-&gt;rb_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
