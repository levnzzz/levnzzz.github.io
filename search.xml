<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDK、JRE、JVM作用与联系</title>
      <link href="jdk%E3%80%81jre%E3%80%81jvm%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%81%94%E7%B3%BB/Java_SE/Java/Java-SE/"/>
      <url>jdk%E3%80%81jre%E3%80%81jvm%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%81%94%E7%B3%BB/Java_SE/Java/Java-SE/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序的执行"><a href="#Java程序的执行" class="headerlink" title="Java程序的执行"></a>Java程序的执行</h1><p><code>Java</code>源文件的执行过程为：</p><ol><li><p>使用编辑器编写<code>Java</code>源文件<code>main.java</code></p></li><li><p>程序编译为字节码文件，<code>javac</code>编译源文件为<code>main.class</code></p></li><li><p>类文件在任意操作系统上由<code>JVM</code>运行</p></li><li><p><code>JVM</code>将字节码翻译成及其可以执行的机器码（0，1二进制）</p></li></ol><p><img src="https://i.loli.net/2020/10/07/E3s59nouImeTp2f.png" alt="Java-Execution-Flow.png"></p><h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>​        <code>JVM</code>是<code>java</code>虚拟机的缩写。所有<code>Java</code>程序首先被编译为*<em><code>.class</code><strong>的类文件，然后这类文件只能在虚拟机上运行，通过虚拟机间接与操作系统交互，将虚拟机程序解释给本地执行。<code>JVM</code>是<code>java</code>平台的基础，和实际的及其一样，他有自己的指令集，并且在</strong></em>运行时候操作不同的内存区域。***</p><p>​        <code>JVM</code>主要工作就是解释自己的指令集（字节码）到CPU的指令集或操作系统对应的系统调用，保护用户被恶意程序骚扰。<code>JVM</code>使用了许多高级的技术提高<code>java</code>性能，包括先进的<strong>内存模型</strong>，<strong>GC</strong>垃圾回收机制，<strong>自适应优化器</strong>。</p><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p><img src="https://i.loli.net/2020/10/07/T9MUcXgl6vqOs35.png" alt="JVM-Architecture.png"></p><h3 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h3><p>​        类装载器是用于加载文件的一个子系统，功能有：<code>loading</code>，<code>linking</code>，<code>initialization</code></p><ul><li><code>Loading</code><ol><li>加载类，三招加载方式：<code>Bootstrap</code>,<code>extension</code>,<code>application</code>；</li><li>当加载类文件时，<code>JVM</code>会找到某个任意类的依赖项；</li><li>第一个引导类载入器试图查找类，它会扫描lib文件夹下的rt.jar文件</li><li>如果没有找到类，则<code>extension</code>类加载器会在<code>lib\ext</code>文件下查找该类、<code>application</code>类加载器会在系统<code>classpath</code>环境变量中查询所有的Jar文件和类。</li><li>如果找不到类，抛出异常：<code>ClassNotFoundException</code></li></ol></li><li><code>Linking</code><ol><li>类加载完后，执行<code>Linking</code>，一个字节码验证器将验证生成的字节码是否正确，如果验证失败，得到一个验证错误。此时还将内存分配给类中的静态变量和静态方法。</li></ol></li><li><code>Initialization</code><ol><li>左后所有静态变量被赋予初始值，并执行静态代码块。</li></ol></li></ul><h3 id="JVM-Memory-Areas"><a href="#JVM-Memory-Areas" class="headerlink" title="JVM Memory Areas"></a>JVM Memory Areas</h3><p>​        <code>JVM</code>内存区域被分割成多个部分来存储应用程序数据的特定部分。</p><ul><li><em>Method Area</em>:存储像元数据，常量运行池，方法代码的结构</li><li><code>Heap</code>（堆区）：存储程序运行时被创建的所有对象；</li><li><code>Stack</code>（栈区）：存储本地变量和中间结果。所有这些变量都是创建他们的线程的本地变量。每个<strong>线程</strong>都有自己的JAVA stack，在创建线程时该区域被创建，所有这些本地变量被称为：<strong>线程本地变量</strong>；</li><li>PC register<strong>程序计数器</strong>：存储当前正在执行语句的物理内存地址，在<code>Java</code>中每一个线程都有自己独立的PC register</li><li><code>Java</code>支持并可以使用本地代码。许多底层代码由C/C++编写。本地方法栈保存本地代码的指令。</li></ul><h2 id="JVM-Execution-Engine（执行引擎）"><a href="#JVM-Execution-Engine（执行引擎）" class="headerlink" title="JVM Execution Engine（执行引擎）"></a>JVM Execution Engine（执行引擎）</h2><p>​        所有分配给<code>JVM</code>的代码都有Execution Engine（执行引擎）执行，执行引擎读取字节码并逐个执行。它使用两个内置的解释器和<code>JIT</code>编译器将字节码转换成机器码并执行它。</p><p><img src="https://i.loli.net/2020/10/07/SpBwu5TIezvUjPJ.png" alt="OS-Specific-Interpreters.png"></p><h3 id="Interpreter-解释器"><a href="#Interpreter-解释器" class="headerlink" title="Interpreter(解释器)"></a>Interpreter(解释器)</h3><p>​    通过查找预定义的<code>JVM</code>指令到机器指令的映射，<code>JVM</code>解释器可以将每个字节码指令转换成相应的本地指令。它直接执行字节码，不执行任何优化。</p><h3 id="JIT-Compiler（即时编译器）"><a href="#JIT-Compiler（即时编译器）" class="headerlink" title="JIT Compiler（即时编译器）"></a>JIT Compiler（即时编译器）</h3><ul><li>为了提高效率，<code>JIT Compiler</code>在运行时与JVM交互，并且适当将字节码序列编译为本地机器代码。典型的，<code>JIT Compiler</code>执行一段代码，优化代码，并将其翻译为机器代码。</li><li><code>JIT Compiler</code>是默认开启的，可以禁用。</li></ul><h1 id="什么是JRE"><a href="#什么是JRE" class="headerlink" title="什么是JRE"></a>什么是JRE</h1><p>​    JRE是一个捆绑了<code>JVM</code>和<code>libraries</code>的软件包。任何执行<code>Java</code>的程序，都需要在机器上装<code>JRE</code>，这是最低要求。</p><h1 id="什么是JDK"><a href="#什么是JDK" class="headerlink" title="什么是JDK"></a>什么是JDK</h1><p>​        <code>JDK</code>是<code>JRE</code>的超集，<code>JDk</code>包含了<code>JRE</code>的所有开发，调试和监视应用程序的工具。当要开发<code>Java</code>应用程序时，需要安装<code>JDK</code>。</p><h1 id="Jdk-JRE-JVM之间的差异"><a href="#Jdk-JRE-JVM之间的差异" class="headerlink" title="Jdk JRE JVM之间的差异"></a>Jdk JRE JVM之间的差异</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JRE = JVM + libraries to run Java Application</span><br><span class="line">JDK = JRE + tools to develop Java Application</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/07/2lfKqG1wFZ3UVaD.png" alt="JDK-JRE-JVM.png"></p><h1 id="JDK-JRE-JVM面试题"><a href="#JDK-JRE-JVM面试题" class="headerlink" title="JDK JRE JVM面试题"></a>JDK JRE JVM面试题</h1><ul><li><p><code>Jav</code>a中的类加载器有几种</p><ol><li><code>Bootstrap</code></li><li><code>extendsion</code></li><li><code>application</code></li></ol></li><li><p>类加载如何工作的`</p><p>​    类加载器扫描预定义的jar文件和类的位置。他们扫描路径中的所有类文件并寻找所需的类。如果发现则加载类，链接并初始化类文件。</p></li><li><p><code>JRE</code>和<code>JVM</code>的不同</p><p>JVM是运行时环境的规范，它执行<code>Java</code>应用程序。<code>Hotspot JVM</code>就是这种规范的一种实现。</p></li><li><p><code>interpreter</code>和<code>JIT compiler</code>的不同</p><p><code>interpreter</code>逐行解释字节码并按顺序执行，这会导致性能低下。<code>JIT compiler</code>通过在块中分析代码并在这过程中添加优化，然后编译为更优化的机器码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从此我爱上的人的人都很像你</title>
      <link href="%E4%BB%8E%E6%AD%A4%E6%88%91%E7%88%B1%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E4%BA%BA%E9%83%BD%E5%BE%88%E5%83%8F%E4%BD%A0/love_letter/%E9%9A%8F%E7%AC%94/%E5%BD%B1%E8%AF%84/"/>
      <url>%E4%BB%8E%E6%AD%A4%E6%88%91%E7%88%B1%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E4%BA%BA%E9%83%BD%E5%BE%88%E5%83%8F%E4%BD%A0/love_letter/%E9%9A%8F%E7%AC%94/%E5%BD%B1%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h1><blockquote><p>也许时间的洪荒里，每一次遇见都是一场盛大的告别；而在最好最蠢的年龄里喜欢上的那一个人，会成为最深刻的东西吧。就像影片最后的书签，泛黄了，还是年轻的笔迹青春的容颜，不会变，不会忘，也不会拥有。</p></blockquote><hr><p>​进入大学以后，偌大的校园逛了两遍，很显然，并没几个认识的人。最后还是钻进图书馆，里面很大很安静，采光良好，冬暖夏凉。据说这座图书馆是“西南第一馆”，设计感极强。</p><p>​然而对我来说，还是不够深刻，我的图书馆在一所中学里，很小，书不多，只能被称作“阅览室”。高三的时候，每次考试结束，都会躲在阅览室里，或许为了逃避结果，翻看各种各样的“闲书”。等到夜深得浓墨重彩的时候，踩着路灯拉长的影子回到租住的屋子。那样的阅读时光无疑是苦涩的隐忍的，但也同样美好难忘，那是我最寂寞的日子里最深刻的抚慰。</p><p>​也许念念不忘的，常常是最简单的。</p><p>于是无缘由的，想到一部老电影。在那部电影里，图书馆总是金黄的、诱人的，散发出一种稍纵即逝的凄凉美感。 </p><h1 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h1><p>​藤井树和藤井树，写在课桌上被人捉弄的的名字。</p><p>男孩藤井树大概是最典型的青春片男主角：帅气，恶作剧，漫不经心，会用拳头教训捉弄他的人。会在心里装一个人，忍受变迁的荒凉。</p><p>​无疑他暗恋着那个和他同名的女孩，但那样的暗恋也单纯得让人心疼，在图书馆借没人看的书，一本一本登记下他们共同的名字；站在窗台看书，眼睛不由自主；在上学路上从背后给自行车上的女孩罩上纸袋……恶作剧，是那个年龄的男孩表达情感最普遍隐晦的方式，羞涩又漫不经心，笨拙又温柔。</p><p>​而这种压抑胆怯感情也总是绵延悠远的吧，以至于离开以后也无法忘怀，爱上博子，一个和那个人如此相似的女孩。有的时候，时间并不会使人遗忘，反而使有的事成为心头的一颗朱砂痣，念念不忘，回眸浮生。也许时间的洪荒里，每一次遇见都是一场盛大的告别；而在最好最蠢的年龄里喜欢上的那一个人，会成为最深刻的东西吧。就像影片最后的书签，泛黄了，还是年轻的笔迹青春的容颜，不会变，不会忘，也不会拥有。也许有时候，有的人活在回忆里，就足够长情。忍不住引用那句被用过千万次的话：</p><p>​        <strong>“青梅枯萎，竹马老去，从此我爱上的人都很像你。”</strong></p><p>​而女藤井树呢，虽然不说，也一定是喜欢着那个男孩吧。所以在图书馆不经意望向他常常倚靠站立的窗棂，看到空空飘摇的纯白窗帘，暗自叹气；所以在夜晚摇着自行车踏板交换拿错的试卷，夜漆黑，灯光明亮；所以在很多年以后还会发现被自己整整齐齐叠在箱底的，他的试卷。</p><p>​而那时呢，都是最蠢最羞涩的年纪吧，被同学捉弄红着脸回避，在图书馆也总呆在距离最遥远的两个角落。可是后来男孩缠着绷带跑步，大家一片哄笑，而她脸上笑着，相机镜头却移不开他的影子；心事重重却不敢说。</p><p>​最后她听说他的死，那天下着雪，她在寒风中推着自行车，不住的咳嗽，眼泪也忍不住的落；最后她收到那张借书卡，写了他们共同的名字，背面有她的素描，笑着落泪着，像那时一样羞涩的想把相片藏起来，一封情书会花多少年才能送达呢？但至少最后她知道，有个傻瓜，在最好的年华里，爱过她。</p><p>​她想起与他的最后一面，也是雪天，她的父亲刚刚去世，他前来还书，没人看的《追忆似水年华》，男孩木木地对她说：“请你节哀。”然后推着自行车在雪地里走远，男孩回头，女孩在门口站着，对他甜美一笑。</p><p>贯彻一生。</p><p>也许真是这样，有的人你仅仅是遇见就用光了所有的运气。</p><h1 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h1><p>​生和死，守望与前行。</p><p>​博子大概是最苦的一个吧，不得不面对死亡、面对孤独、面对爱情幻想的寂灭、面对回忆的翻涌。寄了一封给亡灵的信件，却引出一大段与她无关的往事。</p><p>博子被回忆吞噬了，一直被秋叶拖拽着前行，一直不能从往事里脱身，一直念念不忘，四处找寻，她的爱是固执又坚忍的，她到小樽去找那个回信的人；她去藤井树的学校，用他的方式走过从前别人走过一圈又一圈的操场；歌词里说，思念一个人的滋味，就像是喝下一杯冰冷的水，然后用很长很长的时间，一颗一颗熬成热泪。</p><p>​女藤井树的父亲、藤井树、博子，都面临着同一个话题：死亡。也许这部电影从一开始就在讨论一个更宏大话题：生与死。</p><p>​父亲死去，从前的少年也死去，发了高烧在大雪淋漓的深夜里狂奔，忘不了的亡者，不敢承认的爱情…每个人，在生死面前，都孱弱渺小，都无可奈何。</p><p>不过还好，俊二给了我们一些美好的后来；</p><p>​后来，博子和秋叶一起登山，对着茫茫雪山，她大声的温柔的喊话：“你好吗？我很好。”世界用回声作答。</p><p>​后来，女藤井树平安出院，爷爷指着一棵树说那是她的守护精灵。</p><p>​后来女藤井树收到一封情书，偷走了好多不言而喻的时间。</p><p>​就像那棵和她同龄的树如今已亭亭如盖，四季轮回，万物生长。  </p><p>万世洪荒，初生与寂灭必是最残忍的故事，不过还好：</p><p>​<strong>爱和陪伴的绵延温婉会化解这种本源的痛感，我们会大步向前，对每一朵花微笑。</strong></p><hr><div align=center><font size=4 color=FF0000><strong>祝大家中秋快乐</strong></font></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 影评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的红黑树</title>
      <link href="linux%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/linux_rbtree/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
      <url>linux%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/linux_rbtree/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/</url>
      
        <content type="html"><![CDATA[<p>​        红黑树是一种Linux中广泛使用的数据结构，通常用于高精度计时器组织定制请求，文件系统管理目录，虚拟存储系统进行虚拟内存空间管理。</p><hr><h1 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h1><p>​        红黑树是一种自平衡二叉搜索树。Linux中主要使用的二叉搜索树就是红黑树。除了二叉搜索树的要求意外，红黑树还加入了一下性质：</p><blockquote><ol><li><p>所有节点要么是红色要么是黑色</p></li><li><p>所有叶子节点都是黑色</p></li><li><p>所有非叶子节点都有两个子节点</p></li><li><p>如果一个节点是红色，那他的子节点是黑色</p></li><li><p>任意一个子节点其每个叶子节点的所有简单路径都包含相同数目的黑色节点。</p></li><li><p>叶子节点不包含数据</p></li></ol></blockquote><p>​        上述条件保证了<strong>最深叶子节点的深度不会大于两倍最浅叶子节点的深度</strong>。所以，红黑树总是平衡的。为什么会这样呢。首先<code>任意一个子节点其每个叶子节点所有简单路径都包含相同数目的黑色节点</code>保证了树中最长路径是黑红交替，最短路径是全黑，所以<strong>最长路径不会超过最短路径的两倍</strong>。</p><p><img src="https://i.loli.net/2020/10/11/tsYOdQ6NgfycCiE.png" alt="image.png"></p><p>​        红黑树动画<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">演示</a></p><h1 id="Linux中的红黑树"><a href="#Linux中的红黑树" class="headerlink" title="Linux中的红黑树"></a>Linux中的红黑树</h1><p>​        Linux中文件系统声明在<code>include\linux\rbtree.h</code>中，实现在<code>lib\rbtree.c</code>中。</p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>​        Linux根节点由<code>rb_root</code>描述，创建一个红黑树，我们能要分配一个新的<code>rb_root</code>结构，并且需要初始化为特殊值<code>RB_ROOT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        其他节点由<code>rb_node</code>描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  rb_parent_color;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_RED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_BLACK 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure><p>​        注意: <code>rb_parent_color</code>成员其实是存储了<strong>父节点的地址</strong>和<strong>节点本身的颜色</strong>。</p><p>​        实现一个变量存储两种信息的关键是: <code>__attribute__((aligned(sizeof(long))))</code>, 指定该结构体对齐长度为<code>sizeof(long)</code>, 在32位机中,长度为4字节, 在64位机中长度为8字节，最后一位地址为一定是0，所以可以用来存储颜色值，想要得到地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r) ((struct rb_node *)((r)-&gt;rb_parent_color &amp; ~3))</span></span><br></pre></td></tr></table></figure><h2 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h2><p>​        与<code>rb_parent_color</code>最后一位颜色为有关的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r) ((struct rb_node *)((r)-&gt;rb_parent_color &amp; ~3))    <span class="comment">// 获取父节点地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_color(r) ((r)-&gt;rb_parent_color &amp; 1)                          <span class="comment">// 获取该节点的颜色信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_is_red(r) (!rb_color(r))                                     <span class="comment">// 判断该节点是否为红色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_is_black(r) rb_color(r)                                      <span class="comment">// 判断该节点是否为黑色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_set_red(r) do &#123; (r)-&gt;rb_parent_color &amp;= ~1; &#125; while (0)      <span class="comment">// 设置节点颜色为红色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_set_black(r) do &#123; (r)-&gt;rb_parent_color |= 1; &#125; while (0)     <span class="comment">// 设置节点颜色为黑色</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_set_parent</span><span class="params">(struct rb_node *rb, struct rb_node *p)</span> <span class="comment">// 设置父节点 &#123;</span></span></span><br><span class="line">rb-&gt;rb_parent_color = (rb-&gt;rb_parent_color &amp; 3) | (unsigned long)p; // 先清空父节点地址,再或上新的父节点地址</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_set_color</span><span class="params">(struct rb_node *rb, <span class="keyword">int</span> color)</span>          <span class="comment">// 设置节点颜色 &#123;</span></span></span><br><span class="line">rb-&gt;rb_parent_color = (rb-&gt;rb_parent_color &amp; ~1) | color;           // 先清空颜色信息, 再或上新颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        与节点有关的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_ROOT(struct rb_root) &#123; NULL, &#125;                         <span class="comment">//初始根节点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_entry(ptr, type, member) container_of(ptr, type, member)<span class="comment">//包含ptr的结构体指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_EMPTY_ROOT(root) ((root)-&gt;rb_node == NULL)              <span class="comment">//判断树是否空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_EMPTY_NODE(node) (rb_parent(node) == node)              <span class="comment">//判断节点是否空，父亲是否等于自身</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_CLEAR_NODE(node) (rb_set_parent(node, node))            <span class="comment">//设置节点为空，父亲等于自身</span></span></span><br></pre></td></tr></table></figure><p>​        container_of本身也是一个宏，定义在<code>kernel.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;                \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);           <span class="comment">//把ptr转化为type中member类型的指针__mptr</span></span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)          <span class="comment">//__mptr再减去偏移量就是type的地址</span></span><br></pre></td></tr></table></figure><p>​        <code>offsetof</code>定义在<code>stddef.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)     <span class="comment">//0作为首地址，找到member的地址就是偏移量</span></span></span><br></pre></td></tr></table></figure><h2 id="红黑树插入操作逻辑"><a href="#红黑树插入操作逻辑" class="headerlink" title="红黑树插入操作逻辑"></a>红黑树插入操作逻辑</h2><p>​        具体<a href="https://naotu.baidu.com/file/c0fa8088fa5643598484bae7e81fbb49?token=cc0609045c2ebee9">脑图</a></p><p><img src="https://i.loli.net/2020/10/11/KBygYGEclbvsDrV.png" alt="image.png"></p><blockquote><ul><li>首先建立的节点N都是红的节点</li><li>如果节点N父节点P是红色节点,</li><li>如果叔父节点U也是红色,则只需要更改父节点P和叔父节点P的颜色,再更改祖父节点G的颜色,再动态调整祖父节点G</li><li>如果叔父节点U是红色或者缺失,判断是LL,RR,LR,RL型,并进行相应的旋转</li></ul></blockquote><h2 id="红黑树删除操作逻辑"><a href="#红黑树删除操作逻辑" class="headerlink" title="红黑树删除操作逻辑"></a>红黑树删除操作逻辑</h2><p>​        具体<a href="https://naotu.baidu.com/file/70158a0693b8421b3bd0fe56cde6e361?token=6e76ac0c14851a5b">脑图</a></p><p>​        比较复杂,暂时不写</p><h1 id="Linux中关于红黑树的函数"><a href="#Linux中关于红黑树的函数" class="headerlink" title="Linux中关于红黑树的函数"></a>Linux中关于红黑树的函数</h1><p>​        Linux中关于红黑树重要的函数有:<code>__rb_rotate_left()</code>,<code>__rb_rotate_right()</code> ,<code>rb_link_node()</code>,<code>rb_insert_color()</code>,<code>rb_erase()</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __rb_rotate_left(struct rb_node *node, struct rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">right</span> = <span class="title">node</span>-&gt;<span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">rb_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;rb_right = right-&gt;rb_left))                   <span class="comment">//node的右指针指向node右孩子的左孩子</span></span><br><span class="line">        rb_set_parent(right-&gt;rb_left, node);                 <span class="comment">//node右孩子的左孩子的父亲指定为node</span></span><br><span class="line">    right-&gt;rb_left = node;</span><br><span class="line"></span><br><span class="line">    rb_set_parent(right, parent);                            <span class="comment">//node右孩子祖父指定为node原父亲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)                                              <span class="comment">//node原父亲存在，即原node不是根结点,需要修改原node父结点的指向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == parent-&gt;rb_left)</span><br><span class="line">            parent-&gt;rb_left = right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;rb_right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    <span class="comment">//原node是根结点</span></span><br><span class="line">        root-&gt;rb_node = right;</span><br><span class="line">    rb_set_parent(node, right);                             <span class="comment">//node现任父亲指定为node原右孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __rb_rotate_right(struct rb_node *node, struct rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> = <span class="title">node</span>-&gt;<span class="title">rb_left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">rb_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;rb_left = left-&gt;rb_right))                   <span class="comment">//node的左指针指向node左孩子的右孩子</span></span><br><span class="line">        rb_set_parent(left-&gt;rb_right, node);                <span class="comment">//node的左孩子的右孩子的父亲指定为node</span></span><br><span class="line">    left-&gt;rb_right = node;</span><br><span class="line"></span><br><span class="line">    rb_set_parent(left, parent);                            <span class="comment">//node左孩子的祖父指定为node原父亲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)                                             <span class="comment">//node原父亲存在,即原node不是根结点,需要修改原node父结点的指向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == parent-&gt;rb_right)</span><br><span class="line">            parent-&gt;rb_right = left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;rb_left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    </span><br><span class="line">        root-&gt;rb_node = left;                               <span class="comment">//node是根节点</span></span><br><span class="line">    rb_set_parent(node, left);                              <span class="comment">//node现任父亲指点为node原右孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        有了左转, 右转的定义,可以进程插入删除操作了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rb_insert_color</span><span class="params">(struct rb_node *node, struct rb_root *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>, *<span class="title">gparent</span>;</span></span><br><span class="line">    <span class="comment">//情况1,2：node不是根结点，即有父结点P且P是红色的</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; rb_is_red(parent))</span><br><span class="line">    &#123;</span><br><span class="line">        gparent = rb_parent(parent);</span><br><span class="line">        <span class="comment">//P是祖父G的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (parent == gparent-&gt;rb_left)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">uncle</span> = <span class="title">gparent</span>-&gt;<span class="title">rb_right</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; rb_is_red(uncle)) <span class="comment">//情况3：node的叔父结点是红色的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rb_set_black(uncle);</span><br><span class="line">                    rb_set_black(parent);</span><br><span class="line">                    rb_set_red(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况4：node和父结点P是LR型(变成LL型)</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;rb_right == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">                __rb_rotate_left(parent, root);</span><br><span class="line">                tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况5：node和父结点P是LL型</span></span><br><span class="line">            rb_set_black(parent);</span><br><span class="line">            rb_set_red(gparent);</span><br><span class="line">            __rb_rotate_right(gparent, root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//P是祖父G的右孩子，与上述情况对调</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> struct rb_node *uncle = gparent-&gt;rb_left;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; rb_is_red(uncle))</span><br><span class="line">                &#123;</span><br><span class="line">                    rb_set_black(uncle);</span><br><span class="line">                    rb_set_black(parent);</span><br><span class="line">                    rb_set_red(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;rb_left == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">                __rb_rotate_right(parent, root);</span><br><span class="line">                tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rb_set_black(parent);</span><br><span class="line">            rb_set_red(gparent);</span><br><span class="line">            __rb_rotate_left(gparent, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若node是根结点||node的父结点P是黑色的，则把根结点-&gt;黑色</span></span><br><span class="line">    rb_set_black(root-&gt;rb_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
