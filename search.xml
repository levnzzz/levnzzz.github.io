<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDK、JRE、JVM作用与联系</title>
      <link href="jdk%E3%80%81jre%E3%80%81jvm%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%81%94%E7%B3%BB/Java_SE/Java/Java-SE/"/>
      <url>jdk%E3%80%81jre%E3%80%81jvm%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%81%94%E7%B3%BB/Java_SE/Java/Java-SE/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序的执行"><a href="#Java程序的执行" class="headerlink" title="Java程序的执行"></a>Java程序的执行</h1><p><code>Java</code>源文件的执行过程为：</p><ol><li><p>使用编辑器编写<code>Java</code>源文件<code>main.java</code></p></li><li><p>程序编译为字节码文件，<code>javac</code>编译源文件为<code>main.class</code></p></li><li><p>类文件在任意操作系统上由<code>JVM</code>运行</p></li><li><p><code>JVM</code>将字节码翻译成及其可以执行的机器码（0，1二进制）</p></li></ol><p><img src="https://i.loli.net/2020/10/07/E3s59nouImeTp2f.png" alt="Java-Execution-Flow.png"></p><h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>​        <code>JVM</code>是<code>java</code>虚拟机的缩写。所有<code>Java</code>程序首先被编译为*<em><code>.class</code><strong>的类文件，然后这类文件只能在虚拟机上运行，通过虚拟机间接与操作系统交互，将虚拟机程序解释给本地执行。<code>JVM</code>是<code>java</code>平台的基础，和实际的及其一样，他有自己的指令集，并且在</strong></em>运行时候操作不同的内存区域。***</p><p>​        <code>JVM</code>主要工作就是解释自己的指令集（字节码）到CPU的指令集或操作系统对应的系统调用，保护用户被恶意程序骚扰。<code>JVM</code>使用了许多高级的技术提高<code>java</code>性能，包括先进的<strong>内存模型</strong>，<strong>GC</strong>垃圾回收机制，<strong>自适应优化器</strong>。</p><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p><img src="https://i.loli.net/2020/10/07/T9MUcXgl6vqOs35.png" alt="JVM-Architecture.png"></p><h3 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h3><p>​        类装载器是用于加载文件的一个子系统，功能有：<code>loading</code>，<code>linking</code>，<code>initialization</code></p><ul><li><code>Loading</code><ol><li>加载类，三招加载方式：<code>Bootstrap</code>,<code>extension</code>,<code>application</code>；</li><li>当加载类文件时，<code>JVM</code>会找到某个任意类的依赖项；</li><li>第一个引导类载入器试图查找类，它会扫描lib文件夹下的rt.jar文件</li><li>如果没有找到类，则<code>extension</code>类加载器会在<code>lib\ext</code>文件下查找该类、<code>application</code>类加载器会在系统<code>classpath</code>环境变量中查询所有的Jar文件和类。</li><li>如果找不到类，抛出异常：<code>ClassNotFoundException</code></li></ol></li><li><code>Linking</code><ol><li>类加载完后，执行<code>Linking</code>，一个字节码验证器将验证生成的字节码是否正确，如果验证失败，得到一个验证错误。此时还将内存分配给类中的静态变量和静态方法。</li></ol></li><li><code>Initialization</code><ol><li>左后所有静态变量被赋予初始值，并执行静态代码块。</li></ol></li></ul><h3 id="JVM-Memory-Areas"><a href="#JVM-Memory-Areas" class="headerlink" title="JVM Memory Areas"></a>JVM Memory Areas</h3><p>​        <code>JVM</code>内存区域被分割成多个部分来存储应用程序数据的特定部分。</p><ul><li><em>Method Area</em>:存储像元数据，常量运行池，方法代码的结构</li><li><code>Heap</code>（堆区）：存储程序运行时被创建的所有对象；</li><li><code>Stack</code>（栈区）：存储本地变量和中间结果。所有这些变量都是创建他们的线程的本地变量。每个<strong>线程</strong>都有自己的JAVA stack，在创建线程时该区域被创建，所有这些本地变量被称为：<strong>线程本地变量</strong>；</li><li>PC register<strong>程序计数器</strong>：存储当前正在执行语句的物理内存地址，在<code>Java</code>中每一个线程都有自己独立的PC register</li><li><code>Java</code>支持并可以使用本地代码。许多底层代码由C/C++编写。本地方法栈保存本地代码的指令。</li></ul><h2 id="JVM-Execution-Engine（执行引擎）"><a href="#JVM-Execution-Engine（执行引擎）" class="headerlink" title="JVM Execution Engine（执行引擎）"></a>JVM Execution Engine（执行引擎）</h2><p>​        所有分配给<code>JVM</code>的代码都有Execution Engine（执行引擎）执行，执行引擎读取字节码并逐个执行。它使用两个内置的解释器和<code>JIT</code>编译器将字节码转换成机器码并执行它。</p><p><img src="https://i.loli.net/2020/10/07/SpBwu5TIezvUjPJ.png" alt="OS-Specific-Interpreters.png"></p><h3 id="Interpreter-解释器"><a href="#Interpreter-解释器" class="headerlink" title="Interpreter(解释器)"></a>Interpreter(解释器)</h3><p>​    通过查找预定义的<code>JVM</code>指令到机器指令的映射，<code>JVM</code>解释器可以将每个字节码指令转换成相应的本地指令。它直接执行字节码，不执行任何优化。</p><h3 id="JIT-Compiler（即时编译器）"><a href="#JIT-Compiler（即时编译器）" class="headerlink" title="JIT Compiler（即时编译器）"></a>JIT Compiler（即时编译器）</h3><ul><li>为了提高效率，<code>JIT Compiler</code>在运行时与JVM交互，并且适当将字节码序列编译为本地机器代码。典型的，<code>JIT Compiler</code>执行一段代码，优化代码，并将其翻译为机器代码。</li><li><code>JIT Compiler</code>是默认开启的，可以禁用。</li></ul><h1 id="什么是JRE"><a href="#什么是JRE" class="headerlink" title="什么是JRE"></a>什么是JRE</h1><p>​    JRE是一个捆绑了<code>JVM</code>和<code>libraries</code>的软件包。任何执行<code>Java</code>的程序，都需要在机器上装<code>JRE</code>，这是最低要求。</p><h1 id="什么是JDK"><a href="#什么是JDK" class="headerlink" title="什么是JDK"></a>什么是JDK</h1><p>​        <code>JDK</code>是<code>JRE</code>的超集，<code>JDk</code>包含了<code>JRE</code>的所有开发，调试和监视应用程序的工具。当要开发<code>Java</code>应用程序时，需要安装<code>JDK</code>。</p><h1 id="Jdk-JRE-JVM之间的差异"><a href="#Jdk-JRE-JVM之间的差异" class="headerlink" title="Jdk JRE JVM之间的差异"></a>Jdk JRE JVM之间的差异</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JRE = JVM + libraries to run Java Application</span><br><span class="line">JDK = JRE + tools to develop Java Application</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/07/2lfKqG1wFZ3UVaD.png" alt="JDK-JRE-JVM.png"></p><h1 id="JDK-JRE-JVM面试题"><a href="#JDK-JRE-JVM面试题" class="headerlink" title="JDK JRE JVM面试题"></a>JDK JRE JVM面试题</h1><ul><li><p><code>Jav</code>a中的类加载器有几种</p><ol><li><code>Bootstrap</code></li><li><code>extendsion</code></li><li><code>application</code></li></ol></li><li><p>类加载如何工作的`</p><p>​    类加载器扫描预定义的jar文件和类的位置。他们扫描路径中的所有类文件并寻找所需的类。如果发现则加载类，链接并初始化类文件。</p></li><li><p><code>JRE</code>和<code>JVM</code>的不同</p><p>JVM是运行时环境的规范，它执行<code>Java</code>应用程序。<code>Hotspot JVM</code>就是这种规范的一种实现。</p></li><li><p><code>interpreter</code>和<code>JIT compiler</code>的不同</p><p><code>interpreter</code>逐行解释字节码并按顺序执行，这会导致性能低下。<code>JIT compiler</code>通过在块中分析代码并在这过程中添加优化，然后编译为更优化的机器码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序的机器级表示</title>
      <link href="%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/post/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/"/>
      <url>%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/post/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一节-基础"><a href="#第一节-基础" class="headerlink" title="第一节 基础"></a>第一节 基础</h1><p>​        对应书中3.1～3.5，主要包含X86指令系统中基础的指令。</p><hr><p><strong>小点：</strong></p><ul><li>生成四字节的数据指令会把高位4个字节置0.</li><li>寄存器内存引用需要使用64位寄存器</li><li>局部变量只需要保存在寄存器中</li><li>对于程序而言，缓存是不可见的</li></ul><hr><h2 id="1-机器级表示"><a href="#1-机器级表示" class="headerlink" title="1. 机器级表示"></a>1. 机器级表示</h2><p>​        高级语言知识低级语言的抽象，最后都需要转化成对应机器的机器语言。低级语言我们可以看到更多机器细节的数据。</p><ul><li><p>程序计数器<strong>（PC）</strong>：显示下一条指令地址</p></li><li><p>程序使用的寄存器<strong>（Register）</strong>：保存变量</p></li><li><p>只有几位的<strong>状态码（Condition Codes）</strong>：指示指令的运行结果</p><ul><li><p><strong>ZF：</strong>零标志，最近的操作得到的结果是否为0。</p></li><li><p><strong>无符号数：</strong></p><ul><li><strong>CF：</strong>进位标志，最近的操作使得<strong>最高位产生进位</strong>。可用来检查无符号数是否存在溢出。</li></ul></li><li><p><strong>补码：</strong></p><ul><li><p><strong>SF：</strong>符号标志，最近的操作得到的<strong>结果为负数</strong>。</p></li><li><p><strong>OF：</strong>溢出标志，最近的操作导致补码溢出（<strong>可以通过符号位进一步判断是正溢出还是负溢出</strong>）。</p></li></ul></li></ul></li></ul><p>  对于机器级编程，有两个抽象：</p><ul><li><p>由<strong>指令集体系结构</strong>或<strong>指令集架构（Instruction Set Architecture，ISA）</strong>来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA都将程序的行为描述为按顺序执行每条指令。这是编译器的目标，提供一系列指令告诉机器要做什么。而<strong>微结构（Microarchitecture）</strong>是指这个架构的实现。</p></li><li><p>机器级程序使用的内存地址是虚拟内存地址，使得内存模型看上去是一个很大的连续字节数组。然后由操作系统将其转换为真实的物理内存地址。在任意给定的时刻，只有有限的一部分虚拟地址是合法的。</p></li></ul><p>  本文是基于<strong>x86-64</strong>体系结构，属于<strong>CISC复杂指令集</strong>。另一种主流体系结构<strong>ARM</strong>属于<strong>RICS精简指令集</strong>。</p><h2 id="2-程序编码"><a href="#2-程序编码" class="headerlink" title="2 程序编码"></a>2 程序编码</h2><p>  ​    计算机直接执行机器代码，所以需要将源代码转化为机器代码：</p><pre><code>1. **预处理**：扩展源文件，插入所有`#include`指令的文件，扩展所有用`#define`声明指定的宏。2. **编译**：输出汇编代码3. **汇编**：将汇编代码转化为二进制文件，也叫**可重新定位目标文件**，其中全局地址还没有填入。4. **链接器**：将目标代码文件和库函数合并，填入全局地址，形成**可执行代码文件**。</code></pre><p><img src="https://i.loli.net/2020/10/17/DIK4LhBPyMck6A9.jpg" alt="1596246571373-0c5d9ef2-7959-43ef-9cca-438c9d04cc44.jpg"></p><h3 id="2-1-编译器"><a href="#2-1-编译器" class="headerlink" title="2.1 编译器"></a>2.1 编译器</h3><p>​        文件<code>mstore.c</code>包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y,<span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x,y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过<code>gcc -Og -s mstore.c将其编译成汇编代码，得到</code>mstore.s`，其中：</p><ul><li><code>-Og</code>,是生成机器代码的优化等级，这个表示编译器会生成符合原始C代码整体结构的机器代码，这是用于调试的级别，便于我们学习观察。其他的<code>-O1</code>或<code>-O2</code>会得到更好的程序性能，但是机器代码和源代码的关系就比较难以理解。</li><li><code>-S</code>：只生成到汇编代码</li></ul><p><img src="https://i.loli.net/2020/10/17/q1jNgCZExT5RuDJ.jpg" alt="1596246571396-de693f7c-6997-4a2c-8af1-ab0155184c88.jpg"></p><p>​        所有开头几行都是知道汇编器和链接器的伪指令，汇编代码从<code>multstore：</code>开始。</p><h3 id="2-2-汇编器"><a href="#2-2-汇编器" class="headerlink" title="2.2 汇编器"></a>2.2 汇编器</h3><p>​        我们可以运行<code>gcc -Og -c mstore.c</code>来进行编译和汇编，会生成二进制文件<code>mstore.o</code>，它是对一系列指令的编码，机器直接执行这些字节序列，对源代码一无所知。</p><p>​        我们可以通过<strong>反汇编器（Disassembler）</strong>来将机器代码转化为类似汇编代码的格式，在Linux中，我们可以运行<code>objdump -d mstore.o</code>，可以得到：</p><p><img src="https://i.loli.net/2020/10/17/7AFXQuzWpOJiq8k.jpg" alt="1596246571371-864fd884-6591-4bd0-a817-1c614c0c924a.jpg"></p><ul><li>每个指令需要的字节数不同</li><li>每个指令有自己对应的编码</li></ul><h3 id="2-3-链接器"><a href="#2-3-链接器" class="headerlink" title="2.3 链接器"></a>2.3 链接器</h3><p>​        使用链接器将目标代码格式转化为可执行代码，<strong>要求</strong>：目标代码中必须含有<code>main.c</code>主函数作为程序的入口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = a*b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后运行命令<code>gcc -Og -o prog main.c mstore.c</code>将main.c和mstore.c链接起来，并添加启动和终止程序的代码，以及用来与操作系统交互的代码生成可执行代码，生成最终的可执行文件<code>prog</code>。我们通过对其反汇编，可以得到如下内容</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571372-c7389431-f144-45ad-8d8a-34fbde610106.jpeg" alt="image"></p><p>可以发现和汇编器生成的<strong>区别有</strong>：</p><ol><li>链接器将代码移到了新的地址范围内。</li><li>第4行中，链接器补充了调用函数<code>mult2</code>需要使用的地址。</li><li>多了两行<code>nop</code>，可以使得函数代码变成16字节，更好放置下一个代码。</li></ol><p>大概了解后，我们需要开始学习汇编代码了，</p><h2 id="3-数据格式"><a href="#3-数据格式" class="headerlink" title="3. 数据格式"></a>3. 数据格式</h2><p>​        在x84-64中C语言数据类型的大小如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571435-8418dc0c-5d7d-494d-b265-b0f7e619d533.jpeg" alt="image"></p><p>​        大多数GCC生成的汇编代码指令都有一个表示操作数大小的后缀。<strong>注意：</strong>汇编代码使用<code>l</code>表示4字节整数和 8字节双精度浮点数，由于浮点数使用完全不同的指令和寄存器，所以不会产生冲突。</p><h2 id="4-访问信息"><a href="#4-访问信息" class="headerlink" title="4. 访问信息"></a>4. 访问信息</h2><p>​        一个x86-64的CPU中包含16个存储64位的寄存器，可用来存储<strong>整数数据和指针</strong>，有些寄存器有特殊用途：</p><ul><li>栈指针：<code>%rsp</code>来存储栈顶</li><li>比如<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>和<code>%r9</code>用来保存函数的参数</li><li><code>%rip</code>用来保存当前执行指令的地址</li><li><code>%rax</code>用来存放函数的返回值</li></ul><p>​        在大部分情况下这些寄存器都可用来保存程序数据。并且有一组标准编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值，以及存储局部和临时数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571434-0f63c725-20b9-4d46-a79c-30b42758ed60.jpeg" alt="image"></p><p>​        我们可以对这些寄存器的低位字节中存放的不同大小的数据进行操作，<code>%r</code>表示64位、<code>%e</code>表示32位。</p><p>​        对于生成小于8字节结果的指令，<strong>有两条规则：</strong></p><ol><li>生成1字节或2字节数据的指令会保持剩下的字节内容不变；</li><li><strong>生成4字节数据的指令会把高位 4个字节置零。</strong></li></ol><h3 id="4-1-操作数指示符"><a href="#4-1-操作数指示符" class="headerlink" title="4.1 操作数指示符"></a>4.1 操作数指示符</h3><p>​        大多数指令由一个或多个操作数（Operand），指示出一个操作中要使用的元数据值，以及放置结果的目的位置。x86-64支持的操作数格式如下</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571570-b95e003d-0b8e-423a-9660-a73ad10eb597.jpeg" alt="image"></p><p>​        其中包含三种类型：</p><ul><li><strong>立即数（Immediate）：</strong>用来表示常数值，书写格式是在<code>$</code>后面跟一个标准C表示法表示的整数。</li><li><strong>寄存器（Register）：</strong>表示某个寄存器的内容。</li><li><strong>内存引用：</strong>它会根据计算出来的地址访问某个内存位置。有不同的寻址模式，最常用的是 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571430-c4ea36e3-2c3b-4a3c-bb51-a38c0e508437.svg" alt="image"> ，其中，<strong>要求寄存器大小都是64位的</strong>，才能完整索引整个虚拟内存空间，并且不能使用<code>%rsp</code>。</li></ul><h3 id="4-2-数据传送指令"><a href="#4-2-数据传送指令" class="headerlink" title="4.2 数据传送指令"></a>4.2 数据传送指令</h3><p>​        最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。</p><h4 id="4-2-1-源和目的大小匹配"><a href="#4-2-1-源和目的大小匹配" class="headerlink" title="4.2.1 源和目的大小匹配"></a>4.2.1 源和目的大小匹配</h4><p>​        该类数据传送指令将数据从一个位置复制到另一个位置，不做任何变化。不同类型指令指定了不同的数据大小（一个字为两个字节）。<strong>源操作数</strong>是一个立即数，可以保存在寄存器或内存中；<strong>目的操作数</strong>是一个位置，可以是寄存器或内存位置。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596246571430-a0cfb4ec-f13e-4512-9850-de2979cd8495.jpg" alt="image"></p><p><strong>注意：</strong></p><ul><li>两个操作数不能同时为内存地址。如果要在两个内存位置传输数据，必须用一个寄存器进行中转。</li><li>使用到的寄存器大小一定要和指令最后一个字符指定的大小匹配。</li><li><code>movl</code>以寄存器为目的时，会将寄存器的高位4字节置0。</li><li>如果用<code>movq</code>来传输立即数时，该立即数只能表示为<strong>32位补码，然后扩展到64位的值</strong>。而<code>movabsq</code>能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571422-7e08d379-dcd5-4401-bcf9-d710a0b6f68a.jpeg" alt="image"></p><h4 id="4-2-2-源寄存器小于目的寄存器"><a href="#4-2-2-源寄存器小于目的寄存器" class="headerlink" title="4.2.2 源寄存器小于目的寄存器"></a>4.2.2 源寄存器小于目的寄存器</h4><p>​        在将较小的源值复制到较大的目的时，提供两个类<code>MOVZ</code>和<code>MOVS</code>。<code>MOVZ</code>是将目的中剩余的字节填充0，<code>MOVS</code>是将目的剩余的字节填充符号位的值。它们每条指令后面吗都有两个字符，分别表示源大小和目的大小。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571394-65c9a956-e217-499f-adeb-3fe36784f3c9.jpeg" alt="image"></p><p><strong>注意：</strong></p><ul><li><p>不存在<code>movzlq</code>，可以直接使用<code>movl</code>。因为当使用<code>movl</code>传输数据到32位目的寄存器中时， 会自动将目的寄存器的高位4字节置零。</p></li><li><p><code>cltq</code>没有操作数，总是以<code>%eax</code>作为源寄存器，以<code>%rax</code>作为目的寄存器，等价于<code>movslq %eax,%rax</code>。</p><p><strong>当源寄存器大于目的寄存器时，会报错。</strong></p></li></ul><p><strong>例1：</strong></p><p>​        给定代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exchange</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        其中，<code>xp</code>保存在<code>%rdi</code>中，<code>y</code>保存在<code>%rsi</code>中，补充以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exchange:</span><br><span class="line">    ______________</span><br><span class="line">    ______________</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>​        首先，像<code>x</code>这样的局部变量，通常会保存在寄存器而不是内存中，因为访问寄存器会比内存快很多。所以第一行就是将<code>*xp</code>移到一个寄存器中，因为<code>xp</code>保存在<code>%rdi</code>中，而指针<code>xp</code>保存的是存储数据的内存地址，所以要用<code>(%rdi)</code>来访问对应的内存数据来作为源，而<code>long</code>数据类型保存的是64位数据，所以需要使用<code>movq</code>来传输。所以第一行是<code>movq (%rdi),%rax</code>。接下来将<code>y</code>中的数据保存到指针对应的内存地址中就行了，所以是<code>movq %rsi,(%rdi)</code>。</p><p><strong>例2：</strong></p><p>​        有以下强制类型转换代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src_t *sp;</span><br><span class="line">dest_t *dp;</span><br><span class="line">*dp &#x3D; (dest_t) *sp;</span><br></pre></td></tr></table></figure><p>​        其中<code>sp</code>和<code>dp</code>分别保存在寄存器<code>%rdi</code>和<code>%rsi</code>中。对于不同的<code>src_t</code>和<code>dest_t</code>，我们推测它的汇编指令。</p><ul><li><code>long</code>–&gt; <code>long</code>： 由于两个类型相同，照理说是可以直接<code>movq (%rdi), (%rsi)</code>，但是x86-64限制不能在内存地址间传输，所以需要先经过一个寄存器，所以汇编指令为：<code>movq (%rdi), %rax</code>，<code>movq %rax, (%rsi)</code>。</li><li><code>char</code>–&gt; <code>int</code>：两个都是有符号数，而<code>char</code>时1个字节，<code>int</code>是4个字节，所以要先对数据进行有符号扩展，即<code>movsbl (%rdi), %eax</code>。然后将其转到对应的内存地址<code>movl %eax, (%rsi)</code>。</li><li><code>char</code>–&gt; <code>unsigned</code>：当大小和符号同时改变时，C中是先改变大小，再改变符号的。而<code>char</code>是有符号数，所以先对其进行有符号扩展<code>movsbl (%rdi), %eax</code>。由于有符号数和无符号数之间的位向量是相同的，所以直接将其保存到对应的内存地址就行，即<code>movl %eax, (%rsi)</code>。</li><li><code>unsigned char</code>–&gt; <code>long</code>：由于<code>long</code>是64位的，而且对<code>unsigned char</code>进行无符号扩展时是补充0，所以我们可以直接对低32位赋值，这样高4字节也会自动变成零，即<code>movzbl (%rdi),%eax</code>。然后将其整个转到对应的内存地址<code>movq %rax, (%rsi)</code>。</li><li><code>int</code>–&gt; <code>char</code>：因为<code>int</code>是32位的，而<code>char</code>是8位的，所以要直接对其进行截断。这里是先将其整个移到寄存器中，然后再将部分保存到内存中，即<code>movl (%rdi), %eax</code>，<code>movb %al, (%rsi)</code>。</li><li><code>unsigned</code>–&gt; <code>unsigned char</code>： 上同。</li><li><code>char</code>–&gt; <code>short</code>：<code>movbw (%rdi), %ax</code>，<code>movw %ax, (%rsi)</code>。</li></ul><p><strong>综上：</strong></p><ol><li>两个指针之间进行传输，由于是直接对内存进行操作的，所以需要先经过一个寄存器。</li><li>小的数据类型转换到大的数据类型，是根据前面的数据类型决定是<code>MOVZ</code>还是<code>MOVS</code>。</li><li>大的数据类型转换到小的数据类型时，先将其保存得到寄存器中，再将部分保存到内存中。</li></ol><h3 id="4-3-压入和弹出栈数据"><a href="#4-3-压入和弹出栈数据" class="headerlink" title="4.3 压入和弹出栈数据"></a>4.3 压入和弹出栈数据</h3><p>​        栈在处理过程调用中起着至关重要的作用，在内存中栈顶位于较小的内存地址中。入栈时，就需要先将栈顶地址增加，由此指向了要放数据的地址，然后将数据存入对应的内存中。出栈时，先从内存中取出对应的数据，然后再将栈地址减小，来指向当前的栈顶地址。</p><p>​        这里使用一个特殊的寄存器<code>%rsp</code>来保存栈顶内存地址。并且提供两个操作指令<code>PUSH</code>和<code>POP</code>分别对应入栈和出栈，以操作64位数据为例，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596246571443-7e5a47f2-693a-4b30-8530-2b86412b4bee.jpg" alt="image"></p><p>​        （这里的8是指8个字节）</p><p>​        因为栈和程序代码和其他的程序数据都放在同一内存中，所以我们可以根据<code>%rsp</code>来访问栈中的任意位置。假设栈顶元素是8字节的，则<code>movq 8(%rsp), %rdx</code>表示将第二个元素保存在寄存器<code>%rdx</code>中。</p><h2 id="5-算数和逻辑运算"><a href="#5-算数和逻辑运算" class="headerlink" title="5. 算数和逻辑运算"></a>5. 算数和逻辑运算</h2><p>​        以下列出了x86-64中的一些算数和逻辑操作，除了<code>leaq</code>以外，其他都有对不同大小数据的指令。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571419-0e7de786-d619-43f8-837f-a0b22286a693.jpeg" alt="image"></p><ul><li><code>leaq S D</code>是将S计算出的地址付给寄存器D。通常会被用来执行加法和有限形式的乘法。比如对于比例变址寻址 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571478-f4f9ae60-a150-403a-82e7-91c88d313feb.svg" alt="image"> ，得到的地址会是 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571462-26241dd9-81c1-4aac-8697-b20f020c2f9e.svg" alt="image"> ，所以<code>leaq Imm(%rax, %rbx, s), %rcx</code>就是将<code>Imm+%rax+s*%rbx</code>保存到<code>%rcx</code>。<strong>注意：</strong>目的操作数只能是寄存器。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1596246571554-3b0b746e-a2c4-45d3-a6f3-4f79ebc5ece6.png" alt="image"></p><ul><li><strong>一元操作符</strong>中，操作数可以是寄存器也可以是内存地址。</li><li><strong>二元操作符</strong>中，第一个操作数可以是立即数、寄存器或内存地址；第二个操作数可以是寄存器或内存地址。</li><li><strong>移位操作</strong>中，第一个操作数可以是立即数或放在<strong>寄存器<code>%cl</code>**中，第二个操作数可以是寄存器或内存位置。</strong>注意：**如果我们对w位的数据进行移位，则只考虑<code>%cl</code>中 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1596246571514-3501c99d-d521-42c5-8e75-d2063f2325bb.svg" alt="image"> 位，保证不会将数据移出边界。 比如<code>salb</code>只会考虑低3位的值，<code>salw</code>只会考虑低4位的值，以此类推。</li></ul><p><strong>注意：</strong></p><ul><li>以上操作除了右移以外，在无符号数和补码间都是通用的，也体现了补码的优势。</li><li>可以使用<code>xorl %edx, %edx</code>来对寄存器<code>%rdx</code>置零。</li></ul><h2 id="6-特殊计算操作"><a href="#6-特殊计算操作" class="headerlink" title="6. 特殊计算操作"></a>6. 特殊计算操作</h2><h3 id="6-1-128位除法"><a href="#6-1-128位除法" class="headerlink" title="6.1 128位除法"></a>6.1 128位除法</h3><p>​        在3-10中我们并没有看到除法操作，它是使用比较特殊的指令进行计算的，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596246571632-7460a4f9-1337-426f-97a4-20c0b5ae94ae.jpeg" alt="image"></p><p>​        其中<code>R[%rdx]:R[%rax]</code>表示将两个寄存器的值拼接起来作为一个数，其中寄存器<code>%rdx</code>是高八字节，<code>%rax</code>是低八字节。它这里只有一个操作数表示除数，而被除数保存在<code>%rax</code>和<code>%rdx</code>中。</p><p>​        <strong>有符号数除法：</strong></p><ol><li><p>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</p></li><li><p>将被除数中的64位<code>mov</code>到<code>%rax</code>中</p></li><li><p>如果被除数是64位的，则要用<code>cqto</code>根据<code>%rax</code>中的最高有效位对<code>%rdx</code>进行符号扩展；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</p></li><li><p>使用<code>idiv</code>进行计算。</p><p><strong>无符号数除法：</strong></p></li><li><p>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</p></li><li><p>将被除数中的64位<code>mov</code>到<code>%rax</code>中</p></li><li><p>如果被除数是64位的，则使用<code>xorq %rdx, %rdx</code>将高64位置零；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</p></li><li><p>使用<code>div</code>进行计算。</p></li></ol><h3 id="6-2-128位乘法"><a href="#6-2-128位乘法" class="headerlink" title="6.2 128位乘法"></a>6.2 128位乘法</h3><p>​        普通的imulq二元操作符乘法是64位乘以64位产生一个64位的结果。</p><p>​        我们知道，64位数乘上64位数会得到128位的数，x86-64提供了这种乘法的指令，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1596246571442-5c45d36e-617b-49ae-a0ba-d8e2f3bbb13f.png" alt="image"></p><p>​        我们可以发现，指令<code>imul</code>和图3-10中的普通乘法指令是一样的，但是这个128位乘法只有一个操作数，普通乘法有两个操作数，汇编器会通过操作数的数目来判断是执行哪条指令。</p><ol><li>将占用<code>%rax</code>的数据<code>mov</code>到别的寄存器中</li><li>将其中一个乘数<code>mov</code>到<code>%rax</code>中</li><li>如果是有符号乘法，就使用<code>imul</code>，如果是无符号乘法，就是用<code>mul</code></li><li>对结果进行保存，比如保存在<code>(%rdi)</code>中：如果是在小端机器中，则为<code>movq %rax, (%rdi)</code>，<code>movq %rdx, 8(%rdi)</code>；如果是打断机器中，则为<code>movq %rax, 8(%rdi)</code>，<code>movq %rdx, (%rdi)</code>。</li></ol><h1 id="第二节-控制"><a href="#第二节-控制" class="headerlink" title="第二节 控制"></a>第二节 控制</h1><p>​        对应于书本3.6</p><hr><p><strong>小点：</strong></p><ul><li><p>大多数情况下，机器对有符号数和无符号数都使用一样的指令，因为大多数算数运算对无符号数和补码都是相同的位级行为。但是在右移、除法和乘法指令以及条件码组合中，需要区分无符号数和补码。</p></li><li><p>保存在64位寄存器中的数据类型，除了<code>long</code>和<code>unsigned long</code>以外，还可以是指针（对于64位操作系统而言）。</p></li><li><p>条件跳转只能是直接跳转。</p></li><li><p>当<code>switch</code>的分支跨度很大，并且很稀疏时，会保存很大的跳转表，可能影响性能，编译器可能会将其构建成树的结构。此时建议使用<code>if-else</code>语句。</p></li><li><p>这一节比较重要的概念：条件jump、条件mov以及跳转表的思想</p></li></ul><hr><p>​        之前介绍的只是指令一条条顺序执行的，也就是对应于直线代码的行为。当出现条件语句、循环语句等，就需要有条件地执行指令。机器代码通过测试数据值，然后根据测试的结果来改变控制流或者数据流。</p><h2 id="1-条件码"><a href="#1-条件码" class="headerlink" title="1.  条件码"></a>1.  条件码</h2><p>​        除了之前介绍的保存整数和指针的16个64的寄存器以外，CPU还维护了一组单个位的<strong>条件码（Condition Code）寄存器</strong>，我们不会直接对条件码进行设置，而是根据最近的算数、逻辑或者测试的结果，自动设置这些条件码寄存器的值。</p><p><strong>条件码包括：</strong></p><ul><li><p><strong>ZF：</strong>零标志，最近的操作得到的结果是否为0。</p></li><li><p><strong>无符号数：</strong></p><ul><li><strong>CF：</strong>进位标志，最近的操作使得<strong>最高位产生进位</strong>。可用来检查无符号数是否存在溢出。</li></ul></li><li><p><strong>补码：</strong></p></li><li><p><strong>SF：</strong>符号标志，最近的操作得到的<strong>结果为负数</strong>。</p><ul><li><strong>OF：</strong>溢出标志，最近的操作导致补码溢出（<strong>可以通过符号位进一步判断是正溢出还是负溢出</strong>）。</li></ul></li></ul><p>​      当我们执行如下操作时，不仅目的寄存器会发生改变，同时会设置这些条件码寄存器。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249171960-3be4721e-7321-4016-9f1c-0d7406283c58.jpeg" alt="image"></p><p><strong>注意：</strong></p><ul><li><p><code>lea</code>不会设置条件码，因为它只是单纯计算地址。</p></li><li><p>逻辑操作的CF和OF会设置为0。</p></li><li><p>移位操作CF为最后一个被移出的位，OF=0。</p></li><li><p>INC和DEC会设置OF和ZF，不会改变CF。</p><p>x86-64提供了另外两类指令，<strong>只会设置条件码而不会改变目的寄存器</strong>：</p></li><li><p><code>CMP S1, S2</code>：用来比较<code>S1</code>和<code>S2</code>，根据<code>S2-S1</code>的结果来设置条件码。主要用来比较两个数的大小。CMP命令和SUB的命令行为是一样的，只是CMP命令只设置条件码不改变寄存器。</p></li><li><p><code>TEST S1, S2</code>：用来测试<code>S1</code>和<code>S2</code>，根据<code>S1 &amp; S2</code>的结果来设置条件码。可以将一个操作数作为掩码，用来指示哪些位用来测试。TEST命令和AND命令是一样的，只是TEST命令只设置条件码，不改变寄存器。比如<code>testq %rax, %rax</code>就可以检查<code>%rax</code>是正数、负数还是0。</p><p><strong>注意：</strong>使用<code>CMP</code>进行比较时，要注意顺序是相反的。比如<code>CMP S1, S2</code>得到大于的结果，则表示<code>S2</code>大于<code>S1</code>。</p></li></ul><p>我们可以执行这两个指令后，自己根据条件码的组合来比较或测试结果，但是这里提供了一类<code>SET</code>指令，能够自动根据条件码的组合来得到结果，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249171965-cd40de33-10bc-45d5-8a79-764df72a7d02.jpeg" alt="image"></p><p>这里的目的操作数是<strong>低位单字节寄存器</strong>，或者一个字节的内存位置。如果要得到32位或64位结果，我们可以使用<code>MOVZ</code>对其进行传输。</p><p><strong>注意：</strong>这里无符号数和补码的条件码组合不同，所以需要使用不同的<code>SET</code>指令，所以可以通过<code>SET</code>指令来判断所操作的数是无符号的还是补码的。</p><p>所以常见的<strong>使用顺序</strong>为：</p><ol><li>使用<code>CMP</code>进行比较或<code>TEST</code>进行测试，来设置条件码。</li><li>根据条件码组合或者<code>SET</code>将结果保存在单字节寄存器中。</li><li>使用<code>movbl</code>将结果保存在32位寄存器中，并且会自动设置高4字节为0。</li></ol><h2 id="2-跳转指令"><a href="#2-跳转指令" class="headerlink" title="2. 跳转指令"></a>2. 跳转指令</h2><p>​        之前介绍的都是顺序执行指令的代码，而<strong>跳转（Jump）指令</strong>能够改变指令执行的顺序，跳转到新的指令后继续顺序执行。而跳转指令我们可以分成<strong>不同的类型：</strong></p><ul><li><p><strong>根据提供跳转目标的方式：</strong></p></li><li><ul><li><strong>直接跳转：</strong>跳转目标作为指令的一部分进行编码。汇编语言中，跳转目标通常用一个<strong>标号（Label）</strong>指明，比如下面汇编代码里的<code>.L1</code>就是标号。在产生目标代码时，汇编器以及链接器会确定跳转目标的适当编码，并将其编码为跳转指令的一部分。</li><li><strong>间接跳转：</strong>跳转目标从寄存器或内存位置中读取出来。需要在前面添加一个<code>*</code>，比如<code>jmp *%rax</code>就是跳转到寄存器<code>%rax</code>中保存的地址；<code>jmp *(%rax)</code>就是跳转到内存地址<code>(%rax)</code>中保存的地址。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span> <span class="number">$0</span>, %rax</span><br><span class="line">  <span class="keyword">jmp</span> .L1</span><br><span class="line">  <span class="keyword">movq</span> (%rax), %rdx</span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  popq %rdx</span><br></pre></td></tr></table></figure><ul><li><p><strong>根据跳转的条件：</strong></p></li><li><ul><li><strong>无条件跳转：</strong>没有任何条件，看到<code>jmp</code>就直接跳转。</li><li><strong>有条件跳转：</strong>根据条件码组合来判断是否进行跳转。</li></ul></li></ul><p>​         常见的所有跳转指令如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249172105-cccdbe35-88dd-4a8b-821a-109f184963be.jpeg" alt="image"></p><p>​        <strong>注意：</strong>条件跳转只能是直接跳转。</p><p>​        对于直接跳转的跳转目标的编码，有<strong>两种编码方式：</strong></p><ul><li><p><strong>PC相对的（PC-relative）：</strong>跳转目标地址减去跳转指令下一条指令的地址的差。编码长度可以为1、2或4字节。</p></li><li><p><strong>绝对地址：</strong>用4/8字节直接给定目标地址。</p><p>​    对于如下代码，我们使用PC相对编码</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249171961-a528e373-9c10-45ce-9bcb-5f7278fca6da.jpg" alt="image"></p><p>​        我们反汇编汇编器的结果和链接器的结果，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172128-3913f643-0074-49b7-abab-6ecb906a38ba.jpg" alt="image"></p><p>​        可以发现，无论是汇编器的反汇编结果，还是偏移到新的地址空间的链接器的反汇编结果，第二行的<code>jmp</code>的编码都是<code>eb 03</code>，其中<code>eb</code>是<code>jmp</code>的编码，而<code>03</code>就是计算出来的差值，而第5行的<code>jg</code>的编码都是<code>7f f8</code>，其中<code>7f</code>是<code>jg</code>的编码，而<code>f8</code>是计算出来的结果。所以<strong>即使偏移到新的地址空间，使用PC相对的编码方式也不用修改<code>jmp</code>的编码。</strong></p><p>​        <strong>通过看<code>jmp</code>的编码，就能知道跳转的地址的差值。</strong></p><p>​        通过跳转指令，就能实现条件执行和不同循环结构。</p><h2 id="3-使用跳转指令实现条件执行和循环结构"><a href="#3-使用跳转指令实现条件执行和循环结构" class="headerlink" title="3. 使用跳转指令实现条件执行和循环结构"></a>3. 使用跳转指令实现条件执行和循环结构</h2><h3 id="3-1-用条件控制实现条件分支"><a href="#3-1-用条件控制实现条件分支" class="headerlink" title="3.1 用条件控制实现条件分支"></a>3.1 用条件控制实现条件分支</h3><p>​        实现条件操作的传统方法是通过使用控制的条件转移，当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。对于条件分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">  proc1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  proc2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        其中x保存在<code>%rdi</code>，y保存在<code>%rsi</code>，可以定义对应的汇编语言</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmpq %rsi, %rdi</span><br><span class="line">  <span class="keyword">jge</span> .L1</span><br><span class="line">  PROC2</span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  PROC1</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h3 id="3-2-用条件传送实现条件分支"><a href="#3-2-用条件传送实现条件分支" class="headerlink" title="3.2 用条件传送实现条件分支"></a>3.2 用条件传送实现条件分支</h3><p>​        以上方法的性能并不是很优越。</p><p>​        处理器在执行一条指令时，会经历一系列过程，而每个过程执行所需操作的一小部分，通过重叠连续指令可以提高性能，比如当前指令执行计算时，下一条指令可以执行取指阶段，这个方法称为<strong>流水线（Pipelining）</strong>。但是当遇到条件需要跳转时，只有知道跳转结果才能确定指令顺序，才能使用流水线，现在处理器采用<strong>分支预测</strong>的方法来预测跳转的结果，即处理器会预测当前跳转的结果，然后将预测的指令进行流水线，如果预测正确则会提高性能，如果预测错误，就需要把之前流水线清空，然后在正确的分支重新开始流水线，会损失很多性能。</p><blockquote><p><strong>分支预测处罚计算：</strong>预测错误概率为p，预测正确时代码执行时间为TOK，而预测错误的处罚为TMP。则执行代码的平均时间为TAVG(p)=(1-p)TOK+p(TOK+TMP)=TOK+pTMP，所以TMP=(TAVG(p)-TOK)/p。</p></blockquote><p>​        上一节的用<strong>条件控制</strong>的方法就会存在这个问题，由于存在不确定的跳转，所以处理器会通过分支预测来将填满流水线，如果分支预测错误，就使得性能受损。</p><p>​        而用<strong>条件传送</strong>来实现条件分支，不会先判断跳转，而是先将两个分支的结果进行计算，将结果分别保存在两个寄存器中，然后再通过**条件传送指令<code>CMOV</code>**将正确结果传送到输出的寄存器中。</p><p>​        比如以下的计算x和y的差的绝对值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;y)</span><br><span class="line">    <span class="keyword">return</span> y-x;</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        使用条件控制的方法实现的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">absdiff:</span></span><br><span class="line">  cmpq %rsi, %rdi //y-x</span><br><span class="line">  <span class="keyword">jl</span> .L1</span><br><span class="line">  <span class="keyword">movq</span> %rdi, %rax           //y&gt;=x</span><br><span class="line">  subq %rsi, %rax</span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  <span class="keyword">movq</span> %rsi, %rax</span><br><span class="line">  subq %rdi, %rax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>​        这里在第二行中会直接执行一个<code>cmp</code>，所以就存在不确定的分支，处理器为了能够流水线执行指令，就会先预测结果，如果预测错误，就会很损伤性能。</p><p>使用条件传送方法实现的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">absdiff:</span></span><br><span class="line">  <span class="keyword">movq</span> %rsi, %rax</span><br><span class="line">  subq %rdi, %rax  //y-x</span><br><span class="line">  <span class="keyword">movq</span> %rdi, %rdx</span><br><span class="line">  subq %rsi, %rdx  //x-y</span><br><span class="line">  cmpq %rsi, %rdi</span><br><span class="line">  <span class="keyword">cmovge</span> %rdx, %rax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>​        这里会直接将两个分支的计算结果<code>x-y</code>和<code>y-x</code>分别保存在寄存器<code>%rdx</code>和<code>%rax</code>中，然后最后通过<code>cmovge</code>判断如果<code>x&gt;y</code>就将<code>x-y</code>的结果保存在<code>%rax</code>。这里就不需要进行分支预测，性能就十分稳定。</p><p>​        x86-64上提供了一些<strong>条件传送指令<code>CMOV</code>**，只有在满足条件时，才会将源数据传送到目的中，如下图所示，其中源值可以从寄存器也可以从内存地址获取，而目的只能是寄存器。并且这里</strong>不支持单字节**。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249171994-abea0a94-e102-4a93-8551-8564bc7d5ce1.jpeg" alt="image"></p><p>​        但是条件传送也实现的条件分支也存在<strong>局限性</strong>：</p><ol><li>如果条件判断是里面执行语句的可行性判断时，使用条件传送实现条件分支就会出现错误。比如对于指针<code>xp</code>，有个条件分支为<code>xp?*xp:0</code>，如果使用条件传送来实现，就会先运行<code>*xp</code>，如果该指针不存在，就会报错。</li><li>如果执行语句需要大量计算时，由于条件传送会先全部计算后再进行选择，则会浪费一些时间。</li></ol><p>​        所以只有当两个执行语句很简单时，才会使用条件传送来实现条件分支。</p><h2 id="4-循环"><a href="#4-循环" class="headerlink" title="4. 循环"></a>4. 循环</h2><h3 id="4-1-do-while循环"><a href="#4-1-do-while循环" class="headerlink" title="4.1 do-while循环"></a>4.1 do-while循环</h3><p>​        比如代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n<span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(n&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对应的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fact_do:</span></span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq <span class="number">$1</span>, %rdi</span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jg</span> .L1</span><br><span class="line">  <span class="keyword">rep</span><span class="comment">; ret</span></span><br></pre></td></tr></table></figure><p>​        可以发现，在跳转标号<code>.L1</code>之前是循环的初始化，跳转标号之后就是循环体，然后最后要判断是否继续循环体。</p><h3 id="4-2-while"><a href="#4-2-while" class="headerlink" title="4.2 while"></a>4.2 while</h3><p>​        有两种实现while循环的方法，在实现初始测试的方法不同。</p><p>​        对于以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_while</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-1-Jump-to-middle"><a href="#4-2-1-Jump-to-middle" class="headerlink" title="4.2.1 Jump-to-middle"></a>4.2.1 Jump-to-middle</h4><p>​        类似于do-while，只是需要在最开始就跳转到后面的判断语句</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fact_while:</span></span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line">  <span class="keyword">jmp</span> .JUDGE</span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq <span class="number">$1</span>, %rdi</span><br><span class="line"><span class="symbol">.JUDGE:</span></span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jg</span> .L1</span><br><span class="line">  <span class="keyword">rep</span><span class="comment">; ret</span></span><br></pre></td></tr></table></figure><p>​        <strong>特点：</strong>一开始就有一个无条件跳转指令。</p><h4 id="4-2-2-guarded-to"><a href="#4-2-2-guarded-to" class="headerlink" title="4.2.2 guarded-to"></a>4.2.2 guarded-to</h4><p>​        当使用较高优化等级时，比如<code>-O1</code>时，GCC会使用这种策略</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fact_while:</span></span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jle</span> .L1</span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq <span class="number">$1</span>, %rdi</span><br><span class="line">  cmpq <span class="number">$1</span>, %rdi</span><br><span class="line">  <span class="keyword">jne</span> .L2</span><br><span class="line">  <span class="keyword">rep</span><span class="comment">; ret</span></span><br><span class="line"><span class="symbol">.L1:</span></span><br><span class="line">  movl <span class="number">$1</span>, %eax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>​        这里是直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。</p><h3 id="4-3-for"><a href="#4-3-for" class="headerlink" title="4.3 for"></a>4.3 for</h3><p>​        for循环可以转化为while循环，然后根据优化等级，GCC会为其产生的代码是while循环的两种方法之一。比如对于代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_for</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    result *= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以将其转化为while语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_for_while</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">    result *= i;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        由此就能使用4.2中介绍的两种方法进行翻译了。</p><h3 id="4-4-switch"><a href="#4-4-switch" class="headerlink" title="4.4 switch"></a>4.4 switch</h3><p>​        <code>switch</code>语句可以根据一个整数索引数值进行多重分支。通常使用<strong>跳转表（Jump Table）</strong>数据结构使得实现更加高效，它是一个数组，每个元素是对应的代码块起始地址，根据整数索引得到对应的代码地址后，就可以直接跳转到对应的代码块。相比很长的<code>if-else</code>语句的<strong>优势在于</strong>：执行<code>switch</code>语句的时间与分支数目无关。比如有很长的分支语句，如果用<code>if-else</code>实现，则可能需要经过若干个<code>if-else</code>才能跳转到目的代码块，而使用<code>switch</code>能根据跳转表直接获得代码块地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172132-b7d14408-e8b0-44de-823c-c9240d0f1cc6.jpg" alt="image"></p><p>​        如下图所示的C语言代码</p><p><img src="https://pic1.zhimg.com/80/v2-ff0086df487d98b5f05861b6598bc336_720w.jpg" alt="image"></p><p>​        我们首先看GCC提供对跳转表支持后的C语言代码</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172152-b2ec64f5-a25c-4d0d-920d-a5880ad1a3fd.jpg" alt="image"></p><p>​        里面有一个跳转表数组<code>jt</code>，GCC提供了一个新的运算<code>&amp;&amp;</code>，能够创建一个指向代码位置的指针。首先在第9行中，计算输入值<code>x</code>和<code>switch</code>的最小值的差，并将其保存到无符号数中。然后将其作为跳转表的索引，直接在第16行中跳转到索引的代码位置。</p><p>​        <strong>注意：</strong>这里使用无符号数的原因在于，即使你输入比<code>switch</code>中最小值还小的值，则相减会得到负数，由于无符号数会将负数溢出到很大的正数，所以还是会跳转到<code>default</code>。所以汇编代码会使用<code>ja</code>对其使用无符号数的判断，判断是小于0还是大于最大值。</p><p>​        <strong>注意：</strong>跳转表中会创建从最小值到最大值的代码位置，对于重复的情况，比如<code>104</code>和<code>106</code>，就会跳转到相同的代码位置；对于缺失的情况，比如<code>101</code>和<code>105</code>，就会直接跳转到<code>default</code>。</p><p>​        我们可以看一下对应的汇编代码</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596249172137-3a0d33ef-5b81-4988-9b42-c65f429a5e89.jpeg" alt="image"></p><p>​        <strong>注意：</strong>通过第2行可以知道<code>switch</code>的最小值，第3行可以知道<code>switch</code>的最大值，第4行可以知道<code>default</code>的标号。</p><p>​        这里首先将计算结果保存在<code>%rsi</code>中，然后在第4行中<code>jmp *.L4(, %rsi, 8)</code>利用了跳转表，<strong>跳转表的内容由编译器自动生成填写</strong>，其声明如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172086-3e3688ca-d47b-4130-9c19-cd574793f436.jpg" alt="image"></p><p>​        <code>.rodata</code>表示这是只读数据（Read-Only Data），<code>.align 8</code>表示将元素地址与8对其，<code>.L4</code>就定义了一个跳转表，其枚举了从最小值到最大值的跳转目标。对于<code>*.L4(, %rsi, 8)</code>，首先根据<code>.L4</code>可以获得该跳转表的初始位置，然后因为该跳转表每个元素占8个字节，所以计算<code>(, %rsi, 8)</code>，即<code>8*%rsi</code>，就能得到对应的跳转目标。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1596249172140-a99160c1-f865-4112-87d4-2ce64a8a66ae.jpg" alt="image"></p><p>​        由于以上跳转表的性质，所以当出现跨度很大，并且很稀疏的分支情况时，建议使用<code>if-else</code>。</p><h1 id="第三节-函数"><a href="#第三节-函数" class="headerlink" title="第三节 函数"></a>第三节 函数</h1><p>​        对应于书的3.7节</p><hr><p><strong>小点：</strong></p><ul><li>C中的取地址符<code>&amp;</code>返回的是内存地址，所以一定要保存在内存中。</li><li>保存到内存中进行参数传输时，要求每个参数大小为8字节的倍数，即要求相对<code>%rsp</code>的偏移量为8的倍数</li><li>不会显示地操作程序计数器寄存器<code>%rip</code>，没有指令可以对其操作，只能通过类似<code>call</code>或<code>ret</code>间接对其操作。</li><li>栈顶指针<code>%rsp</code>是随着函数运行不断变化的。</li><li>函数可以假设“被调用者保存寄存器”的值是不变的，而可以用“调用者保存寄存器”来保存临时值。</li><li>某个函数要永久使用的值，要么保存在“被调用者保存寄存器”中，要么保存在内存中。</li><li>当函数需要使用“被调用者保存寄存器”时，就直接将其<code>push</code>到栈中，使用过后再<code>pop</code>重置。</li><li>无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过<code>%rsp</code>将这些区域释放掉，这是动态的过程，使得一个函数运行完时，<code>%rsp</code>指向的就是返回地址，就能直接通过<code>ret</code>返回到调用者的断点处。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1596250833201-cd60eeaf-304f-4cbd-932d-8fe622ce8ef2.jpeg" alt="image"></p><ul><li>进入一个函数时，首先将要使用的“被调用者保存寄存器”<code>push</code>到栈中，然后<strong>通过<code>%rsp</code>来申请一段固定大小的空间</strong>，用来存放局部变量和参数构造区，最后再释放申请的空间。</li></ul><p>​        要提供对函数的机器级支持，必须处理许多不同的属性。我们假设函数P调用函数Q，Q执行后返回P。这个过程包括以下一个或多个<strong>机制：</strong></p><ul><li><strong>传递控制：</strong>在进入函数Q的时候，程序计数器要设置为Q的代码的起始位置。从函数Q返回时，要把程序计数器设置为P中调用Q后面那条指令的地址，即从P中的断点处继续执行。</li><li><strong>传递数据：</strong>函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。</li><li><strong>分配和释放内存：</strong>开始时，函数Q可能需要为局部变量分配空间，而在返回前，又要释放这些存储空间。</li></ul><p>​        要想详细了解这些机制，我们首先要知道在内存中是如何保存函数的。</p><hr><h2 id="1-运行时栈"><a href="#1-运行时栈" class="headerlink" title="1. 运行时栈"></a>1. 运行时栈</h2><p>​        栈帧：当函数需要的存储空间超出寄存器能够存放的大小，或者调用别的函数需要保存额外数据时，就会在栈上分配一个空间，这个空间称为函数的<strong>栈帧（Stack Frame）</strong>。相对的，当某个函数的所有局部变量都能保存在寄存器中，并且不会调用任何的函数时，就无需开辟该函数的栈帧了。当给一个函数创建栈帧时，编译器会给函数分配<strong>所需</strong>的<strong>定长</strong>的栈帧，在函数开始时就分配好后就不会改变了，所以栈顶指针<code>%rsp</code>就知道当函数返回时，需要释放多少空间。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593831663269-efd6cd27-05ba-4b0e-9584-34ca4c1aeab6.jpg" alt="image"></p><p>​        栈帧包括：被保存的寄存器 –&gt; 局部变量 –&gt; 参数构造区 –&gt; 返回地址</p><p>​        其中除了返回地址，其他都不是必须要用的，只有到需要的时候才创建。</p><h3 id="1-1-被保存的寄存器"><a href="#1-1-被保存的寄存器" class="headerlink" title="1.1 被保存的寄存器"></a>1.1 被保存的寄存器</h3><p>​        我们对除了栈指针<code>%rsp</code>外的所有寄存器分成两类：</p><ul><li><strong>被调用者保存寄存器：</strong><code>%rbx</code>、<code>%rbp</code>和<code>%r12</code>~<code>%r15</code>。这部分寄存是由被调用者，即Q保存的。如果Q改变了这部分寄存器的值，就需要将其保存在Q自己栈帧中的<strong>“被保存的寄存器”</strong>中。当Q返回时，再将这部分寄存器的值根据内存复原。所以函数P可以假设“被调用者保存寄存器”的值是始终不变的。</li><li><strong>调用者保存寄存器：</strong>除了上面的寄存器外，都属于被调用者保存寄存器。 任何函数都能修改这些寄存器的值，并且不会保存在“被保存的寄存器”中，所以P要自己将这部分寄存的内容保存起来。所以函数P可以假设“调用者保存寄存器”的值是变化的，需要自己保存，可以用这部分寄存器保存临时值。</li></ul><p>​        <strong>调用步骤</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//<span class="number">1</span>.函数一进来，就需要通过<span class="keyword">push</span>指令将自己要使用的“被调用者保存寄存器”保存在自己的栈帧中</span><br><span class="line">//比如使用了%rbx和%rbp</span><br><span class="line">  pushq %rbx    //保存%rbx到栈帧中</span><br><span class="line">  pushq %rbp    //保存%rbp到栈帧中</span><br><span class="line">... //可以使用“被调用者保存寄存器”来保存值</span><br><span class="line">//<span class="number">2</span>.当“被调用者保存寄存器”不够保存当前函数的值时，需要开辟局部变量空间保存其他值</span><br><span class="line">//比如保存<span class="number">8</span>字节值</span><br><span class="line">  subq <span class="number">$8</span>, %rsp //将栈指针下移<span class="number">8</span>个字节</span><br><span class="line">  <span class="keyword">movq</span> %rdi, (%rsp)  //将需要保存的值保存到栈上</span><br><span class="line">//<span class="number">3</span>.调用别的函数</span><br><span class="line">  <span class="keyword">call</span> func //调用函数func，则“被调用者保存寄存器”会保存在函数func的栈帧中</span><br><span class="line">... //可以继续使用“被调用者保存寄存器”，因为函数func返回时会重置这些寄存器到原始值</span><br><span class="line">//<span class="number">4</span>.释放局部变量空间</span><br><span class="line">  addq <span class="number">$8</span>, %rsp</span><br><span class="line">//<span class="number">5</span>.重置“被调用者保存寄存器”的值，注意顺序要相反</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rbx</span><br></pre></td></tr></table></figure><p>​        <strong>综上所述：</strong></p><ol><li>将要使用的“被调用者保存寄存器”<code>push</code>到栈中。（存储调用当前函数的函数的值）</li><li>将除了“被调用者保存寄存器”的其他寄存器保存在空闲的“被调用者保存寄存器”中，如果保存不下，就将其保存在内存的“局部变量”区域</li><li>调用其他函数</li><li>释放 “局部变量”区域</li><li>将“被调用者保存寄存器”的值通过<code>pop</code>从栈中恢复。注意：顺序要和<code>push</code>时相反</li></ol><h3 id="1-2-局部变量"><a href="#1-2-局部变量" class="headerlink" title="1.2 局部变量"></a>1.2 局部变量</h3><p>​        当函数需要保存的数据不多时，就会将数据保存在“被调用者保存寄存器”中。但是以下情况必须<strong>保存在内存中</strong>，该部分称为该函数的<strong>局部变量：</strong></p><ul><li><p>“被调用者保存寄存器”不足以保存所有的本地数据</p></li><li><p>当一个局部变量使用取地址符&amp;时，指的是返回该变量在内存中的地址，就必须将其保存在内存中</p></li><li><p>当局部变量是数组或结构时</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593832934958-03a6a743-3a1c-4841-b7de-d26b42c325de.jpg" alt="image"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">call_proc:</span></span><br><span class="line">  //<span class="number">1</span>. 因为x1、x2、x3和x4都有取地址符，所以都是保存在内存中的，首先要通过%rsp分配存储空间</span><br><span class="line">  subq <span class="number">$32</span>, %rsp       //将栈顶指针%rsp下移<span class="number">32</span>，扩展了<span class="number">32</span>字节空间</span><br><span class="line">  //<span class="number">2</span>. 将数据保存在内存中</span><br><span class="line">  <span class="keyword">movq</span> <span class="number">$1</span>, <span class="number">24</span>(%rsp)    //因为x1为long，所以需要<span class="number">8</span>字节空间，所以将<span class="number">1</span>保存在<span class="number">24</span>(%rsp)处</span><br><span class="line">  movl <span class="number">$2</span>, <span class="number">20</span>(%rsp)    //因为x2为<span class="keyword">int</span>，所以需要<span class="number">4</span>字节空间</span><br><span class="line">  movw <span class="number">$3</span>, <span class="number">18</span>(%rsp)    //因为x3为short，所以需要<span class="number">2</span>字节空间</span><br><span class="line">  movb <span class="number">$4</span>, <span class="number">17</span>(%rsp)    //因为x4为char，所以需要<span class="number">1</span>字节空间</span><br><span class="line">  //<span class="number">3</span>. 依次根据proc传入参数的顺序保存在内存和寄存器中</span><br><span class="line">  //因为总共要传入<span class="number">8</span>个参数，超过了<span class="number">6</span>个参数，所以要将最后的x4和&amp;x4保存在内存中，这里要求和<span class="number">8</span>字节对齐</span><br><span class="line">  leaq <span class="number">17</span>(%rsp), %rax  //获取&amp;x4，因为不能直接在内存间<span class="keyword">mov</span>，所以需要先保存到寄存器%rax</span><br><span class="line">  <span class="keyword">movq</span> %rax, <span class="number">8</span>(%rsp)   //参数<span class="number">8</span>：将&amp;x4保存在内存<span class="number">8</span>(%rsp)中，这里要求是<span class="number">8</span>的倍数</span><br><span class="line">  movl <span class="number">$4</span>, (%rsp)      //参数<span class="number">7</span>：将x4保存在内存(%rsp)中</span><br><span class="line">  leaq <span class="number">18</span>(%rsp), %r9   //参数<span class="number">6</span>：将&amp;x3保存在%r9中</span><br><span class="line">  movl <span class="number">$3</span>, %r8d        //参数<span class="number">5</span>：将x3保存在%r8中</span><br><span class="line">  leaq <span class="number">20</span>(%rsp), %rcx  //参数<span class="number">4</span>：将&amp;x2保存在%rcx中</span><br><span class="line">  movl <span class="number">$2</span>, %edx        //参数<span class="number">3</span>：将x2保存在%rdx中</span><br><span class="line">  leaq <span class="number">24</span>(%rsp), %rsi  //参数<span class="number">2</span>：将&amp;x1保存在%rsi中</span><br><span class="line">  movl <span class="number">$1</span>, %edi        //参数<span class="number">1</span>：将x1保存在%rdi中</span><br><span class="line">  //<span class="number">4</span>. 调用函数</span><br><span class="line">  <span class="keyword">call</span> proc</span><br><span class="line">  //<span class="number">5</span>. 根据%rsp将保存在内存中的数据进行计算</span><br><span class="line">...</span><br><span class="line">  //<span class="number">6</span>. 删除空间</span><br><span class="line">  addq <span class="number">$32</span>, %rsp</span><br></pre></td></tr></table></figure><p>​        可以将其总结为以下几步：</p><ol><li>申请局部空间，通过对栈顶指针<code>%rsp</code>减掉一个值</li><li>根据数据大小，通过<code>%rsp</code>索引将数据保存在内存空间中</li><li>根据传入参数顺序，将其保存到内存和寄存器中。<strong>注意：</strong>参数大小要为8字节的倍数。</li><li>释放局部空间，通过对栈顶指针<code>%rsp</code> 加上<code>1.</code>中的值</li></ol><h3 id="1-3-参数构造区"><a href="#1-3-参数构造区" class="headerlink" title="1.3 参数构造区"></a>1.3 参数构造区</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1593833317142-76d172f9-aa22-42b8-83ee-3606f41d3b9c.jpeg" alt="image"></p><p>​        如果某个函数要传递超过6个参数的话，就需要将第7个到第n个参数保存在<strong>栈</strong>中，然后通过<strong>栈顶指针<code>%rsp</code>**进行索引其中第7个参数在栈顶位置。要求每个参数的大小要为8字节的倍数。这部分区域称为</strong>参数构造区**。保存在寄存器中的参数访问起来比保存在内存中快很多。</p><h3 id="1-4-返回地址"><a href="#1-4-返回地址" class="headerlink" title="1.4 返回地址"></a>1.4 返回地址</h3><p>​        主要任务：记录函数返回地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1593833387368-a4b1150b-409d-43ec-b76d-251b7f1d6670.jpeg" alt="image"></p><ul><li><p><code>call</code>：可以直接将函数名作为跳转目标，其编码的计算方式和<code>jmp</code>相同。相当于<code>push</code>和设置<code>%rip</code>的组合。</p></li><li><ul><li>将栈指针减8，留出保存返回地址的空间</li><li>将紧跟<code>call</code>指令后面那条指令的地址作为返回地址，保存到栈中。</li><li>将程序计数器设置为调用函数的地址。</li></ul></li><li><p><code>ret</code>：从当前函数返回，不需要操作数。相当于设置<code>%rip</code>和<code>pop</code>的组合。</p></li><li><ul><li>将程序计数器设置为栈顶元素。</li><li>将栈指针加8。</li></ul></li></ul><h2 id="2-总述"><a href="#2-总述" class="headerlink" title="2. 总述"></a>2. 总述</h2><ul><li>（被保存的寄存器）函数P将要使用的“被调用者保存寄存器”通过<code>push</code>保存在函数的栈帧中。</li><li>（局部变量）如果函数P使用了“调用者保存寄存器”，就需要将其保存在栈中，才能调用函数Q。并且函数P根据需要申请空间来保存其他局部变量。</li><li>（参数构造区）函数P将参数保存在寄存器中，如果超过6个参数，就申请空间保存到内存中。</li><li>（返回地址）函数P使用<code>call</code>指令调用函数Q，会将<code>call</code>的下一行指令的地址压入栈中，并将程序计数器指向函数Q的第一条指令的地址。</li><li>当函数Q运行时会随着使用动态申请和释放局部变量，当函数Q运行完时，首先使用栈“被调用者保存寄存器”的值，然后使用<code>ret</code>指令返回将程序计数器设置为栈顶的返回地址，最后将栈顶的返回地址弹出。</li></ul><p>​        我们可以发现有趣的一点是，无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过<code>%rsp</code>将这些区域释放掉，这是动态的过程，使得一个函数运行完时，<code>%rsp</code>指向的就是返回地址，就能直接通过<code>ret</code>返回到调用者的断点处。</p><h1 id="第四节-数据"><a href="#第四节-数据" class="headerlink" title="第四节 数据"></a>第四节 数据</h1><p>​        对应于书3.8、3.9。</p><hr><p><strong>小点：</strong></p><ul><li>当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称。而当你声明一个指针时，你所分配的只有指针本身的空间。</li><li>当程序要用一个常数作为数维度或者缓冲区大小时，最好通过<code>#define</code>声明将这个常数与一个名字联系起来，后面就一直使用这个名字代替常数的数值。</li><li>在<code>struct</code>和<code>union</code>中的对象，都是保存在内存中的。</li><li>定义结构体时，按照对象K值的大小，<strong>从大到小声明</strong>，可以减少填充的空间，节省整个结构体的大小。</li></ul><hr><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><h3 id="1-1-普通数组"><a href="#1-1-普通数组" class="headerlink" title="1.1 普通数组"></a>1.1 普通数组</h3><p>​        对于一个数组声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[N];</span><br></pre></td></tr></table></figure><p>​        主要经历两个步骤：</p><ol><li><p>根据数据类型<code>T</code>的大小<code>L</code>字节，先在内存空间中分配一个大小为<code>L*N</code>的连续空间；</p></li><li><p>将<code>A</code>作为这个连续内存空间的起始指针，即A的值<code>xA</code>就是该内存空间的起始地址。</p><p><strong>注意</strong>：<strong>当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称</strong>。<strong>而当你声明一个指针时，你所分配的只有指针本身的空间</strong>，所以如果没有初始化指针，直接对其进行解引用可能会出现错误。</p></li></ol><p>​        如果我们将该数组的起始地址<code>xA</code>和索引值<code>i</code>保存在寄存器中，就能通过“比例变址寻址”的方式获得对应内存地址的数据。比如我们将起始地址保存在寄存器<code>%rdx</code>，将索引值保存在寄存器<code>%rcx</code>中，假设数据类型为<code>int</code>4字节，则访问该位置的汇编代码为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl (%rdx, %rcx, <span class="number">4</span>), %eax</span><br></pre></td></tr></table></figure><h3 id="1-2-嵌套的数组"><a href="#1-2-嵌套的数组" class="headerlink" title="1.2 嵌套的数组"></a>1.2 嵌套的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T D[R][C]</span><br></pre></td></tr></table></figure><p>​        其中，<code>R</code>是行数，<code>C</code>是列数。数组按照行优先保存。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593835497216-2041404d-e596-4262-8d0c-bbd8d53e6389.jpg" alt="image"></p><p>​        所以当该数组的起始地址为<code>x</code>，<code>T</code>的大小为<code>L</code>时，<code>D[i][j]</code>的地址为<code>x+L(Ci+j)</code>。类似一元数组，我们也可以很容易地通过“比例变址寻址”的方式进行索引。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593835522867-61c19daf-3f3e-42b2-8052-dc0dd8127642.jpg" alt="image"></p><h3 id="1-3-定长数组"><a href="#1-3-定长数组" class="headerlink" title="1.3 定长数组"></a>1.3 定长数组</h3><p>​        当我们使用<code>#define</code>定义一个变量<code>N</code>为常量后，再用<code>N</code>来确定数组大小，则该数组是一个定长数组。</p><h3 id="1-4-变长数组"><a href="#1-4-变长数组" class="headerlink" title="1.4 变长数组"></a>1.4 变长数组</h3><p>​        过去C要求数组的大小要在编译时就确定，才能生成对应的汇编代码。如果需要变长数组，就需要程序员自己对数组分配存储空间。ISO-C99允许数组的维度为表达式，在数组被分配时才计算出来，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[exp1][exp2];</span><br></pre></td></tr></table></figure><p>​        只要求<code>exp1</code>和<code>exp2</code>定义在上面那个声明之前。</p><p>​        我们接下来对比下定长数组和变长数组在索引时汇编代码的区别：</p><ul><li>定长数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fix_matrix[<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fix_ele</span><span class="params">(fix_matrix A, <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对应的汇编代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fix_ele:</span><br><span class="line">  leaq (%rsi, %rsi, 2), %rax    #compute 3i</span><br><span class="line">  leaq (%rdi, %rax, 4), %rax    #compute A+12i</span><br><span class="line">  movl (%rax, %rdx, 4), %eax    #read fomr M[A+12i+4j]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><ul><li>变长数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">var_ele</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> A[n][n], <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对应的汇编代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var_ele:</span><br><span class="line">  imulq %rdx, %rdi             <span class="meta">#compute ni</span></span><br><span class="line">  leaq  (%rsi, %rdi, <span class="number">4</span>), %rax  <span class="meta">#compute A+4ni</span></span><br><span class="line">  movl  (%rax, %rcx, <span class="number">4</span>), %eax  <span class="meta">#read from M[A+4ni+4j]</span></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>​        看汇编代码可以发现以下区别：</p><ul><li>增加了参数n，使得寄存器的使用改变了，</li><li>用了乘法指令来计算<code>ni</code>，而不是用<code>leaq</code>来计算<code>3i</code>，乘法会导致无法避免的性能损失</li></ul><h2 id="2-异质的数据结构"><a href="#2-异质的数据结构" class="headerlink" title="2. 异质的数据结构"></a>2. 异质的数据结构</h2><p>​        c语言提供两种将不同对象组合到一起的数据结构</p><h3 id="2-1-struct"><a href="#2-1-struct" class="headerlink" title="2.1 struct"></a>2.1 struct</h3><p>​        C语言中，可以用<code>struct</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p><ul><li><strong>定义：</strong>可以将不同类型的对象聚合到一个对象中，并使用名字来引用结构中的各个组成部分。</li><li><strong>存储：</strong>结构的所有组成部分都存放在内存中一段<strong>连续的</strong>区域内，指向结构的<strong>指针</strong>是结构第一字节的地址。</li><li><strong>获得元素：</strong>编译器会维护关于每个结构类型的信息，了解每个字段的偏移量，由此作为内存引用指令的唯一，来对结构元素进行引用。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1593837007125-2960fbfd-82dc-4ca1-8fa3-58462b86e932.png" alt="image"></p><p>​        所以结构的各个字段的选取完全是在编译时处理的，机器代码不包含关于字段申明或字段名字的信息。</p><h4 id="2-1-1-对其原则"><a href="#2-1-1-对其原则" class="headerlink" title="2.1.1 对其原则"></a>2.1.1 对其原则</h4><p>​        <strong>对齐原则</strong>是任何K字节的基本对象的地址必须是K的倍数</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593837157485-ebf4e6e4-cedd-4444-8cae-4d77d1be6969.jpg" alt="image"></p><p>​        在<code>struct</code>中两个连续的对象，编译器可能中间会插入间隙，来满足各自对内存地址的要求。并且还有<strong>两个额外的要求：（对齐要求最大为8）</strong></p><ul><li>要求结构的初始地址一定是结构体中最大对象大小的倍数，使得偏移量加上初始地址才是真的满足倍数关系的。</li><li>在结构体末尾填充，使其是结构体中最大对象大小的倍数，使得结构数组中下一个元素的地址也是成倍数关系的。</li></ul><h3 id="2-2-联合"><a href="#2-2-联合" class="headerlink" title="2.2 联合"></a>2.2 联合</h3><p>​        C语言中，可以用<code>union</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p><ul><li><strong>定义：</strong>允许以多种类型来引用一个对象。</li><li><strong>存储：</strong>保存在<strong>公共的</strong>一块内存中，通过不同对象的类型来赋予这块内存不同的含义。<strong>内存大小为最大字段的大小。</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593837408508-862da1fe-e4d5-4ec4-9989-f07b97a326e6.jpg" alt="image"></p><p>​        主要应用有：</p><ul><li>如果我们事先知道两个不同字段是互斥的，就能将其定义在一个union中，就能节省内存空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;N_LEAF, N_INTERNAL&#125; <span class="keyword">nodetype_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span>&#123;</span></span><br><span class="line">  <span class="keyword">nodetype_t</span> type;</span><br><span class="line">  <span class="keyword">union</span> node_u&#123;</span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">      <span class="keyword">union</span> node_u *left;</span><br><span class="line">      <span class="keyword">union</span> node_u *right;</span><br><span class="line">    &#125; internal;</span><br><span class="line">  &#125; info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>访问相同位模式下不同数据类型的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">double2long</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">  &#125; temp;</span><br><span class="line">  temp.d = d;</span><br><span class="line">  <span class="keyword">return</span> temp.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong><code>struct</code>和<code>union</code>的区别：</strong><code>struct</code>为每个对象分配了单独的内存空间，而<code>union</code>分配了共用的内存空间。</p><p>​        <strong>什么时候用<code>union</code>什么时候用<code>struct</code>：</strong>当你要信息同时存在时，就需要分配到不同的内存中，就要用<code>struct</code>，否则用<code>union</code>。</p><p>​        <strong>计算struct和union嵌套的数据类型的内存分布：</strong></p><ul><li>如果是包裹在struct内的，就按顺序按照对象大小依次排列下来</li><li>如果是包裹在union内的，就看最大的对象大小，直接分配一块内存就行。</li></ul><h1 id="第五节-控制和数据结构"><a href="#第五节-控制和数据结构" class="headerlink" title="第五节 控制和数据结构"></a>第五节 控制和数据结构</h1><p>​        对应于书中的3.10小节。</p><h2 id="1-x86-64内存分布"><a href="#1-x86-64内存分布" class="headerlink" title="1. x86-64内存分布"></a>1. x86-64内存分布</h2><p>​        真实物理内存通过操作系统将其映射虚拟内存</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593931911264-0bd9f222-7d32-4672-9b01-62bf96abfea5.jpg" alt="image"></p><ul><li><strong>Stack：</strong>在Linux中，将栈放置在整个地址空间的最顶部，用于函数调用，及<strong>局部变量</strong>的存储，这样随着函数的运行，栈顶就能向低地址不断扩展。常用系统中栈的大小是8MB，可通过命令<code>limit</code>查看，如果用栈指针访问超过8MB范围的地址，就会出现<strong>段错误（Segmentation Fault）</strong>。 相同程序的栈的分配是固定的。</li><li><strong>Shared Libraries：</strong>类似于<code>printf</code>和<code>malloc</code>的这类<strong>库函数</strong>平时是被存储在磁盘上的，当我们程序需要使用库函数时，就会在程序开始执行时，将它们加载到你的程序中，这称为<strong>动态加载（Dynamic Linking</strong>）。</li><li><strong>Heap：</strong>用来存放通过**<code>malloc</code>、<code>callc</code>或<code>new</code>**等申请的变量，这些变量在程序运行时会动态变化。当你不断通过<code>malloc</code>申请空间又没释放时，堆顶的指针就不会断向高地址增加，使得占用的内存不断变多。堆在分配时是具有随机性的。</li><li><strong>Data：</strong>该数据区用来存放程序开始时分配的数据，你声明的<strong>全局变量、静态变量或字符常量等</strong>都在这个数据段中。</li><li><strong>Text：</strong>根据可执行目标文件的内容进行初始化，是放置你的<strong>可执行程序</strong>的位置。这部分区域是只读的。</li></ul><h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h2><p>​        指针类型不是机器代码的一部分，而是C语言提供的关于内存地址的抽象，指针的值存储的是对象的地址，可以直接通过指针来间接对内存进行访问，避免程序员寻址错误。特殊的<code>NULL(0)</code>表示该指针不指向任何值。如果指针通过<code>&amp;</code>创建，表示获得某个对象的地址，在机器代码中对应于<code>leaq</code>。如果指针通过<code>*</code>进行访问，表示访问该指针指向的对象的值，在机器代码中对应于内存引用。</p><p>​        指针类型确定访问多少个字节。</p><p>​        指针类型还影响指针运算的伸缩。</p><p>​        我们同样可以声明<strong>函数指针</strong>，表示指向函数在机器代码中的第一条指令的内存地址。</p><h2 id="3-缓冲区溢出"><a href="#3-缓冲区溢出" class="headerlink" title="3. 缓冲区溢出"></a>3. 缓冲区溢出</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>​        对数组的引用超出了边界。缓冲区溢出会被用于网络攻击。    </p><p>​        函数P调用函数Q后，会先在栈中写入返回地址A，对应于函数P中的断点位置。而在函数Q中，首先会为buf申请一段空间，如果我们写入一些攻击代码，比如转化为字节形式的指令，并且将返回地址A覆盖为该buf的起始位置。这样当函数Q运行完后，只是通过移动栈指针来释放空间，但是我们注入的代码还保存在栈中，并且<code>ret</code>会调用返回地址B，就返回到了我们注入代码的起始位置，就会开始执行我们注入的代码了。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593933331397-6257fcf5-9d23-410a-85bd-3dcc43f1961c.jpg" alt="image"></p><h3 id="3-2-对抗缓冲区溢出攻击"><a href="#3-2-对抗缓冲区溢出攻击" class="headerlink" title="3.2 对抗缓冲区溢出攻击"></a>3.2 对抗缓冲区溢出攻击</h3><h4 id="3-2-1-不使用具有缓冲溢出的函数"><a href="#3-2-1-不使用具有缓冲溢出的函数" class="headerlink" title="3.2.1 不使用具有缓冲溢出的函数"></a>3.2.1 不使用具有缓冲溢出的函数</h4><p>​        fgets 代替 gets strncpy代替strcpy</p><h4 id="3-2-2-地址空间布置随机化"><a href="#3-2-2-地址空间布置随机化" class="headerlink" title="3.2.2 地址空间布置随机化"></a>3.2.2 地址空间布置随机化</h4><p>​        攻击代码要插入指向攻击代码的指针，需要知道代码放置的位置。对此，使用地址空间布局随机化（ASLR），每次运行程序时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据都会加载到内存的不同区域，使得代码位置不是很好获得。</p><p>​        破解方法是空操作雪橇（Nop Sled），在代码前插入nop指令，只要攻击者能猜到一个nop就能滑倒攻击指令。</p><p>​        ASLR中栈随机化技术比较常用，在栈前分配n字节的随机大小空间。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1593933863248-ea6edf94-ba43-43f0-a905-0d218c79da36.png" alt="image"></p><p>​        比如我们使用重复运行以下代码获得栈地址范围</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> local;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,&amp;local);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        假设获得最小地址为<code>0xFFFFB754</code>，最小地址为<code>0xFFFFD754</code>，则随机化的空间为8192个字节。如果我们构建一个128字节的nop sled，则只要尝试<code>8192/128=64</code>次就能成功，所以随机化程度不能太小，同时也别太大占用程序的空。</p><h4 id="3-2-3-限制可执行代码区域"><a href="#3-2-3-限制可执行代码区域" class="headerlink" title="3.2.3 限制可执行代码区域"></a>3.2.3 限制可执行代码区域</h4><p>​        标记栈是不可执行的。</p><h4 id="3-2-4-栈破坏检测"><a href="#3-2-4-栈破坏检测" class="headerlink" title="3.2.4 栈破坏检测"></a>3.2.4 栈破坏检测</h4><p>​        GCC首先会尝试确定一个函数是否容易受到栈溢出攻击，比如函数中有局部char类型缓冲区时，就会使用一种<strong>栈保护者（Stack Protector）机制</strong>，通过在该函数栈帧中的局部变量区与栈状态（返回地址和寄存器保存区）之间存入一个随机的<strong>金丝雀值（Canary）</strong>，然后在恢复寄存器状态和返回返回地址之前，会检测该值是否发生变化，如果发生变化，则程序异常终止。</p><p>​        <strong>技巧：</strong>将缓冲区放在靠近金丝雀值的位置，防止其他局部变量被修改。</p><h2 id="4-支持边长帧"><a href="#4-支持边长帧" class="headerlink" title="4. 支持边长帧"></a>4. 支持边长帧</h2><p>​        有些函数，需要的局部变量是变长的。需要实现边长帧</p><p>​        为了管理变长栈帧，x86-64代码使用<code>%rbp</code>作为<strong>帧指针（Frame Pointer）</strong>。进入函数时，先将其存入到“保存寄存器区”，然后将当前的栈指针<code>%rsp</code>的值赋予<code>%rbp</code>，则函数最后可直接通过将<code>%rbp</code>的值赋予<code>%rsp</code>就能释放变长的栈帧，并且通过“保存寄存器区”来重置<code>%rbp</code>的值。</p><p>​        以以下代码为例：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1593935160286-c34bc2d3-5818-40eb-96aa-b8609dd172e9.jpg" alt="image"></p><p>​        这里使用了<code>*p[n]</code>申请了一块变长的存储空间，对应的汇编代码为</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1593935174972-37adfd01-269a-43a5-8349-3a6799cf7c4f.jpeg" alt="image"></p><p>​        我们逐行进行解析</p><ol><li><p>函数入口</p></li><li><p>由于在变长栈帧中要使用<code>%rbp</code>作为初始地址，而且<code>%rsp</code>是“被调用者保存寄存器”，所以要先将其压入栈中保存原始值</p></li><li><p>将当前的栈指针<code>%rsp</code>保存到<code>%rbp</code>中，用于后续的释放空间</p></li><li><p>由于代码中对<code>i</code>访问了地址，所以需要将<code>i</code>保存到内存中，所以申请了一段16个字节大小的内存空间，用于存放<code>i</code></p></li><li><p>用<code>%rax</code>保存<code>8n+22</code></p></li><li><p><code>$-16</code>的十六进制表示为<code>0xFFFFFFFFFFFFFFF0</code>，将它和<code>%rax</code>进行与操作，相当于将<code>8n+22</code>变为16的倍数，如果n是奇数，则为<code>8n+8</code>，如果n是偶数，则为<code>8n+16</code>。</p></li><li><p>用<code>%rax</code>计算的值申请存储<code>p</code>的空间。这里涉及到了对齐操作，由于<code>p</code>中保存的元素都是8字节大小的指针，则要求整个存储该字节的整个空间大小是8的倍数，而通过5.中的计算，能够保证<code>%rax</code>是8的倍数。</p></li><li><p>由于我们要找到8的倍数用来存储指针，这里需要对其进行舍入处理，使其能够向上舍入，这里计算的就是偏移量</p></li><li><p>计算得到最近的8倍数，用来开始保存数组<code>p</code></p><p>​    最后的<code>leave</code>指令，等价于</p></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span> %rbp, %rsp #释放之前申请的变长栈帧</span><br><span class="line">popq %rbp       #重置%rbp的值</span><br></pre></td></tr></table></figure><p>​        所以变长栈帧的申请，会自动进行对齐操作，并且使用<code>%rbp</code>作为初始地址，在函数返回时释放存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 细读经典 </category>
          
          <category> 《CSAPP》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从此我爱上的人的人都很像你</title>
      <link href="%E4%BB%8E%E6%AD%A4%E6%88%91%E7%88%B1%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E4%BA%BA%E9%83%BD%E5%BE%88%E5%83%8F%E4%BD%A0/love_letter/%E9%9A%8F%E7%AC%94/%E5%BD%B1%E8%AF%84/"/>
      <url>%E4%BB%8E%E6%AD%A4%E6%88%91%E7%88%B1%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E4%BA%BA%E9%83%BD%E5%BE%88%E5%83%8F%E4%BD%A0/love_letter/%E9%9A%8F%E7%AC%94/%E5%BD%B1%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h1><blockquote><p>也许时间的洪荒里，每一次遇见都是一场盛大的告别；而在最好最蠢的年龄里喜欢上的那一个人，会成为最深刻的东西吧。就像影片最后的书签，泛黄了，还是年轻的笔迹青春的容颜，不会变，不会忘，也不会拥有。</p></blockquote><hr><p>​进入大学以后，偌大的校园逛了两遍，很显然，并没几个认识的人。最后还是钻进图书馆，里面很大很安静，采光良好，冬暖夏凉。据说这座图书馆是“西南第一馆”，设计感极强。</p><p>​然而对我来说，还是不够深刻，我的图书馆在一所中学里，很小，书不多，只能被称作“阅览室”。高三的时候，每次考试结束，都会躲在阅览室里，或许为了逃避结果，翻看各种各样的“闲书”。等到夜深得浓墨重彩的时候，踩着路灯拉长的影子回到租住的屋子。那样的阅读时光无疑是苦涩的隐忍的，但也同样美好难忘，那是我最寂寞的日子里最深刻的抚慰。</p><p>​也许念念不忘的，常常是最简单的。</p><p>于是无缘由的，想到一部老电影。在那部电影里，图书馆总是金黄的、诱人的，散发出一种稍纵即逝的凄凉美感。 </p><h1 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h1><p>​藤井树和藤井树，写在课桌上被人捉弄的的名字。</p><p>男孩藤井树大概是最典型的青春片男主角：帅气，恶作剧，漫不经心，会用拳头教训捉弄他的人。会在心里装一个人，忍受变迁的荒凉。</p><p>​无疑他暗恋着那个和他同名的女孩，但那样的暗恋也单纯得让人心疼，在图书馆借没人看的书，一本一本登记下他们共同的名字；站在窗台看书，眼睛不由自主；在上学路上从背后给自行车上的女孩罩上纸袋……恶作剧，是那个年龄的男孩表达情感最普遍隐晦的方式，羞涩又漫不经心，笨拙又温柔。</p><p>​而这种压抑胆怯感情也总是绵延悠远的吧，以至于离开以后也无法忘怀，爱上博子，一个和那个人如此相似的女孩。有的时候，时间并不会使人遗忘，反而使有的事成为心头的一颗朱砂痣，念念不忘，回眸浮生。也许时间的洪荒里，每一次遇见都是一场盛大的告别；而在最好最蠢的年龄里喜欢上的那一个人，会成为最深刻的东西吧。就像影片最后的书签，泛黄了，还是年轻的笔迹青春的容颜，不会变，不会忘，也不会拥有。也许有时候，有的人活在回忆里，就足够长情。忍不住引用那句被用过千万次的话：</p><p>​        <strong>“青梅枯萎，竹马老去，从此我爱上的人都很像你。”</strong></p><p>​而女藤井树呢，虽然不说，也一定是喜欢着那个男孩吧。所以在图书馆不经意望向他常常倚靠站立的窗棂，看到空空飘摇的纯白窗帘，暗自叹气；所以在夜晚摇着自行车踏板交换拿错的试卷，夜漆黑，灯光明亮；所以在很多年以后还会发现被自己整整齐齐叠在箱底的，他的试卷。</p><p>​而那时呢，都是最蠢最羞涩的年纪吧，被同学捉弄红着脸回避，在图书馆也总呆在距离最遥远的两个角落。可是后来男孩缠着绷带跑步，大家一片哄笑，而她脸上笑着，相机镜头却移不开他的影子；心事重重却不敢说。</p><p>​最后她听说他的死，那天下着雪，她在寒风中推着自行车，不住的咳嗽，眼泪也忍不住的落；最后她收到那张借书卡，写了他们共同的名字，背面有她的素描，笑着落泪着，像那时一样羞涩的想把相片藏起来，一封情书会花多少年才能送达呢？但至少最后她知道，有个傻瓜，在最好的年华里，爱过她。</p><p>​她想起与他的最后一面，也是雪天，她的父亲刚刚去世，他前来还书，没人看的《追忆似水年华》，男孩木木地对她说：“请你节哀。”然后推着自行车在雪地里走远，男孩回头，女孩在门口站着，对他甜美一笑。</p><p>贯彻一生。</p><p>也许真是这样，有的人你仅仅是遇见就用光了所有的运气。</p><h1 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h1><p>​生和死，守望与前行。</p><p>​博子大概是最苦的一个吧，不得不面对死亡、面对孤独、面对爱情幻想的寂灭、面对回忆的翻涌。寄了一封给亡灵的信件，却引出一大段与她无关的往事。</p><p>博子被回忆吞噬了，一直被秋叶拖拽着前行，一直不能从往事里脱身，一直念念不忘，四处找寻，她的爱是固执又坚忍的，她到小樽去找那个回信的人；她去藤井树的学校，用他的方式走过从前别人走过一圈又一圈的操场；歌词里说，思念一个人的滋味，就像是喝下一杯冰冷的水，然后用很长很长的时间，一颗一颗熬成热泪。</p><p>​女藤井树的父亲、藤井树、博子，都面临着同一个话题：死亡。也许这部电影从一开始就在讨论一个更宏大话题：生与死。</p><p>​父亲死去，从前的少年也死去，发了高烧在大雪淋漓的深夜里狂奔，忘不了的亡者，不敢承认的爱情…每个人，在生死面前，都孱弱渺小，都无可奈何。</p><p>不过还好，俊二给了我们一些美好的后来；</p><p>​后来，博子和秋叶一起登山，对着茫茫雪山，她大声的温柔的喊话：“你好吗？我很好。”世界用回声作答。</p><p>​后来，女藤井树平安出院，爷爷指着一棵树说那是她的守护精灵。</p><p>​后来女藤井树收到一封情书，偷走了好多不言而喻的时间。</p><p>​就像那棵和她同龄的树如今已亭亭如盖，四季轮回，万物生长。  </p><p>万世洪荒，初生与寂灭必是最残忍的故事，不过还好：</p><p>​<strong>爱和陪伴的绵延温婉会化解这种本源的痛感，我们会大步向前，对每一朵花微笑。</strong></p><hr><div align=center><font size=4 color=FF0000><strong>祝大家中秋快乐</strong></font></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 影评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的红黑树</title>
      <link href="linux%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/linux_rbtree/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
      <url>linux%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91/linux_rbtree/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/</url>
      
        <content type="html"><![CDATA[<p>​        红黑树是一种Linux中广泛使用的数据结构，通常用于高精度计时器组织定制请求，文件系统管理目录，虚拟存储系统进行虚拟内存空间管理。</p><hr><h1 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h1><p>​        红黑树是一种自平衡二叉搜索树。Linux中主要使用的二叉搜索树就是红黑树。除了二叉搜索树的要求意外，红黑树还加入了一下性质：</p><blockquote><ol><li><p>所有节点要么是红色要么是黑色</p></li><li><p>所有叶子节点都是黑色</p></li><li><p>所有非叶子节点都有两个子节点</p></li><li><p>如果一个节点是红色，那他的子节点是黑色</p></li><li><p>任意一个子节点其每个叶子节点的所有简单路径都包含相同数目的黑色节点。</p></li><li><p>叶子节点不包含数据</p></li></ol></blockquote><p>​        上述条件保证了<strong>最深叶子节点的深度不会大于两倍最浅叶子节点的深度</strong>。所以，红黑树总是平衡的。为什么会这样呢。首先<code>任意一个子节点其每个叶子节点所有简单路径都包含相同数目的黑色节点</code>保证了树中最长路径是黑红交替，最短路径是全黑，所以<strong>最长路径不会超过最短路径的两倍</strong>。</p><p><img src="https://i.loli.net/2020/10/11/tsYOdQ6NgfycCiE.png" alt="image.png"></p><p>​        红黑树动画<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">演示</a></p><h1 id="Linux中的红黑树"><a href="#Linux中的红黑树" class="headerlink" title="Linux中的红黑树"></a>Linux中的红黑树</h1><p>​        Linux中文件系统声明在<code>include\linux\rbtree.h</code>中，实现在<code>lib\rbtree.c</code>中。</p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>​        Linux根节点由<code>rb_root</code>描述，创建一个红黑树，我们能要分配一个新的<code>rb_root</code>结构，并且需要初始化为特殊值<code>RB_ROOT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        其他节点由<code>rb_node</code>描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  rb_parent_color;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_RED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_BLACK 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure><p>​        注意: <code>rb_parent_color</code>成员其实是存储了<strong>父节点的地址</strong>和<strong>节点本身的颜色</strong>。</p><p>​        实现一个变量存储两种信息的关键是: <code>__attribute__((aligned(sizeof(long))))</code>, 指定该结构体对齐长度为<code>sizeof(long)</code>, 在32位机中,长度为4字节, 在64位机中长度为8字节，最后一位地址为一定是0，所以可以用来存储颜色值，想要得到地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r) ((struct rb_node *)((r)-&gt;rb_parent_color &amp; ~3))</span></span><br></pre></td></tr></table></figure><h2 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h2><p>​        与<code>rb_parent_color</code>最后一位颜色为有关的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r) ((struct rb_node *)((r)-&gt;rb_parent_color &amp; ~3))    <span class="comment">// 获取父节点地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_color(r) ((r)-&gt;rb_parent_color &amp; 1)                          <span class="comment">// 获取该节点的颜色信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_is_red(r) (!rb_color(r))                                     <span class="comment">// 判断该节点是否为红色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_is_black(r) rb_color(r)                                      <span class="comment">// 判断该节点是否为黑色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_set_red(r) do &#123; (r)-&gt;rb_parent_color &amp;= ~1; &#125; while (0)      <span class="comment">// 设置节点颜色为红色</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_set_black(r) do &#123; (r)-&gt;rb_parent_color |= 1; &#125; while (0)     <span class="comment">// 设置节点颜色为黑色</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_set_parent</span><span class="params">(struct rb_node *rb, struct rb_node *p)</span> <span class="comment">// 设置父节点 &#123;</span></span></span><br><span class="line">rb-&gt;rb_parent_color = (rb-&gt;rb_parent_color &amp; 3) | (unsigned long)p; // 先清空父节点地址,再或上新的父节点地址</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_set_color</span><span class="params">(struct rb_node *rb, <span class="keyword">int</span> color)</span>          <span class="comment">// 设置节点颜色 &#123;</span></span></span><br><span class="line">rb-&gt;rb_parent_color = (rb-&gt;rb_parent_color &amp; ~1) | color;           // 先清空颜色信息, 再或上新颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        与节点有关的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_ROOT(struct rb_root) &#123; NULL, &#125;                         <span class="comment">//初始根节点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_entry(ptr, type, member) container_of(ptr, type, member)<span class="comment">//包含ptr的结构体指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_EMPTY_ROOT(root) ((root)-&gt;rb_node == NULL)              <span class="comment">//判断树是否空</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_EMPTY_NODE(node) (rb_parent(node) == node)              <span class="comment">//判断节点是否空，父亲是否等于自身</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_CLEAR_NODE(node) (rb_set_parent(node, node))            <span class="comment">//设置节点为空，父亲等于自身</span></span></span><br></pre></td></tr></table></figure><p>​        container_of本身也是一个宏，定义在<code>kernel.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;                \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);           <span class="comment">//把ptr转化为type中member类型的指针__mptr</span></span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)          <span class="comment">//__mptr再减去偏移量就是type的地址</span></span><br></pre></td></tr></table></figure><p>​        <code>offsetof</code>定义在<code>stddef.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)     <span class="comment">//0作为首地址，找到member的地址就是偏移量</span></span></span><br></pre></td></tr></table></figure><h2 id="红黑树插入操作逻辑"><a href="#红黑树插入操作逻辑" class="headerlink" title="红黑树插入操作逻辑"></a>红黑树插入操作逻辑</h2><p>​        具体<a href="https://naotu.baidu.com/file/c0fa8088fa5643598484bae7e81fbb49?token=cc0609045c2ebee9">脑图</a></p><p><img src="https://i.loli.net/2020/10/11/KBygYGEclbvsDrV.png" alt="image.png"></p><blockquote><ul><li>首先建立的节点N都是红的节点</li><li>如果节点N父节点P是红色节点,</li><li>如果叔父节点U也是红色,则只需要更改父节点P和叔父节点P的颜色,再更改祖父节点G的颜色,再动态调整祖父节点G</li><li>如果叔父节点U是红色或者缺失,判断是LL,RR,LR,RL型,并进行相应的旋转</li></ul></blockquote><h2 id="红黑树删除操作逻辑"><a href="#红黑树删除操作逻辑" class="headerlink" title="红黑树删除操作逻辑"></a>红黑树删除操作逻辑</h2><p>​        具体<a href="https://naotu.baidu.com/file/70158a0693b8421b3bd0fe56cde6e361?token=6e76ac0c14851a5b">脑图</a></p><p>​        比较复杂,暂时不写</p><h1 id="Linux中关于红黑树的函数"><a href="#Linux中关于红黑树的函数" class="headerlink" title="Linux中关于红黑树的函数"></a>Linux中关于红黑树的函数</h1><p>​        Linux中关于红黑树重要的函数有:<code>__rb_rotate_left()</code>,<code>__rb_rotate_right()</code> ,<code>rb_link_node()</code>,<code>rb_insert_color()</code>,<code>rb_erase()</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __rb_rotate_left(struct rb_node *node, struct rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">right</span> = <span class="title">node</span>-&gt;<span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">rb_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;rb_right = right-&gt;rb_left))                   <span class="comment">//node的右指针指向node右孩子的左孩子</span></span><br><span class="line">        rb_set_parent(right-&gt;rb_left, node);                 <span class="comment">//node右孩子的左孩子的父亲指定为node</span></span><br><span class="line">    right-&gt;rb_left = node;</span><br><span class="line"></span><br><span class="line">    rb_set_parent(right, parent);                            <span class="comment">//node右孩子祖父指定为node原父亲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)                                              <span class="comment">//node原父亲存在，即原node不是根结点,需要修改原node父结点的指向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == parent-&gt;rb_left)</span><br><span class="line">            parent-&gt;rb_left = right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;rb_right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    <span class="comment">//原node是根结点</span></span><br><span class="line">        root-&gt;rb_node = right;</span><br><span class="line">    rb_set_parent(node, right);                             <span class="comment">//node现任父亲指定为node原右孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __rb_rotate_right(struct rb_node *node, struct rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> = <span class="title">node</span>-&gt;<span class="title">rb_left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">rb_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;rb_left = left-&gt;rb_right))                   <span class="comment">//node的左指针指向node左孩子的右孩子</span></span><br><span class="line">        rb_set_parent(left-&gt;rb_right, node);                <span class="comment">//node的左孩子的右孩子的父亲指定为node</span></span><br><span class="line">    left-&gt;rb_right = node;</span><br><span class="line"></span><br><span class="line">    rb_set_parent(left, parent);                            <span class="comment">//node左孩子的祖父指定为node原父亲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)                                             <span class="comment">//node原父亲存在,即原node不是根结点,需要修改原node父结点的指向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == parent-&gt;rb_right)</span><br><span class="line">            parent-&gt;rb_right = left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;rb_left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    </span><br><span class="line">        root-&gt;rb_node = left;                               <span class="comment">//node是根节点</span></span><br><span class="line">    rb_set_parent(node, left);                              <span class="comment">//node现任父亲指点为node原右孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        有了左转, 右转的定义,可以进程插入删除操作了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rb_insert_color</span><span class="params">(struct rb_node *node, struct rb_root *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>, *<span class="title">gparent</span>;</span></span><br><span class="line">    <span class="comment">//情况1,2：node不是根结点，即有父结点P且P是红色的</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; rb_is_red(parent))</span><br><span class="line">    &#123;</span><br><span class="line">        gparent = rb_parent(parent);</span><br><span class="line">        <span class="comment">//P是祖父G的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (parent == gparent-&gt;rb_left)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">uncle</span> = <span class="title">gparent</span>-&gt;<span class="title">rb_right</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; rb_is_red(uncle)) <span class="comment">//情况3：node的叔父结点是红色的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rb_set_black(uncle);</span><br><span class="line">                    rb_set_black(parent);</span><br><span class="line">                    rb_set_red(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况4：node和父结点P是LR型(变成LL型)</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;rb_right == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">                __rb_rotate_left(parent, root);</span><br><span class="line">                tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况5：node和父结点P是LL型</span></span><br><span class="line">            rb_set_black(parent);</span><br><span class="line">            rb_set_red(gparent);</span><br><span class="line">            __rb_rotate_right(gparent, root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//P是祖父G的右孩子，与上述情况对调</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> struct rb_node *uncle = gparent-&gt;rb_left;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; rb_is_red(uncle))</span><br><span class="line">                &#123;</span><br><span class="line">                    rb_set_black(uncle);</span><br><span class="line">                    rb_set_black(parent);</span><br><span class="line">                    rb_set_red(gparent);</span><br><span class="line">                    node = gparent;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;rb_left == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">                __rb_rotate_right(parent, root);</span><br><span class="line">                tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rb_set_black(parent);</span><br><span class="line">            rb_set_red(gparent);</span><br><span class="line">            __rb_rotate_left(gparent, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若node是根结点||node的父结点P是黑色的，则把根结点-&gt;黑色</span></span><br><span class="line">    rb_set_black(root-&gt;rb_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
