<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第四章 设立自己的处理器 | OnePiece</title><meta name="keywords" content="CSAPP"><meta name="author" content="不想画CAD"><meta name="copyright" content="不想画CAD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="基础硬件控制语言​        硬件描述语言（Hardware Description Language，HDL）可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。逻辑合成程序（Logic Synthesis）可以根据HDL的描述来生成有效的电路设计。所以从手工设计电路到合成生成的转变，就好像从手写汇编到高级语言的转变。 ​        硬件控制语言（Hard">
<meta property="og:type" content="article">
<meta property="og:title" content="第四章 设立自己的处理器">
<meta property="og:url" content="https://levnzzz.github.io/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8/csapp-4/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/index.html">
<meta property="og:site_name" content="OnePiece">
<meta property="og:description" content="基础硬件控制语言​        硬件描述语言（Hardware Description Language，HDL）可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。逻辑合成程序（Logic Synthesis）可以根据HDL的描述来生成有效的电路设计。所以从手工设计电路到合成生成的转变，就好像从手写汇编到高级语言的转变。 ​        硬件控制语言（Hard">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/10/17/Z63WiowRkJdsO1K.jpg">
<meta property="article:published_time" content="2020-10-18T07:32:24.000Z">
<meta property="article:modified_time" content="2020-10-18T07:37:50.583Z">
<meta property="article:author" content="不想画CAD">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/10/17/Z63WiowRkJdsO1K.jpg"><link rel="shortcut icon" href="https://i.loli.net/2020/10/11/SihaqID2rXypTtj.jpg"><link rel="canonical" href="https://levnzzz.github.io/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8/csapp-4/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isSidebar: true,
  postUpdate: '2020-10-18 15:37:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/10/11/SihaqID2rXypTtj.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">硬件控制语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">逻辑设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">组合逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E6%97%B6%E9%92%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">存储器和时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">硬件寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">寄存器文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.3.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">虚拟内存系统</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E6%8C%87%E4%BB%A4%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Y86-64指令体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8D%95%E5%85%83"><span class="toc-number">2.1.1.</span> <span class="toc-text">状态单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Y86-64%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">Y86-64指令及其编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Y86-64%E7%A8%8B%E5%BA%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.3.</span> <span class="toc-text">Y86-64程序例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">2.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">Y86-64的顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">处理指令的阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">SEQ硬件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E7%9A%84HCL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">SEQ的HCL表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%9D%80%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">取址阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">译码和写回阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">执行阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E5%AD%98%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">访存阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0PC%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">更新PC阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E6%80%A7%E8%83%BD"><span class="toc-number">2.3.4.</span> <span class="toc-text">SEQ性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">流水线实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.1.</span> <span class="toc-text">流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">流水线基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">流水线局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">不一致的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%BF%87%E6%B7%B1%EF%BC%8C%E6%94%B6%E7%9B%8A%E4%B8%8B%E9%99%8D"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">流水线过深，收益下降</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3"><span class="toc-number">3.1.3.</span> <span class="toc-text">指令相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">Y86-64流水线实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ-%E5%92%8CPIPE"><span class="toc-number">3.2.1.</span> <span class="toc-text">SEQ+和PIPE-</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">3.2.2.</span> <span class="toc-text">处理控制相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.</span> <span class="toc-text">流水线冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%9A%82%E5%81%9C%E6%9D%A5%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">用暂停来避免数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%BD%AC%E5%8F%91%E6%9D%A5%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">用转发来避免数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">加载&#x2F;使用数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">避免控制冒险</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.2.4.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PIPE%E7%9A%84HCL%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">PIPE的HCL代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PC%E9%80%89%E6%8B%A9%E5%92%8C%E5%8F%96%E6%8C%87%E9%98%B6%E6%AE%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">PC选择和取指阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E%E9%98%B6%E6%AE%B5-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">译码和写回阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">执行阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E5%AD%98%E9%98%B6%E6%AE%B5-1"><span class="toc-number">3.3.4.</span> <span class="toc-text">访存阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="toc-number">3.4.</span> <span class="toc-text">流水线控制逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E5%92%8C%E6%B0%94%E6%B3%A1"><span class="toc-number">3.4.1.</span> <span class="toc-text">暂停和气泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-%E4%BD%BF%E7%94%A8%E5%86%92%E9%99%A9"><span class="toc-number">3.4.2.</span> <span class="toc-text">加载&#x2F;使用冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86ret%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.3.</span> <span class="toc-text">处理ret指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-number">3.4.4.</span> <span class="toc-text">预测错误的分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.5.</span> <span class="toc-text">异常指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%BB%84%E5%90%88"><span class="toc-number">3.4.6.</span> <span class="toc-text">特殊情况组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%80%BB%E8%BE%91%E7%9A%84HCL%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.7.</span> <span class="toc-text">流水线逻辑的HCL代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.4.8.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9"><span class="toc-number">3.5.</span> <span class="toc-text">额外内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.</span> <span class="toc-text">多周期指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">与存储系统接口的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%9A%84%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.5.3.</span> <span class="toc-text">当前的微处理器设计</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/10/17/Z63WiowRkJdsO1K.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">OnePiece</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">第四章 设立自己的处理器</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-18T07:32:24.000Z" title="发表于 2020-10-18 15:32:24">2020-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-18T07:37:50.583Z" title="更新于 2020-10-18 15:37:50">2020-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/">细读经典</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/">《CSAPP》</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="硬件控制语言"><a href="#硬件控制语言" class="headerlink" title="硬件控制语言"></a>硬件控制语言</h2><p>​        <strong>硬件描述语言（Hardware Description Language，HDL）</strong>可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。<strong>逻辑合成程序（Logic Synthesis）</strong>可以根据HDL的描述来生成有效的电路设计。所以从手工设计电路到合成生成的转变，就好像从手写汇编到高级语言的转变。</p>
<p>​        <strong>硬件控制语言（Hardware Control Language，HCL）只</strong>表达硬件设计的控制部分，只有有限的操作集合，也没有模块化，可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-hcl.pdf">这里</a>。</p>
<p>​        这么课开发了将HCL翻译成Verilog的工具，然后结合基本硬件单元的Verilog代码，就能产生HDL描述，由此就能合成实际能工作的微处理器了。可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-verilog.pdf">这里</a>。</p>
<h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>​        当前逻辑<code>1</code>是由1.0伏特左右的高电压表示，逻辑<code>0</code>是由0.0伏特左右的低电压表示。</p>
<p>​        实现一个数字系统主要有<strong>三个组成部分：</strong></p>
<ul>
<li>计算对位进行操作的函数的组合逻辑</li>
<li>存储位的存储器单元</li>
<li>控制存储器单元更新的时钟信号</li>
</ul>
<h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>​        当前逻辑<code>1</code>是由1.0伏特左右的高电压表示，逻辑<code>0</code>是由0.0伏特左右的低电压表示。</p>
<p>​        实现一个数字系统主要有<strong>三个组成部分：</strong></p>
<ul>
<li><p>计算对位进行操作的函数的组合逻辑</p>
</li>
<li><p>存储位的存储器单元</p>
</li>
<li><p>控制存储器单元更新的时钟信号</p>
<p>逻辑门是数字电路的<strong>基本计算单元</strong>。如下图所示</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459134690-ff754684-78ba-470a-b627-dc7dc9af50ed.jpg" alt="image"></p>
<p>​        其中第一行是布尔表达式，第二行是标准符号，第三行是HCL表达式。我们可以将AND和OR扩展到多个输入的版本。    </p>
<p>​        <strong>注意：</strong>1. 逻辑门只对单个位的值进行操作。2. 当一个门的输入发生变化时，输出会很快相应变化。</p>
<p>​        将很多逻辑门组合成一个实现某种功能的网，就能构成<strong>计算块（Computational block）</strong>，称为<strong>组合电路（Combinational Circuits）</strong>。想要构建有效的组合电路，有以下<strong>限制：</strong></p>
<ul>
<li><p>每个逻辑门的输入必须连接到以下其中之一：</p>
</li>
<li><ul>
<li>一个系统输入</li>
<li>某个存储器单元的输出</li>
<li>某个逻辑门的输出</li>
</ul>
</li>
<li><p>两个或多个逻辑门的输出不能连接在一起</p>
</li>
<li><p>网络不能形成回路</p>
</li>
</ul>
<p><strong>例1：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135037-648b2c9f-a4b0-479d-b565-e50935dda906.jpg" alt="image"></p>
<p>​        <strong>HCL表达式：</strong><code>bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</code></p>
<p>​        <strong>功能：</strong>用来判断输入<code>a</code>和<code>b</code>是否相同，结果保存在<code>eq</code>中。</p>
<p><strong>例2：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135096-748ed7f5-b7fc-421b-880b-a7e8fa4087da.jpg" alt="image"></p>
<p>​        <strong>HCL表达式：</strong><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></p>
<p>​        <strong>功能：</strong>该组合电路称为<strong>多路复用器（Multiplexor，MUX）</strong>， 当<code>s=1</code>时，<code>out</code>的值就是<code>a</code>的值；当<code>s=0</code>时，<code>out</code>值就是<code>b</code>的值。</p>
<p>​        <strong>HCL表达式和C语言逻辑表达式区别：</strong></p>
<ul>
<li><p><code>=</code>在HCL表达式中表示给表达式赋予的名字</p>
</li>
<li><p>组合电路中输出会持续相应输入的变化，而C语言只有在程序执行过程中遇到了才进行求职</p>
</li>
<li><p>逻辑门只允许对0和1进行操作，而C语言将0表示为FASLE，将其余任意值表示为TRUE</p>
</li>
<li><p>C语言中存在部分求值的特点，组合逻辑中不存在</p>
<p>​    以上HCL都是对单个位进行运算的，可以很容易对其进行扩展实现对数据<strong>字（Word）</strong>进行操作的电路。</p>
</li>
</ul>
<p><strong>例1：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135084-45b97dc7-f231-4a0b-adb9-75ff49f70f66.jpg" alt="image"></p>
<p>​        直接合并64个位级相等的组合电路，再加上一个逻辑与门，就能得到一个64位的字级相等组合电路。右边是对其的抽象，其中实线表示字级信号，虚线表示布尔信号。</p>
<p>​        为了简单，可以将所有字级信号都声明为int，不指定字的大小，则该组合电路可以由两个int类型的参数A和B构成的HCL表达式描述<code>bool Eq = (A == B);</code>。</p>
<p><strong>例2：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597459135004-df8cadeb-e9a0-4797-8432-ea603722ae83.jpeg" alt="image"></p>
<p>​        这是一个64位字级多路复用器电路。这里只产生了一次<code>!s</code>，可以减少需要的逻辑门数量。在HCL中，多路复用器函数可以用<strong>情况表达式（Case Expression）</strong>来描述</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  select1 : expr1;</span><br><span class="line">  select2 : expr2;</span><br><span class="line">  ...</span><br><span class="line">  selectk : exprk;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>​        其中，<code>select</code>是布尔表达式，<code>expr</code>是字级表达式。</p>
<p>​        <strong>注意：</strong>1. 在HCL中，不要求不同的选择表达式之间是互斥的，但是实际的多路复用器的信号必须互斥。2. 选择表达式是<strong>顺序求值</strong>的，所以后续的选择表达式可以在之前的选择表达式的基础上进行简化。</p>
<p>​        右侧是字级多路复用器的抽象，根据HCL表达式可知，首先根据<code>s</code>的值来判断是否选择<code>A</code>，如果不选择，就一定会选择<code>B</code>。</p>
<p><strong>例3：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135030-f4998ae1-4045-4f68-aeae-8294453f4335.jpg" alt="image"></p>
<p>​        这是一个通过两个信号来控制的四路复用器。对应的HCL表达式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Out4 = [</span><br><span class="line">  !s1 &amp;&amp; !s2 : A; #<span class="number">00</span></span><br><span class="line">  !s1        : B; #<span class="number">01</span></span><br><span class="line">  !s2        : C; #<span class="number">10</span></span><br><span class="line">  <span class="number">1</span>          : D; #<span class="number">11</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>​        而我们需要从两位<code>code</code>中提取出两个信号，可以通过相等测试：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code == <span class="number">2</span> || code == <span class="number">3</span>;</span><br><span class="line">bool s0 = code == <span class="number">1</span> || code == <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>​        也可以通过<strong>判断集合关系</strong>的方式，其通用格式为<code>iexpr in &#123;iexpr1, iexpr2, ..., iexprk&#125;</code>，所以可以表示为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code in &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">bool s0 = code in &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>​        比较重要的一个字级组合电路是<strong>算数/逻辑单元（ALU）</strong>，它包含3个输入：标号为A和B的两个数据输入，以及一个控制输入。根据控制输入的值来选择要对A和B进行的运算。如下图所示，是位Y86-64设计的ALU模型。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459135014-f1e22695-71c5-44e5-9ee2-f08a9525904a.jpg" alt="image"></p>
<p>​        <strong>注意：</strong>组合电路值进行逻辑运算，不设计存储信息，当某个抽象能够存储信息，就不是组合电路。</p>
<h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>​        为了产生<strong>时序电路（Sequential Circuit）</strong>，即存在状态并且能在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。而这些存储设备是由同一个具有周期性信号的<strong>时钟</strong>控制的，决定什么时候将新值保存到存储器中。</p>
<p>​        主要有<strong>两类存储器设备：</strong></p>
<ul>
<li><p><strong>时钟寄存器（寄存器）：</strong>存储单个位或字，主要作为电路不同部分的组合逻辑之间的屏障。</p>
</li>
<li><p><strong>随机访问存储器（内存）：</strong>存储多个字，用地址来选择读写哪个字。<strong>包括：</strong></p>
</li>
<li><ul>
<li><strong>处理器的虚拟内存系统：</strong>通过操作系统对存储器进行抽象，使得处理器可以在很大的地址空间中访问，地址为虚拟内存的索引值。</li>
<li><strong>寄存器文件：</strong>是一个以寄存器标识符为地址，存储着对应程序寄存器值的随机访问存储器。在IA32或Y86-64处理器中，有15个程序寄存器（<code>%rax</code>~<code>%r14</code>）。</li>
</ul>
</li>
</ul>
<p>​        这里要注意区分机器级编程中的寄存器和硬件中的寄存器</p>
<ul>
<li><strong>硬件：</strong>寄存器指的是时钟寄存器，直接将它的输入和输出连接到电路的其他部分。这里称为硬件寄存器。</li>
<li><strong>机器级编程：</strong>寄存器代表的是存储在寄存器文件中的，CPU中少数可寻址的字，地址为寄存器标识符。这里称为程序寄存器。</li>
</ul>
<h4 id="硬件寄存器"><a href="#硬件寄存器" class="headerlink" title="硬件寄存器"></a>硬件寄存器</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459861451-6f692ec1-9e31-4ee7-890f-2b5a30c6322f.jpg" alt="image"></p>
<p>​        如上图所示，硬件寄存器大多数时候会保持在稳定状态x，产生的输出也是它当前的状态。当寄存器的输入发生改变时，寄存器的输出也不会马上变化，而是等时钟变成高电位时，才会将当前状态修改为输入值。由此将当前寄存器两侧的逻辑电路分隔开来。</p>
<p>​        Y86-64处理器会使用硬件寄存器老保存程序计数器（PC）、条件代码（CC）和程序状态（Stat）。</p>
<h4 id="寄存器文件"><a href="#寄存器文件" class="headerlink" title="寄存器文件"></a>寄存器文件</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459861504-bc5c7eb8-0da1-404a-9989-9946317463f0.jpg" alt="image"></p>
<p>​        寄存器文件包含两个读端口和一个写端口，意味着能读取两个程序寄存器的同时对第三个程序寄存器进行写操作。这里的地址就是程序寄存器标识符。<strong>（两读一写）</strong></p>
<p>​        寄存器文件的写入操作受时钟信号控制，只有当时钟为高电平时，才将<code>valW</code>中的值写入<code>dstw</code>指示的程序寄存器中。</p>
<h4 id="虚拟内存系统"><a href="#虚拟内存系统" class="headerlink" title="虚拟内存系统"></a>虚拟内存系统</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597459861454-8340a5c3-9fce-41ff-b15c-db99d4f7193b.jpg" alt="image"></p>
<p>​        处理器用虚拟内存来保存程序数据。<code>read</code>和<code>write</code>是两个标志位，用来控制当前是要读还是写。包含通过逻辑电路实现的边界检查，如果地址超过虚拟内存地址空间，就会使得<code>error=1</code>。</p>
<p>​        虚拟内存的写入操作受时钟信号控制，只有当<code>write=1</code>并且时钟为高电平时，才会将<code>data in</code>的数据保存到对应地址的位置。</p>
<p>​        <strong>注意：</strong>向存储器（时钟寄存器、随机访问存储器）写入值时会受到时钟的控制，所以存在时序，而向存储器读取值时不受到时钟的控制，不存在时序，可以直接将其近似于逻辑电路，输入地址，一段延迟后，就会将值返回到输出中。</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/office/yuque/0/2020/pdf/1413496/1597460297959-5f8f3ecf-1e0a-4ce7-b27c-263f692c543d.pdf?from=file:///Applications/%E8%AF%AD%E9%9B%80.app/Contents/Resources/app.asar/build/renderer/index.html?locale=zh-CN&isYuque=true&theme=1%23/editor">waside-hcl.pdf</a></p>
<h1 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h1><h2 id="Y86-64指令体系结构"><a href="#Y86-64指令体系结构" class="headerlink" title="Y86-64指令体系结构"></a>Y86-64指令体系结构</h2><h3 id="状态单元"><a href="#状态单元" class="headerlink" title="状态单元"></a>状态单元</h3><p>​        我们将每条指令会读取或修改处理器状态的部分称为<strong>程序员可见</strong>状态，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597460521723-6fbd90e0-837f-453f-b098-e72112229d24.jpg" alt="image"></p>
<ul>
<li><strong>程序寄存器RF：</strong>这里对x86-64的寄存器进行省略，降低复杂度。其中<code>%rsp</code>用于指示出栈、入栈、函数调用和返回地址。</li>
<li><strong>条件码CC：</strong>保存最近算数或逻辑指令造成的影响。</li>
<li><strong>程序计数器PC：</strong>保存当前正在执行的指令的地址。</li>
<li><strong>内存DEME：</strong>操作系统将物理内存抽象为一个单一的字节数组。</li>
<li><strong>程序状态Stat：</strong>表明当前程序运行的状态，取值如下图所示。当出现异常时，处理器会调用异常处理程序，这里为了简化，直接让处理器停止执行指令。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597460521578-a971fccb-a696-466b-88be-1724d92b294a.jpg" alt="image"></p>
<h3 id="Y86-64指令及其编码"><a href="#Y86-64指令及其编码" class="headerlink" title="Y86-64指令及其编码"></a>Y86-64指令及其编码</h3><p>​        指令集的设计要求字节编码要有唯一的解释。这里实现如下图所示的Y86-64指令集，左侧为汇编指令，右侧为指令对应的编码。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597461006623-f06d2893-2ec8-4f92-8cdc-f632d80785d3.jpeg" alt="image"></p>
<ul>
<li>传送指令分成了<code>rrmovq</code>、<code>irmovq</code>、<code>rmmovq</code>和<code>mrmovq</code>。其中第一个字母表示源，第二个字母表示目的，<code>r</code>寄存器、<code>i</code>立即数、<code>m</code>内存。这里为了简化，只支持基址和偏移量形式的内存引用。</li>
<li>整数操作指令<code>OPq</code>，包含<code>addq</code>、<code>subq</code>、<code>andq</code>和<code>xorq</code>。会设置条件码<code>ZF</code>、<code>SF</code>和<code>OF</code>。</li>
<li>跳转指令<code>jXX</code>，包括<code>jmp</code>、<code>jle</code>、<code>jl</code>、<code>je</code>、<code>jne</code>、<code>jge</code>和<code>jg</code>。这里<code>jXX</code>使用绝对地址。</li>
<li>条件传送指令<code>cmovXX</code>，包括<code>cmovle</code>、<code>cmovl</code>、<code>cmove</code>、<code>cmovne</code>、<code>cmovge</code>和<code>cmovg</code>。</li>
<li><code>call</code>使用绝对地址。</li>
<li><code>push</code>和<code>pop</code>是对栈的调整，<code>push %rsp</code>是先将<code>%rsp</code>的内容保存到栈中，再对<code>%rsp</code>减8；<code>pop %rsp</code>等价于<code>mrmovq (%rsp), %rsp</code>。</li>
<li><code>halt</code>指令停止指令的执行。</li>
</ul>
<p>​        我们将指令的高8位称为<strong>指令指示符</strong>，可以用来确定指令类型，其中高4位为<strong>代码部分</strong>，低4位为<strong>功能部分</strong>。代码部分能确定指令执行的步骤，而功能部分能确定ALU要进行什么运算以及确定条件码的组合，比如功能部分我<code>1</code>表示让ALU进行减法运算并设置对应的条件码，则整数操作指令会得到计算结果，分支指令和传送指令会根据条件码来确定是否跳转和传送。<code>OPq</code>、<code>jXX</code>和<code>cmovXX</code>的编码如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597461006553-c9d7e02a-e924-4129-b4e9-d1e0fa86b5b7.jpeg" alt="image"></p>
<p>​        <strong>对于指令操作数的编码：</strong></p>
<ul>
<li>当指令不包含操作数时，比如<code>ret</code>，只需要一个字节长度。</li>
<li>当指令包含寄存器作为操作数时，需要额外添加<strong>寄存器指示符字节</strong>，可以使用如下图所示的寄存器标识符，当只有一个寄存器操作数时，需要将另4个字节标识为<code>0xF</code>。此时需要两个字节长度。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597461006581-5339de63-82e0-48a9-8dbe-682817f52585.jpg" alt="image"></p>
<ul>
<li>当指令包含立即数、带偏移量的内存引用和目标地址，需要额外的8字节进行编码。</li>
</ul>
<p><strong>例：</strong><code>rmmovq %rsp, 0x123456789abcd(%rdx)</code>的编码</p>
<p>​        <code>rmmovq</code>的编码形式为</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1597461006651-3a02818f-e649-4e7f-89ef-48d6f68bddf7.png" alt="image"></p>
<p>​        其中，<code>%rsp</code>的寄存器标志符为<code>0x4</code>，<code>%rdx</code>的寄存器标志符为<code>0x2</code>。这里立即数不满足8字节，所以需要在其前面填充得到8字节，即<code>0x000123456789abcd</code>，由于采用小端法，所以要对字节顺序进行调整得到<code>cd ab 89 67 45 23 01 00</code>。最终将所有编码都拼接起来，得到<code>40 42 cd ab 89 67 45 23 01 00</code>。</p>
<h3 id="Y86-64程序例子"><a href="#Y86-64程序例子" class="headerlink" title="Y86-64程序例子"></a>Y86-64程序例子</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> *start, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1597462762924-6ac29e47-8145-4a49-ad51-1bf5087f0c30.png" alt="image.png"></p>
<p>​        这里可以通过汇编器YAS将其转变为可执行代码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597462010337-4dfc21c1-754f-4359-ae1d-0a9decd824a7.jpeg" alt="image"></p>
<p>​        以上是Y86-64完整的汇编代码。其中以<code>.</code>开头的为<strong>汇编器伪指令（Assembler Directives）</strong>，用于让汇编器调整地址。<code>.pos address</code>表示从<code>address</code>处开始产生代码，如第2行的<code>.pos 0</code>表示从0开始产生代码，第<code>.pos 0x200</code>表示从<code>0x200</code>处开始产生栈。<code>.align 8</code>表示在8字节边界处对其。</p>
<p>​        这里实现了一个指令集模拟器YIS，可以模拟Y86-64机器代码程序的执行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597462010275-a875301f-5ad3-48cb-be62-77019a860a64.jpeg" alt="image"></p>
<h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><h3 id="处理指令的阶段"><a href="#处理指令的阶段" class="headerlink" title="处理指令的阶段"></a>处理指令的阶段</h3><p>​        处理一条指令我们可以将其划分成若干个阶段：</p>
<ol>
<li><p><strong>取指（Fetch）：</strong>根据程序计数器PC从内存中读取指令字节。然后完成以下步骤</p>
</li>
<li><ol>
<li>从指令中提取出指令指示符字节，并且确定出指令代码（<code>icode</code>）和指令功能（<code>ifun</code>）</li>
<li>如果存在寄存器指示符，则从指令中确定两个寄存器标识符<code>rA</code>和<code>rB</code></li>
<li>如果存在常数字，则从指令中确定<code>ValC</code></li>
<li>根据指令指令长度以及指令地址，可确定下一条指令的地址<code>valP</code></li>
</ol>
</li>
<li><p><strong>译码（Decode）：</strong>如果存在<code>rA</code>和<code>rB</code>，则译码阶段会从寄存器文件中读取<code>rA</code>和<code>rB</code>的值<code>valA</code>和<code>valB</code>。对于<code>push</code>和<code>pop</code>指令，译码阶段还会从寄存器文件中读取<code>%rsp</code>的值。</p>
</li>
<li><p><strong>执行（Execute）：</strong>算术逻辑单元（ALU）会根据<code>ifun</code>的值执行对应的计算，得到结果<code>valE</code>，包括</p>
</li>
<li><ol>
<li>计算运算结果，会设置条件码的值，则条件传送和跳转指令会根据<code>ifun</code>来确定条件码组合，确定是否跳转或传送。</li>
<li>计算内存引用的有效地址</li>
<li>增加或减少栈指针</li>
</ol>
</li>
<li><p><strong>访存（Memory）：</strong>写入内存或从内存读取数据<code>valM</code>。</p>
</li>
<li><p><strong>写回（Write Back）：</strong>将结果写入寄存器文件中。</p>
</li>
<li><p><strong>更新PC（PC Update）：</strong>将PC更新为<code>valP</code>，使其指向下一条指令。</p>
<p>​    接下来将Y86-64的指令按照以上框架进行整理</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816665-282dfcca-1a3b-40ad-ac01-b5af158aaf38.jpeg" alt="image"></p>
<p>​        这里可以发现，相同<code>icode</code>具有相同的步骤，而相同的<code>ifun</code>在执行阶段具有相同的计算方式，比如<code>addq</code>、<code>jmp</code>和<code>rrmovq</code>的<code>ifun</code>都是0，所以都进行加法计算。</p>
<p><strong>注意：</strong><code>OPq</code>中会将<code>ifun</code>传入给ALU来确定<code>OP</code>的类型。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816847-757248f0-a5fa-406c-bad9-ac62b7918506.jpeg" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816892-161f9091-985e-40f9-a7a4-02695d8dc24f.jpeg" alt="image"></p>
<p><strong>注意：</strong><code>pop</code>在译码阶段读了两次栈顶指针的值，这是为了使后续流程和别的指令相似。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816871-b93b8d82-c4f5-4e90-87d1-7c4761e2f3b7.jpeg" alt="image"></p>
<p>​        这里都会对PC值进行修改，<code>jXX</code>在执行阶段会根据<code>ifun</code>和条件码来设置是否跳转<code>Cnd</code>。<code>call</code>需要将下一条指令的地址作为返回值存入栈中，并修改栈顶指针的值。<code>ret</code>需要从栈顶指针出获得返回地址，将其设置为PC，并且还要修改栈顶指针的值。</p>
<p>​        这里的每一行表示某个值的计算（比如<code>valP</code>）或者激活某个硬件单元（比如内存），我们列出这些计算和动作，其中增加了<code>valA</code>的源<code>srcA</code>、<code>valB</code>的源<code>srcB</code>、写入计算结果<code>valE</code>的寄存器<code>dstE</code>、写入内存值<code>valM</code>的寄存器<code>dstM</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816932-19e9e99c-64b0-4a99-bc2c-12b29a79c065.jpeg" alt="image"></p>
<p>​        接下来将创建硬件设计来实现这6个阶段，并将其连接起来。</p>
<h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>​        我们可以得到顺序实现的SEQ抽象视图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816660-a5b3cd8b-fc1c-4bf9-aab3-0700749b233d.jpg" alt="image"></p>
<ul>
<li><p>数据内存和指令内存都是在相同的内存空间中，只是根据不同的功能对其进行划分</p>
</li>
<li><p>寄存器文件包含两个读端口<code>A</code>和<code>B</code>，以及两个写端口<code>M</code>和<code>E</code>，分别接收来自内存的值<code>valM</code>以及ALU计算的结构<code>valE</code>。</p>
</li>
<li><p>PC更新的值可能来自于：下一条指令地址<code>valP</code>、来自内存的值<code>valM</code>、调用指令或跳转指令的目标地址<code>valC</code>。</p>
<p>​    更加详细的图如下所示</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816905-28be5ca2-2f21-457e-a5c8-118b6d6d877b.jpeg" alt="image"></p>
<ul>
<li>白色方框为时钟寄存器（程序计数器PC是唯一时钟寄存器）；蓝色方框为硬件单元，当做黑盒子而不关心细节设计；白色圆圈表示线路名字。</li>
<li>宽度为字长的数据使用粗线；宽度为字节或更窄的数据用细线；单个位的数据用虚线，主要表示控制值。</li>
<li>灰色圆角矩形表示控制逻辑块，能在不同硬件单元之间传递数据，以及操作这些硬件单元，使得对每个不同的指令执行指定的运算。是本章的重点，会给出对应的HCL表达式。</li>
</ul>
<p>​        SEQ的实现包括组合逻辑和两种存储器：时钟寄存器（程序计数器和条件码寄存器）和随机访问存储器（寄存器文件、指令内存和数据内存）。我们知道组合逻辑和存储器的读取是没有时序的，只要输入一给定，输出就会发生对应的变化。但是存储器的写入是受到时钟的控制的，只有当时钟为高电位时，才会将值写入存储器中。</p>
<p>​        所以涉及到写数据的存储器（程序计数器、条件码寄存器、寄存器文件和数据内存）就需要对时序进行明确的控制，才能控制好指令各阶段的执行顺序。为了保证每条指令执行的结果能和上一节中介绍的顺序执行的结果相同，我们要保证指令的计算<strong>不会回读</strong>，即处理器不需要为了完成一条指令的执行而去读取由该指令更新的状态。因为该指令更新的状态是写入数据，需要经过一个时钟周期，如果该指令需要读取更新过的状态，就需要空出一个时钟周期。</p>
<p>​        我们通过寄存器和内存的时钟控制，由此设计了上一节中的指令执行阶段，这样能够保证即使所有状态同时更新，也能等价于顺序执行各个阶段，也保证了能够在一个周期中完成一条指令。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816650-2ed57158-ca7b-4bbf-be91-9be91d6387ed.jpeg" alt="image"></p>
<p>​        如上图所示，每次时钟从低电平变为高电平时，就会执行一条指令。开始执行<code>addq %rdx, %rbx</code>时，在时钟周期起点①处，会在寄存器和内存中写入上一条指令计算的结果，此时逻辑电路（白色部分）还没开始计算，到了时钟周期结尾②处，会执行得到该条指令的结果，并且更新程序计数器指向下一条指令，但是由于时钟还处于低电平，所以还未写入内存和寄存器中。当开始执行<code>je dest</code>时，在时钟周期起点③处，由于时钟变为了高电平，所以会将<code>addq %rdx, %rbx</code>计算的结果写入寄存器和内存中，此时就会指向<code>je dest</code>指令，但是逻辑电路还没还是计算，到了时钟周期结尾④处时，就会计算得到该条指令的结果，但是还没写入内存和寄存器中。</p>
<h3 id="SEQ的HCL表达式"><a href="#SEQ的HCL表达式" class="headerlink" title="SEQ的HCL表达式"></a>SEQ的HCL表达式</h3><p>​        我们首先对指令进行编码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1597463816673-84f7a512-aa39-4cbe-9815-5da72fbba4cf.jpeg" alt="image"></p>
<h4 id="取址阶段"><a href="#取址阶段" class="headerlink" title="取址阶段"></a>取址阶段</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463817523-f4a92a47-b9e2-4af8-a481-f80b896aaede.jpg" alt="image"></p>
<p>​        该部分访问<strong>内存硬件单元</strong>。首先以PC作为第一个字节的地址，一次从内存中读取10个字节。灰色部分是我们需要确定的HCL表达式</p>
<ul>
<li><code>icode</code>为第一字节的高4位，当指令地址越界时，指令内存会返回<code>imem_error</code>信号，此时直接将其表示为<code>nop</code>指令，否则获得高4位值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word icode = [</span><br><span class="line">  imem_error : INOP;</span><br><span class="line">  <span class="number">1</span>          : imem_icode;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ifun</code>为第一字节的低4位，当出现<code>imem_error</code>信号时，会使用默认功能码，否则获得低4位值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word ifun = [</span><br><span class="line">  imem_error : FNONE;</span><br><span class="line">  <span class="number">1</span>          : imem_ifun;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>instr_valid</code>表示是否为合法指令</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool instr_valid = icode in &#123;</span><br><span class="line">  INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>need_regids</code>表示该指令否包含寄存器指示符字节，如果指令不含有寄存器指示符字节，则会将其赋值为<code>0xFF</code>。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_regids = icode in &#123;</span><br><span class="line">  IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>need_valC</code>表示该指令是否含有常数字节</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_valC = icode in &#123;</span><br><span class="line">  IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PC增加器会根据PC值、<code>need_valC</code>和<code>need_regids</code>来确定<code>valP</code>值，则</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valP = PC+<span class="number">1</span>+need_regids+<span class="number">8</span>*need_valC</span><br></pre></td></tr></table></figure>

<h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><p>这两个阶段都涉及<strong>寄存器文件</strong>，会根据<code>icode</code>、条件信号<code>Cnd</code>、<code>rA</code>和<code>rB</code>来设置写入的目的和读取的源。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816702-91b90c6d-da3a-4a2f-be03-4424ad901c84.jpg" alt="image"></p>
<ul>
<li>写入的目的<code>dstE</code>和<code>dstM</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word dstE = [</span><br><span class="line">  icode in &#123;IRRMOVQ&#125; &amp;&amp; Cnd             : rB; #cmovXX指令，可以将其看成是rrmovq和条件信号Cnd的组合 </span><br><span class="line">  icode in &#123;IIRMOVQ, IOPQ&#125;              : rB;</span><br><span class="line">  icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP; #获取%rsp</span><br><span class="line">  <span class="number">1</span>                                     : RNONE;</span><br><span class="line">];</span><br><span class="line">word dstM = [</span><br><span class="line">  icode in &#123;IMRMOVQ, IPOPQ&#125; : rA;</span><br><span class="line">  <span class="number">1</span>                         : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>读取的源<code>srcA</code>和<code>srcB</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word srcA = [</span><br><span class="line">  icode in &#123;IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ&#125; : rA;</span><br><span class="line">  icode in &#123;IPOPQ, IRET&#125;                    : RRSP;</span><br><span class="line">  <span class="number">1</span>                                         : RNONE;</span><br><span class="line">];</span><br><span class="line">word srcB = [</span><br><span class="line">  icode in &#123;IOPQ, IRMMOVQ, IMRMOVQ&#125;     : rB;</span><br><span class="line">  icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP;</span><br><span class="line">  <span class="number">1</span>                                     : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>​        该部分包括<strong>ALU</strong>。该部分逻辑主要根据<code>icode</code>来设置进入ALU进行计算的两个数字<code>aluA</code>和<code>aluB</code>，会根据<code>ifun</code>来设置需要ALU进行的计算。其中根据<code>ifun</code>和条件码计算得到的条件信息<code>Cnd</code>是通过cond硬件模块。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816646-b86ed8f0-1c45-437a-bd54-45a22913e5d2.jpg" alt="image"></p>
<ul>
<li>进入ALU进行计算的两个值<code>aluA</code>和<code>aluB</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word aluA = [</span><br><span class="line">  icode in &#123;IRRMOVQ, IOPQ&#125;             : valA; #包含两个寄存器时，aluA为寄存器的值valA</span><br><span class="line">  icode in &#123;IIRMOVQ, IRMMOVQ, IMRMOVQ&#125; : valC; #当出现立即数、偏移量时，aluA为常数值</span><br><span class="line">  icode in &#123;ICALL, IPUSHQ&#125;             : -<span class="number">8</span>; #入栈需要将栈顶地址下移<span class="number">8</span>字节</span><br><span class="line">  icode in &#123;IRET, IPOPQ&#125;               : <span class="number">8</span>; #出栈需要将栈顶地址上移<span class="number">8</span>字节</span><br><span class="line">];</span><br><span class="line">word aluB = [</span><br><span class="line">  icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ&#125; : valB;</span><br><span class="line">  icode in &#123;IRRMOVQ, IIRMOVQ&#125;                                   : <span class="number">0</span>;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>设置ALU进行的函数<code>alufun</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word alufun = [</span><br><span class="line">  icode == IOPQ : ifun;</span><br><span class="line">  <span class="number">1</span>             : ALUADD;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>获得是否设置条件码<code>set_cc</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc = icode in &#123;IOPQ&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="访存阶段"><a href="#访存阶段" class="headerlink" title="访存阶段"></a>访存阶段</h4><p>​        这部分包含<strong>数据内存</strong>，设计从从数据内存读写程序数据。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816748-ef2b1171-70b9-42da-a645-76be9888974e.jpg" alt="image"></p>
<ul>
<li>确定是从内存中读取数据还是写入数据</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool mem_read = icode in &#123;IMRMOVQ, IPOPQ, IRET&#125;;</span><br><span class="line">bool mem_write = icode in &#123;IRMMOVQ, IPUSHQ, ICALL&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>获得内存地址<code>mem_addr</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem_addr = [</span><br><span class="line">  icode in &#123;IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ&#125; : valE; #IPUSHQ和ICALL设计栈地址计算，IRMMOVQ和IMRMOVQ设计内存引用计算，所以都是ALU的计算结果</span><br><span class="line">  icode in &#123;IPOPQ, IRET&#125;                     : valA; #这部分没涉及ALU计算</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>获得输入内存的数据<code>mem_data</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word mem_data = [</span><br><span class="line">  icode in &#123;IRMMOVQ, IPUSHQ&#125; : valA; #从寄存器获得值</span><br><span class="line">  icode == ICALL             : valP; #当调用函数时，会将返回地址写入内存中</span><br><span class="line">  #默认不写入任何信息</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>确定程序状态<code>Stat</code></strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Stat = [</span><br><span class="line">  imem_error || dmem_error: ASDR;</span><br><span class="line">  !instr_valid            : SINS;</span><br><span class="line">  icode == IHALT          : SHLT;</span><br><span class="line">  <span class="number">1</span>                       : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="更新PC阶段"><a href="#更新PC阶段" class="headerlink" title="更新PC阶段"></a>更新PC阶段</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1597463816727-43b872a5-c97d-4a76-9405-875a8d516fe7.jpg" alt="image"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word new_pc = [</span><br><span class="line">  icode == ICALL       : valC; #调用函数时，会直接将PC更新为目标函数的地址</span><br><span class="line">  icode == IJXX &amp;&amp; Cnd : valC; #当条件跳转指令满足时，会跳转到目标地址</span><br><span class="line">  icode == IRET        : valM; #ret会从内存中读取返回地址，所以是valM</span><br><span class="line">  <span class="number">1</span>                    : valP; #默认为valP</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="SEQ性能"><a href="#SEQ性能" class="headerlink" title="SEQ性能"></a>SEQ性能</h3><p>​        我们通过将指令执行过程划分成了若干个阶段，使得我们能通过统一框架来描述各个指令执行的过程，也能进一步减少需要的硬件。但是由于每次时钟变为高电平时需要写入数据，使得需要在一个时间周期内完成所有步骤，所以我们要求时钟周期特别慢。</p>
<p>​        比如执行<code>ret</code>时，当前PC指向<code>ret</code>指令的地址，当时钟变为高电平时，我们需要在下一次时钟变为高电平之前，完成：两次从寄存器文件读取<code>%rsp</code>内容，通过ALU计算<code>%rsp</code>上移8字节的地址，根据<code>%rsp</code>从内存中获得返回地址，然后将新的<code>%rsp</code>值写回寄存器文件中（此时由于时钟还是低电平，所以还没有真实写入，只是设置为了值）。由此能够保证在下一个时钟变为高电平时，能够把正确的<code>%rsp</code>值写回寄存器文件中。</p>
<p>​        而且我们可以发现，指令执行的不同阶段是在处理器的不同硬件部分，所以完全可以让不同指令同时运行，只要求他们处于不同阶段，这也是下一章中流水线的主要思想。</p>
<h1 id="流水线实现"><a href="#流水线实现" class="headerlink" title="流水线实现"></a>流水线实现</h1><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><h3 id="流水线基本原理"><a href="#流水线基本原理" class="headerlink" title="流水线基本原理"></a>流水线基本原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594078776358-9b342cfd-7722-41e7-a5e6-77a1fce48cca.jpg" alt="image"></p>
<p>​        我们将从头到尾执行一条指令所需的时间称为<strong>延迟（Delay）</strong>，则这里延迟为320ps。我们将系统在单位时间内能执行的指令数目称为**吞吐量（Throughput）。<br><img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594078889094-d4ca63b1-2db3-4f51-a524-6948d249f5aa.svg" alt="image"></p>
<p>​        意味着一秒能执行3.12G条指令。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594078862266-ee665c12-8f12-49ed-82db-cdd2b87ceb8e.jpg" alt="image"></p>
<p>​        对于每个阶段，我们需要100ps的组合逻辑计算时间以及20ps加载到寄存器的时间，所以我们这里能将时钟周期设定为120ps。并且我们可以发现每过一个时钟周期就有一条指令完成，所以吞吐量变为了8.33GIPS，提高了2.67倍。但是每条指令需要经过3个时钟周期，所以延迟为360ps，变为原来的1.12倍。</p>
<p>​        所以<strong>流水线特点</strong>为：提高系统的吞吐量，但是会轻微增加延迟。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594078993527-c9f9728b-981b-4d32-b2a3-dd2a79d06089.jpeg" alt="image"></p>
<p>​        上图是其中一段时间详细过程。</p>
<ol>
<li>239ps时，<code>I2</code>经过组合逻辑A的计算到达寄存器A，<code>I1</code>经过组合逻辑B的计算到达寄存器B，此时时钟还处于低电平，则流水线寄存器还未读取组合逻辑计算的结果，还保持着原来的值。</li>
<li>241ps时，时钟已经变成高电平了，此时寄存器就会读取组合逻辑计算的结果，将其保存到寄存器中。则寄存器A保存<code>I2</code>在组合逻辑A中计算的结果，寄存器B保存<code>I1</code>在组合逻辑B中计算的结果。</li>
<li>300ps时，寄存器中的值已经输入到下一阶段的逻辑电路一段时间了，则该输入信号会以不同的速率在逻辑电路中传播，形成了图中所示的<strong>波阵面（Curved Wavafront）</strong>。</li>
<li>359ps时，又重复到了1中相似的状态。</li>
</ol>
<p>​        <strong>时钟周期的影响：</strong>时钟周期用来控制流水线寄存器的读取频率，用来将不同阶段分隔开来，互不干扰。如果时钟周期太快，组合逻辑的计算还未完成，就会使得非法的值保存到寄存器中。如果时钟周期太慢，不会导致计算错误，只是效率会比较低。</p>
<h3 id="流水线局限性"><a href="#流水线局限性" class="headerlink" title="流水线局限性"></a>流水线局限性</h3><h4 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h4><p>​        处理器中的某些硬件单元，比如ALU或内存，是无法划分成多个延迟较小的单元的，这使得我们划分的不同阶段的组合逻辑具有不同的延迟。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079372802-9d316417-dcff-4455-b9ae-f42dc024d223.jpeg" alt="image"></p>
<p>​        如上图所示，其中组合逻辑B需要150ps进行计算。由于整个系统共用一个时钟周期，为了保证组合逻辑B能在一个时钟周期内计算出正确结果，使得保存到流水线寄存器中，我们就需要将时钟周期设定为150+20=170ps，这使得系统吞吐量变为5.88GIPS，而运行一条指令需要的延迟为3*170=510ps。</p>
<p>​        <strong>注意：</strong>想要吞吐量最大，我们需要使得时钟周期尽可能小，而时钟周期受到最慢的组合逻辑的限制，所以我们可以将最大的组合逻辑的时间加上一个寄存器的时延作为时钟周期。想要延迟最小，就不使用流水线。</p>
<h4 id="流水线过深，收益下降"><a href="#流水线过深，收益下降" class="headerlink" title="流水线过深，收益下降"></a>流水线过深，收益下降</h4><p>​        我们将每个组合逻辑进一步划分成更小的部分，构建更深的流水线</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079486756-6ba66012-b252-4075-8497-6c67ac27eee2.jpeg" alt="image"></p>
<p>​        这里时钟周期变为70ps，则吞吐量为14.29GIPS。这里我们可以发现，虽然我们将组合逻辑分成了更小的单元，使得组合逻辑的时延缩小了两倍，但是吞吐量的性能并没有提升两倍。这是由于更深的流水线，会扩大寄存器时延的影响，在70ps的时钟周期中，寄存器的时延就占了28.6%，意味着更深的流水线的吞吐量会依赖于寄存器时延的性能。</p>
<h3 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h3><p>​        真实系统中，指令之间存在两种形式的相关：</p>
<ul>
<li><p><strong>数据相关</strong>：下一条指令会用到这条指令计算出来的结果</p>
</li>
<li><p><strong>控制相关</strong>：一条指令要确定下一条指令的位置</p>
</li>
</ul>
<p>​        这些相关可能会导致流水线产生计算错误，称为<strong>冒险（Hazard）</strong>，包括：<strong>数据冒险（Data Hazard）</strong>和<strong>控制冒险（Control Hazard）</strong>。</p>
<h2 id="Y86-64流水线实现"><a href="#Y86-64流水线实现" class="headerlink" title="Y86-64流水线实现"></a>Y86-64流水线实现</h2><h3 id="SEQ-和PIPE"><a href="#SEQ-和PIPE" class="headerlink" title="SEQ+和PIPE-"></a>SEQ+和PIPE-</h3><p>​        为了平衡一个流水线系统各个阶段的延迟，需要使用<strong>电路重定时（Circuit Retiming）</strong>在不改变逻辑行为的基础上，修改系统的状态表示。如下图所示，顺序实现的SEQ中，更新PC阶段是在时钟周期结束时才执行的，通过组合电路计算得到的<code>icode</code>、<code>Cnd</code>、<code>valC</code>、<code>valM</code>和<code>valP</code>通过组合电路计算得到新的PC，将其保存到PC的时钟寄存器中。但是这些值是在不同阶段中计算出来的，所以SEQ+新增了一系列状态寄存器来保存之前计算出来的结果，然后将更新PC阶段放到了时钟周期开始执行，这样在每个阶段时钟周期变成高电平时就会将该阶段计算出来的值保存到状态寄存器中，然后PC逻辑电路就能根据当前的状态寄存器的值来预测下一步的PC值。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594079905309-a95d82cd-dd0e-46ab-a6e2-35c0c200a7aa.jpg" alt="image"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079747281-ae93ddc1-32dd-4033-b7cc-67b544a8631c.jpeg" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594079775213-83cebbab-a388-43ee-8de6-9a3ab84eec32.jpeg" alt="image"></p>
<p>​        SEQ与SEQ+对比，更新PC阶段移到了时钟周期开始</p>
<p>​        我们可以在各个阶段中加入流水线寄存器，并将信号重新排列来将SEQ+转换成初步的流水线处理器PIPE-，硬件结构如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594080040911-d1a087fd-2f45-4165-ad86-2b3a22fe472d.jpeg" alt="image"></p>
<ul>
<li>分别插入了5个流水线寄存器用来保存后续阶段所需的信号，编号为<code>F</code>、<code>D</code>、<code>E</code>、<code>M</code>和<code>W</code>。我们可以发现在<code>D</code>和<code>E</code>中都有<code>stat</code>信号，分别表示为<code>D_stat</code>和<code>E_stat</code>。在取指阶段和访存阶段都有通过逻辑计算得到<code>stat</code>信号，分别表示为<code>f_stat</code>和<code>m_stat</code>。</li>
<li>在SEQ+中，在译码阶段通过逻辑电路计算得到<code>dstE</code>和<code>dstM</code>，会直接将其连接到寄存器文件的写端口的地址输入，当计算出<code>valE</code>和<code>valM</code>时直接写回到对应寄存器中。但是<code>dstE</code>和<code>dstM</code>是在译码阶段计算出来的，而<code>valE</code>是在执行阶段计算得到，<code>valM</code>是在访存阶段获得的，在流水线系统PIPE-中各个阶段是相互独立的，当某条指令运行到写回阶段时，得到了<code>valE</code>和<code>valM</code>，但是当前的<code>dstE</code>和<code>dstM</code>是处于译码阶段的指令计算出来的，会出现错误，所以需要将<code>dstE</code>和<code>dstM</code>一直保存到后续的流水线寄存器中。<strong>通用规则：</strong>通过合并信号来减少寄存器状态和线路的数量。<strong>通用规则：</strong>我们要保存处于一个流水线阶段中的指令的所有信息。</li>
<li>我们可以发现，只有<code>call</code>指令需要将<code>valP</code>保存到内存中，即我们为了<code>call</code>指令需要将取指阶段得到的<code>valP</code>一直保存到后续的流水线寄存器中，直到访存阶段将其保存到内存中。但是我们发现<code>call</code>指令只使用<code>valB</code>保存<code>%rsp</code>的值，并不会使用<code>valA</code>，所以我们可以通过PIPE-中的<code>selectA</code>模块将<code>valP</code>保存到<code>valA</code>，由此就不需要保存<code>valP</code>了。同理条件跳转指令，当不选择跳转分支时，后面也需要<code>valP</code>，也可以将其保存到<code>valA</code>中，由此也不需要保存<code>valP</code>了。<strong>通用规则：</strong>我们要保存处于一个流水线阶段中的指令的所有信息。</li>
</ul>
<h3 id="处理控制相关"><a href="#处理控制相关" class="headerlink" title="处理控制相关"></a>处理控制相关</h3><p>​        对于<code>call</code>和<code>jmp</code>指令，下一条指令的地址就是<code>valC</code>，而除了条件分支和<code>ret</code>指令外，下一条指令的地址就是<code>valP</code>，这些指令不存在控制相关，使得流水线处理器能够每个时钟周期就处理一条指令。如果出现了条件分支，则需要该指令运行到执行阶段后才知道是否选择该分支，如果出现了<code>ret</code>指令，则需要该指令运行到访存阶段，才知道返回地址，此时就存在了控制相关，使得处理器要经过几个时钟周期才知道要运行的下一条指令的地址，所以<strong>控制冒险只会出现在**</strong>条件分支**<strong>和**</strong><code>ret</code>指令**<strong>中</strong>，我们可以通过预测下一条PC来处理这个问题。</p>
<ul>
<li><p><strong>条件分支：</strong>我们可以通过<strong>分支预测</strong>技术来预测分支方向，并根据预测开始取值。常见的技术包括：</p>
</li>
<li><ul>
<li><strong>总是选择（always taken，AT）：</strong>总是预测处理器选择了条件分支，因此预测PC值为<code>valC</code>，成功率大约为60%。</li>
<li><strong>从不选择（never taken，NT）：</strong>总是预测处理器不选择条件分支，因此预测PC值为<code>valP</code>，成功率大约为40%。</li>
<li><strong>反向选择、正向不选择（backward taken, forward not-taken，BTFNT）：</strong>条件分支通常用于循环操作，当跳转地址比下一条指令地址小，说明进入了循环，否则退出循环，而循环通常会执行多次，因此当跳转地址比下一条指令地址低就选择分支，否则就不选择分支， 成功率大约为65%。</li>
</ul>
</li>
<li><p><code>ret</code>指令：常见的技术包括</p>
</li>
<li><ul>
<li>暂停处理新指令，直到<code>ret</code>指令通过写回阶段知道下一条指令的地址</li>
<li>在取指单元中放入一个硬件栈，保存过程调用指令产生的返回地址</li>
</ul>
</li>
</ul>
<p>​        当预测PC出现错误时出现控制冒险，会执行错误的指令，所以会极大影响流水线处理器的性能，后面再讨论这个问题。</p>
<p>​        在本文中，条件分支使用AT策略，<code>ret</code>指令使用第一条策略。从PIPE-硬件结构中可知，在取值阶段首先根据<code>icode</code>从<code>valP</code>和<code>valC</code>中选出预测的PC值，对于<code>call</code>和分支使用<code>valC</code>，其他指令使用<code>valP</code>。然后<code>Select PC</code>逻辑电路再从<code>predPC</code>、<code>M_valA</code>和<code>W_valM</code>中进行选择。我们推测为什么是这样的</p>
<ul>
<li><strong>条件分支：</strong>首先条件分支在取指阶段会直接选择条件分支，使得<code>predPC</code>为<code>valC</code>，则当条件分支执行到译码阶段时，<code>valC</code>对应的指令就会在取指阶段开始执行。当条件分支执行到执行阶段时，可以通过<code>CC</code>知道是否真的要选择条件分支，如果真的选择分支，则继续执行，否则条件分支的下一条指令地址应该是<code>valP</code>，此时该条件分支对应的<code>valP</code>保存在<code>M_valA</code>中，所以可以让<code>Select PC</code>选择<code>M_valA</code>来重新执行条件分支的部分。</li>
<li><strong><code>ret</code>指令：</strong>当执行<code>ret</code>指令时，会暂停传入新的指令，知道<code>ret</code>指令执行到访存阶段时，才从内存中读取了下一条指令的返回地址，保存在<code>W_valM</code>中，所以<code>Select PC</code>可以选择<code>W_valM</code>来执行返回地址对应的指令。</li>
</ul>
<h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>​        流水线冒险主要包含数据冒险和控制冒险，当程序状态的读写<strong>不处于同一阶段</strong>，就可能出现数据冒险，当出现分支预测错误或<code>ret</code>指令时，会出现控制冒险。</p>
<p>​        程序寄存器的读取处于译码阶段，而写入处于写回阶段，因此程序寄存器会出现数据冒险的可能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594081587950-ad6e1798-fb62-4f42-b4fd-6cdc55bf909d.jpeg" alt="image"></p>
<p>​        我们在代码中插入了<strong>三行<code>nop</code>指令</strong>，则当<code>addq %rdx, %rax</code>处于译码阶段读取寄存器时，第一行和第二行指令已经完成了对寄存器<code>%rdx</code>和<code>%rax</code>的写入操作，因此该代码不会出现数据冒险，但是如果减少<code>nop</code>指令，第一行和第二行指令还没完成对寄存器的写入操作时，<code>addq %rdx, %rax</code>已经处于译码阶段读取寄存器了，此时就会读取到错误的值而出现数据冒险。由于读取操作和写入操作相差3个时钟周期，所以如果一条指令的操作数被它前面三条指令中的任何一条修改时，就会出现数据冒险。</p>
<p>​        而内存的读写都处于访存阶段、条件码寄存器的读写都处于执行阶段因此它们不会出现数据冒险的情况，而我们为每个阶段都在流水线寄存器中保留了stat值，所以当异常发生时，处理器就能有条理地停止。</p>
<p>​        所以这里我们主要探讨程序寄存器数据冒险和控制冒险。</p>
<h4 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h4><p>​        我们可以在执行阶段中插入一段自动产生的<code>nop</code>指令，来保持寄存器、内存、条件码和程序状态不变，使得当前指令停在译码阶段，并且会控制程序计数器不变，使得下一条指令停在取指阶段，直到产生指令的源操作数的指令通过了写回阶段。（相当于产生类似上图的指令序列）</p>
<p>​        该方法指令要停顿最少一个最多三个时钟周期，严重降低整体的吞吐量。</p>
<h4 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h4><p>​        对于以下代码我们可以发现，<code>I1</code>处于访存阶段而<code>I2</code>处于执行阶段，都还没有将<code>valE</code>保存在<code>%rdx</code>和<code>%rax</code>中，所以<code>I3</code>的译码阶段无法从寄存器文件中读取到正确的<code>%rax</code>和<code>%rdx</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594082041108-51f4ddc7-23d4-49ac-8997-740ac1df8e2f.jpg" alt="image"></p>
<p>​        但是即使还没有将<code>valE</code>保存到对应的寄存器文件中，其实<code>I1</code>在执行阶段已经将<code>%rdx</code>的值保存到流水线寄存器M中<code>M_valE</code>，而<code>I2</code>在执行阶段通过ALU计算得到了<code>%rax</code>的值<code>e_valE</code>，所以即使没有写入对应的寄存器文件中，已经能从<code>M_valE</code>和<code>e_valE</code>得到<code>%rax</code>和<code>%rbx</code>的值了</p>
<p>​        所以<code>I3</code>的译码阶段可以从以下形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA &#x3D; R[%rdx]</span><br><span class="line">valB &#x3D; R[%rax]</span><br></pre></td></tr></table></figure>

<p>​        变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA &#x3D; M_valE</span><br><span class="line">valB &#x3D; e_valE</span><br></pre></td></tr></table></figure>

<p>​        此时就不存在数据冒险，以及暂停了。</p>
<p>​        除了通过ALU的计算结果来转发，还能通过内存来进行转发，并且通过当前阶段的<code>dstE</code>和<code>dstM</code>与目标指令的<code>srcA</code>和<code>srcB</code>进行判断来决定是否转发。在处理器中，<code>valA</code>和<code>valB</code>一共有5个转发源：</p>
<ul>
<li><p><code>e_valE</code>：在执行阶段，ALU中计算得到的结果<code>valE</code>，通过<code>E_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令相邻需要访问非内存读取到寄存器寄存器的情况）</strong></p>
</li>
<li><p><code>M_valE</code>：将ALU计算的结果<code>valE</code>保存到流水线寄存器M中，通过<code>M_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空一个需要访问非内存读取到寄存器的寄存器的情况）</strong></p>
</li>
<li><p><code>m_valM</code>：在访存阶段，从内存中读取的值<code>valM</code>，通过<code>M_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空一个需要访问内存中读取到寄存器的寄存器的情况）</strong></p>
</li>
<li><p><code>W_valM</code>：将内存中的值<code>valM</code>保存到流水线寄存器W中，通过<code>W_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空两个需要访问内存中读取到寄存器的寄存器的情况）</strong></p>
</li>
<li><p><code>W_valE</code> ：将ALU计算的结果<code>valE</code>保存到流水线寄存器W中，通过<code>W_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。<strong>（两条指令空两个需要访问非内存读取到寄存器的寄存器的情况）</strong></p>
<p>​    数据转发需要在基本的PIPE-的硬件结构基础上增加一些额外的数据连接和控制逻辑，则PIPE的硬件结构如下图所示</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594082330068-06001aea-a9fd-4be0-a5de-c70779ae9fcb.jpeg" alt="image"></p>
<h4 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h4><p>​        <code>%rbx</code>的值通过转发技术可以从<code>M_valE</code>中获得，但是<code>%rax</code>的值需要<code>0x028</code>指令执行到访存阶段，才能从内存中读取到<code>%rax</code>的值，但是当前<code>0x028</code>指令处于执行阶段，所以无法通过转发技术来解决这个数据冒险。<strong>（两条指令相邻需要访问从内存读取到寄存器寄存器的情况）</strong></p>
<p>​        我们可以通过<strong>加载互锁（Load Interlock）</strong>方法来处理这种加载/使用数据冒险，其实就是引入了暂停，如下图所示，当<code>0x032</code>指令执行到译码阶段时，对该指令暂停一个时钟周期，此时<code>0x028</code>指令就能执行到访存阶段，此时就能从<code>m_valM</code>中获得<code>%rax</code>的值。</p>
<p>​        <strong>结合加载互锁和转发技术足以解决所有类型的数据冒险</strong>，并且对模型的吞吐量不会造成很大的影响。</p>
<h4 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h4><p>​        控制冒险只会出现在<code>ret</code>指令和跳转指令预测错方向时产生。</p>
<ul>
<li><code>ret</code>指令</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594083235880-a5ebcb1f-e832-4e69-8d1d-1133c75dccab.jpg" alt="image"></p>
<p>​        对于以上代码，对应的流水线图为</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083235859-68c9327e-9c37-468c-b66b-ba5aed8ddc4b.jpeg" alt="image"></p>
<p>​        可以发现，当执行<code>call proc</code>时，在取指阶段就能获得<code>valC</code>表示下一条指令的地址，所以会取到<code>ret</code>指令。而<code>ret</code>指令只有运行到访存阶段时才能获得返回地址<code>valM</code>，并且在写回阶段的时钟电平变高时，才会写入PC寄存器中，所以需要在<code>ret</code>指令后添加3个bubble。</p>
<ul>
<li>跳转指令</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083260527-b35c2ca5-3143-433a-a561-11ca27386ae0.jpeg" alt="image"></p>
<p>​        对于以上代码，对应的流水线图为</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083260542-c187d378-3bc0-4a6e-ba2b-eb87651ed09d.jpeg" alt="image"></p>
<p>​        首先对于跳转分支，我们采用AT策略，所以在执行<code>jne target</code>的取指阶段时获得的<code>valC</code>会直接作为下一条指令的地址。当跳转指令运行执行阶段时，就会通过<code>CC</code>和<code>ifun</code>得知是否预测正确，此时已经将下一条指令运行到译码阶段，第二条指令运行到了取指阶段，如果预测错误，就会分别插入两个bubble，避免运行到后续阶段，改变程序员可见状态，会浪费两个时钟周期。（相当于两个bubble）</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​        异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。当前的ISA包含三种内部产生的异常：1. halt指令；2. 非法指令码和功能码组合的指令；3. 取值或数据读写访问非法地址。外部产生的异常包括：接收到一个网络接口受到新包的信号、点击鼠标的信号等等。</p>
<p>​        在我们的ISA中，希望处理器遇到异常时，会停止并设置适当的状态码。<strong>要求：</strong>异常指令之前的所有指令已经完成，后续的指令都不能修改条件码寄存器和内存。流水线系统包含以下问题：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594083506935-d4896daf-77f0-4345-943b-c2097071acc4.jpg" alt="image"></p>
<ol>
<li>当同时多条指令引起异常时，处理器应该向操作系统报告哪个异常？<strong>基本原则：</strong>由流水线中最深的指令引起的异常，优先级最高，因为指令在流水线中越深的阶段，表示该指令越早执行。</li>
<li>在分支预测中，当预测分支中出现了异常，而后由于预测错误而取消该指令时，需要取消异常。</li>
</ol>
<p>在PIPE硬件架构中，我们对每个流水线寄存器中都设置了一个<code>stat</code>信号，用来保存当前阶段的异常信号，随着流水线的进行，就能解决以上问题：</p>
<ol>
<li><code>stat</code>信号只是简单存放在流水线寄存器的状态字段中，不会对流水线中的指令流有任何影响，保证了异常指令之前的指令都能完成，但是要<strong>禁止流水线中后面的指令不能更新条件码寄存器和内存</strong>。</li>
<li>当出现异常的指令到达写回阶段时，由于流水线中的指令是顺序执行的，所以能保证当前异常是最早出现的异常。</li>
<li>当条件分支预测错误时，直接取消该指令后，<code>stat</code>信号就不会保存下去了。</li>
<li>最终流水线寄存器W中的<code>stat</code>信号会被记录为程序状态。</li>
</ol>
<h2 id="PIPE的HCL代码"><a href="#PIPE的HCL代码" class="headerlink" title="PIPE的HCL代码"></a>PIPE的HCL代码</h2><p>​        从各个逻辑块开始设置</p>
<h3 id="PC选择和取指阶段"><a href="#PC选择和取指阶段" class="headerlink" title="PC选择和取指阶段"></a>PC选择和取指阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594083933704-b0003a5f-c160-449f-b4fb-60d5d22c1c4a.jpeg" alt="image"></p>
<p>​        当前阶段需要完成选择程序计数器的值，并且预测下一个PC值。</p>
<p>​        预测PC值时，对于<code>call</code>指令时，会直接将<code>valC</code>作为下一个PC值，对于条件分支指令，我们选择AT策略，所以也会直接将<code>valC</code>作为下一个PC值，其他除了<code>ret</code>指令外，都是使用<code>valP</code>作为下一个PC值。在图中为<code>Predict PC</code>模块，对应的HCL代码为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word f_predPC = [</span><br><span class="line">  f_icode in &#123;IJXX, ICALL&#125; : f_valC;</span><br><span class="line">  <span class="number">1</span>                        : f_valP;</span><br><span class="line">];<span class="comment">//预测分支</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>注意：</strong>这里需要用前缀表明使用了哪个阶段的值，比如<code>f_valC</code>表示使用了取指阶段中计算出来的<code>valC</code>，如果是<code>D_valC</code>表示保存在流水线寄存器D中的<code>valC</code>值。</p>
<p>​        选择PC值时主要分以下三种情况：</p>
<ol>
<li>当条件分支运行到执行阶段时，会知道是否出现预测错误，如果出现预测错误，则需要将PC值设置为<code>valP</code>值，而当前的<code>valP</code>值保存在<code>M_valA</code>中</li>
<li>当出现<code>ret</code>指令时，会暂停后续指令，直到<code>ret</code>指令运行到访存阶段时，从内存读取出了返回地址才是PC值，而当前返回地址保存在<code>W_valM</code>中</li>
<li>对于其他指令，直接使用预测的PC值<code>F_predPC</code>就行了</li>
</ol>
<p><strong>注意：</strong><code>f_predPC</code>表示当前阶段预测的下一个PC值，而<code>F_predPC</code>表示前一条指令预测的当前指令的PC值。</p>
<p>​        在图中为<code>Select PC</code>模块，对应的HCL代码为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word f_pc = [</span><br><span class="line">  #通过M_icode知道是否为条件分支指令，并且在执行阶段会根据ifun和计算结果设置信号Cnd</span><br><span class="line">  M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">  #通过W_icode知道是否为ret指令</span><br><span class="line">  W_icode == IRET           : W_valM;</span><br><span class="line">  #默认</span><br><span class="line">  <span class="number">1</span>                         : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>​        其他部分和SEQ的HCL代码类似</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#确定指令的icode</span><br><span class="line">word f_icode = [</span><br><span class="line">  imem_error : INOP;</span><br><span class="line">  <span class="number">1</span>          : imem_icode;</span><br><span class="line">];</span><br><span class="line">#确定指令的ifun</span><br><span class="line">word f_ifun = [</span><br><span class="line">  imem_error :INOP;</span><br><span class="line">  <span class="number">1</span>          : imem_ifun;</span><br><span class="line">];</span><br><span class="line">#判断指令是否合法</span><br><span class="line">bool instr_valid = f_icode in&#123;</span><br><span class="line">  INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ</span><br><span class="line">&#125;;</span><br><span class="line">#判断取指阶段的状态</span><br><span class="line">word f_stat = [</span><br><span class="line">  imem_error       : SADR;</span><br><span class="line">  !instr_valid     : SINS;</span><br><span class="line">  f_icode == IHALT : SHLT;</span><br><span class="line">  <span class="number">1</span>                : SAOK;</span><br><span class="line">];</span><br><span class="line">#判断是否需要寄存器</span><br><span class="line">bool need_regids = f_icode in &#123;</span><br><span class="line">  IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ </span><br><span class="line">&#125;;</span><br><span class="line">#判断是否包含valC</span><br><span class="line">bool need_valC = f_icode in &#123;</span><br><span class="line">  IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="译码和写回阶段-1"><a href="#译码和写回阶段-1" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594084455733-e47fefd8-f5bf-4418-a1ae-e4ce0863fcbe.jpeg" alt="image"></p>
<p>在译码阶段，比较复杂的逻辑单元与转发逻辑和合并信号相关</p>
<ul>
<li><strong>合并信号：</strong>我们可以发现只有<code>call</code>指令和条件跳转指令在后面阶段需要<code>valP</code>，前者用于压入栈中，后者用于预测错误时跳回，并且该两种指令都不需要从寄存器文件A端口读取数据，所以对于这两种指令，可以将<code>valA</code>的值设置为<code>valP</code>的值，减少流水线寄存器需要保存的信号。</li>
<li><strong>转发逻辑：</strong>由于对寄存器文件的读写不在同一阶段，所以可能会造成数据冒险，可以直接使用流水线寄存器中保存的或者每个阶段中计算出来的值，而无需要求从寄存器文件中读取。一共包含5中转发源：<code>e_valE</code>、<code>m_valM</code>、<code>M_valE</code>、<code>W_valM</code>和<code>W_valE</code>，为了保证能读取到最新指令的结果，应该设置转发源满足从左到右依次降低的优先级。</li>
</ul>
<p>由此我们可以完成译码阶段的HCL代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#设置从寄存器文件中读取的源</span><br><span class="line">word d_srcA &#x3D; [</span><br><span class="line">  D_icode in &#123;IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ&#125; : D_rA; #这些指令需要从寄存器rA中读取数据</span><br><span class="line">  D_icode in &#123;IPOPQ, IRET&#125;                    : RRSP; #需要设置栈顶指针，所以需要读取栈值</span><br><span class="line">  1                                           : RNONE;</span><br><span class="line">];</span><br><span class="line">word d_srcB &#x3D; [</span><br><span class="line">  D_icode in &#123;IOPQ, IRMMOVQ, IMRMOVQ&#125;     : D_rB; #从内存中读取时需要从寄存器中读取偏移量</span><br><span class="line">  D_icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP;</span><br><span class="line">  1                                       : RNONE;</span><br><span class="line">];</span><br><span class="line">#设置写入寄存器文件的目的</span><br><span class="line">#注意：在译码阶段并不会进行写入，只是先计算出当前指令需要的目的寄存器地址，保存到流水线寄存器中，而后在写回阶段才使用</span><br><span class="line">word d_dstE &#x3D; [</span><br><span class="line">  D_icode in &#123;IRRMOVQ, IIRMOVQ, IOPQ&#125;     : D_rB;</span><br><span class="line">  D_icode in &#123;IPUSHQ, IPOPQ, ICALL, IRET&#125; : RRSP;</span><br><span class="line">  1                                       : RNONE;</span><br><span class="line">];</span><br><span class="line">word d_dstM &#x3D; [</span><br><span class="line">  D_icode in &#123;IMRMOVQ, IPOPQ&#125; : D_rA;</span><br><span class="line">  1                           : RNONE;</span><br><span class="line">];</span><br><span class="line">#通过合并信息和转发机制设置valA的值</span><br><span class="line">word d_valA &#x3D; [</span><br><span class="line">  #合并信息</span><br><span class="line">  D_icode in &#123;ICALL, IJXX&#125; : D_valP;</span><br><span class="line">  #按照转发源的优先级设置转发源</span><br><span class="line">  d_srcA &#x3D;&#x3D; e_dstE         : e_valE;</span><br><span class="line">  d_srcA &#x3D;&#x3D; M_dstM         : m_valM;</span><br><span class="line">  d_srcA &#x3D;&#x3D; M_dstE         : M_valE;</span><br><span class="line">  d_srcA &#x3D;&#x3D; W_dstM         : W_valM;</span><br><span class="line">  d_srcA &#x3D;&#x3D; W_dstE         : W_valE;</span><br><span class="line">  #默认都是从寄存器文件中读取的</span><br><span class="line">  1                        : d_rvalA;</span><br><span class="line">];</span><br><span class="line">#通过转发机制设置valB的值</span><br><span class="line">word d_valB &#x3D; [</span><br><span class="line">  d_srcB &#x3D;&#x3D; e_dstE         : e_valE;</span><br><span class="line">  d_srcB &#x3D;&#x3D; M_dstM         : m_valM;</span><br><span class="line">  d_srcB &#x3D;&#x3D; M_dstE         : M_valE;</span><br><span class="line">  d_srcB &#x3D;&#x3D; W_dstM         : W_valM;</span><br><span class="line">  d_srcB &#x3D;&#x3D; W_dstE         : W_valE;</span><br><span class="line">  1                        : d_rvalB;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在写回阶段时，我们要写入的寄存器文件目的是<code>W_dstE</code>和<code>W_dstM</code>的值。</p>
<p>​        当指令运行到最终的写回阶段时，因为流水线寄存器中的<code>stat</code>信号表示最近完成指令的处理器状态，所以就可以用来设置处理器的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word Stat &#x3D; [</span><br><span class="line">  W_stat &#x3D;&#x3D; SBUB : SAOK; #特殊情况，当写回阶段时bubble时</span><br><span class="line">  1              : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="执行阶段-1"><a href="#执行阶段-1" class="headerlink" title="执行阶段"></a>执行阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594084741531-41fbde30-04be-4927-8e96-12120c27e4a1.jpeg" alt="image"></p>
<p>在执行阶段中和SEQ的类似，只是要注意，当前面的指令出现异常时，需要保证条件码寄存器不进行修改，对应的HCL代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool set_cc &#x3D; E_icode &#x3D;&#x3D; IOPQ &amp;&amp; #首先要保证当前指令是算数指令，才会设置CC</span><br><span class="line">  !m_stat in &#123;SADR, SINS, SHLT&#125; &amp;&amp; #保证上一条处在访存阶段的指令没有出现异常</span><br><span class="line">  !W_stat in &#123;SADR, SINS, SHLT&#125;; #保证上两条指令没有出现异常</span><br></pre></td></tr></table></figure>

<p>其他部分与SEQ的类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#设置进入ALU的值</span><br><span class="line">word aluA &#x3D; [</span><br><span class="line">  E_icode in &#123;IRRMOVQ, IOPQ&#125;             : E_valA; #直接从寄存器中读取的值</span><br><span class="line">  E_icode in &#123;IIRMOVQ, IRMMOVQ, IMRMOVQ&#125; : E_valC; #包含立即数的值</span><br><span class="line">  E_icode in &#123;ICALL, IPUSHQ&#125;             : -8; #入栈，修改栈顶指针</span><br><span class="line">  E_icode in &#123;IRET, IPOPQ&#125;               : 8; #出栈，修改栈顶指针</span><br><span class="line">];</span><br><span class="line">word aluB &#x3D; [</span><br><span class="line">  E_icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ &#125; : E_valB;</span><br><span class="line">  E_icode in &#123; IRRMOVQ, IIRMOVQ &#125;                                  : 0;</span><br><span class="line">];</span><br><span class="line">#设置ALU进行的运算</span><br><span class="line">word alufun &#x3D; [</span><br><span class="line">  E_icode &#x3D;&#x3D; IOPQ : E_ifun;</span><br><span class="line">  1               : ALUADD;</span><br><span class="line">];</span><br><span class="line">#根据ALU计算的结果设置条件转移</span><br><span class="line">word e_dstE &#x3D; [</span><br><span class="line">  E_icode &#x3D;&#x3D; IRRMOVQ &amp;&amp; !e_Cnd :RNONE; #当为寄存器之间移动时，这里时条件转移</span><br><span class="line">  1                            : E_dstE;</span><br><span class="line">];</span><br><span class="line">#call指令需要的valP保存在valA中，在访存阶段需要使用</span><br><span class="line">#并且在取指阶段，还会通过当前的M_Cnd来判断跳转指令预测是否正确，再使用M_valA返回</span><br><span class="line">#所以需要将e_val传递下去</span><br><span class="line">word e_valA &#x3D; E_valA;</span><br></pre></td></tr></table></figure>

<h3 id="访存阶段-1"><a href="#访存阶段-1" class="headerlink" title="访存阶段"></a>访存阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594084741559-09c2f277-e2d8-44bf-9a63-79b924b84923.jpeg" alt="image"></p>
<p>这部分的HCL代码和SEQ的类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#设置内存地址</span><br><span class="line">word mem_addr &#x3D; [</span><br><span class="line">  M_icode in &#123;IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ&#125; : M_valE;</span><br><span class="line">  M_icode in &#123;IPOPQ, IRET&#125;                     : M_valA;</span><br><span class="line">];</span><br><span class="line">#设置读写的控制信号</span><br><span class="line">bool mem_read &#x3D; M_icode in &#123;IMRMOVQ, IPOPQ, IRET&#125;;</span><br><span class="line">bool mem_write &#x3D; M_icode in &#123;IRMMOVQ, IPUSHQ, ICALL&#125;;</span><br><span class="line">#由于当前阶段可能出现内存地址错误，所以还需要设置状态</span><br><span class="line">word m_stat &#x3D; [</span><br><span class="line">  dmem_error :SADR;</span><br><span class="line">  1          : M_stat;</span><br><span class="line">];</span><br><span class="line">#将其他需要的值传递下去</span><br><span class="line">word w_dstE &#x3D; W_dstE;</span><br><span class="line">word w_valE &#x3D; W_valE;</span><br><span class="line">word w_dstM &#x3D; W_dstM;</span><br><span class="line">word w_valM &#x3D; W_valM;</span><br></pre></td></tr></table></figure>

<h2 id="流水线控制逻辑"><a href="#流水线控制逻辑" class="headerlink" title="流水线控制逻辑"></a>流水线控制逻辑</h2><p>​        会讨论流水线中低级机制，使得流水线控制逻辑能将指令阻塞在流水线寄存器或往流水线中插入一个气泡。并且在流水线中，还有些特殊情况是其他机制不能处理的，包括：加载/使用冒险、处理<code>ret</code>、预测错误的分支、异常等情况。</p>
<h3 id="暂停和气泡"><a href="#暂停和气泡" class="headerlink" title="暂停和气泡"></a>暂停和气泡</h3><p>​        暂停和气泡是流水线中低级的机制，<strong>暂停</strong>能将指令阻塞在某个阶段，往流水线中插入<strong>bubble</strong>能使得流水线继续运行，但是不会改变当前阶段的寄存器、内存、条件码或程序状态。这两个状态决定了当时钟电平变高时，如何修改流水线寄存器。</p>
<p>​        对于正常状态，即不是用暂停和bubble时，只要时钟电平变高，就会将流水线寄存器的状态修改为输入值，并作为新的输出。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594084926353-b5c8bed6-9a34-462f-b0f7-70ea95b08c6b.jpg" alt="image"></p>
<ul>
<li><strong>暂停</strong></li>
</ul>
<p>​        通过加入流水线寄存器，我们将指令的执行划分成了不同的阶段，并且每个阶段的输入就是流水线寄存器中的内容，所以如果我们想要将指令暂停在某个阶段时，我们可以直接将该阶段的流水线寄存器固定不变，使得该阶段的输入信息保持不变，就能在该阶段反复地执行指令，<strong>就是的指令阻塞在当前阶段了。</strong></p>
<p>​        所以将指令暂停在某个阶段，就是当时钟电平变高时，保持该阶段的流水线寄存器的状态不变。暂定都是一段全部暂停</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594084939046-df0e3b6f-a4ae-4400-8211-ef4993fe071b.jpg" alt="image"></p>
<ul>
<li><strong>bubble</strong></li>
</ul>
<p>​        当时钟电平变高时，上一阶段指令的执行结果会保存到当前阶段的流水线寄存器，执行当前阶段后就会修改程序员可见状态，当我们想要保持程序员可见状态不变，可以插入一个bubble，使得寄存器状态设置成某个固定的复位配置，得到一个等效于<code>nop</code>指令的状态，<strong>相当于取消指令的运行</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594084970263-5e4facaf-701a-4f32-9e0b-d7bf7ffb7ffa.jpg" alt="image"></p>
<h3 id="加载-使用冒险"><a href="#加载-使用冒险" class="headerlink" title="加载/使用冒险"></a>加载/使用冒险</h3><p>​        <code>mrmovq</code>和<code>popq</code>指令<code>I1</code>会从内存中读取值保存到寄存器中，但是是在访存阶段才会读取到内存的值，所以如果下一条指令<code>I2</code>会读取这个寄存器的值，就会出现加载/使用冒险，因为当<code>I2</code>处于译码阶段读取寄存器值时，<code>I1</code>还是处于执行阶段，所以无法读取到内存的值。</p>
<p>​        <strong>理想处理方式</strong>为：固定流水线寄存器D和F，使得指令<code>I2</code>和下一条指令<code>I3</code>能分别阻塞在译码阶段和取指阶段，然后在译码阶段后面插入一个时钟周期的bubble，使得<code>I1</code>和前面的指令可以继续向后执行一个时钟周期，则<code>I1</code>此时处于访存阶段，就能读取到内存的值了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085096048-06e4bd6a-3662-4f53-8a16-c91f2dc4fc92.png" alt="image"></p>
<p>​        所以当触发了加载/使用冒险时，流水线寄存器会如下设置一个时钟周期</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085096050-9032c291-4c70-483c-9ba8-273eaa3a25d0.png" alt="image"></p>
<h3 id="处理ret指令"><a href="#处理ret指令" class="headerlink" title="处理ret指令"></a>处理ret指令</h3><p>​        执行<code>ret</code>指令时，会从栈中读取返回地址作为下一条指令的地址，所以当<code>ret</code>执行到访存阶段时，才能读取到下一条指令的地址，然后在写回阶段的时钟电路变成高电平时，才会将其写入流水线寄存器M中，然后将<code>M_valM</code>传回去到<code>Select PC</code>逻辑模块。<strong>触发条件</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRET in &#123;D_icode, E_icode, M_icode&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>理想处理方式</strong>为：当<code>ret</code>执行到译码阶段时，会触发触发条件，此时就固定流水线寄存器F，就能保持不断读取下一条指令<code>I2</code>，并且后面在译码阶段插入3个时钟周期的bubble（根据取指阶段的HCL，会不断执行<code>valP</code>的错误指令，但是通过插入bubble，使得它只能执行到取指阶段），使得<code>ret</code>指令能向后执行3个时钟周期到达写回阶段，此时就能直接通过<code>W_valM</code>获得下一个PC的地址。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594085361782-cc511581-3468-4348-b28d-45d86ea557c4.jpeg" alt="image"></p>
<p>​        所以当触发了<code>ret</code>指令时，流水线寄存器会如下设置3个时钟周期</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085361778-a0dcd3f3-7435-4db2-8941-3d2184b6c46d.png" alt="image"></p>
<h3 id="预测错误的分支"><a href="#预测错误的分支" class="headerlink" title="预测错误的分支"></a>预测错误的分支</h3><p>​        我们采用AT分支预测策略，所以当遇到条件分支指令<code>I1</code>时，会直接跳转到对应的地址开始执行，只有当<code>I1</code>执行到执行阶段时，才能通过<code>e_Cnd</code>判断是否发生跳转，此时已经执行了后续的两个指令<code>I2</code>和<code>I3</code>，分别处于译码阶段和取指阶段。预测错误的<strong>触发条件</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E_icode &#x3D;&#x3D; IJXX &amp;&amp; !e_Cnd</span><br></pre></td></tr></table></figure>

<p>​        当出现预测错误时，说明我们并不需要执行已经执行了的<code>I2</code>和<code>I3</code>指令，<strong>理想的处理方式</strong>为：直接在译码阶段插入bubbl中断<code>I3</code>，在执行阶段插入bubble中断<code>I2</code>，然后将正确的指令放入取指阶段开始执行，所以分支预测错误最多损耗两个时钟周期。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594085574182-000819b3-0465-4061-a83a-a8ce48f766cd.jpeg" alt="image"></p>
<p>​        所以当触发了预测错误的分支时，流水线寄存器就会如下设置一个时钟周期</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1413496/1594085574189-abfbe31c-89ff-460f-886e-3b8ab5cada28.png" alt="image"></p>
<h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3><p>​        当出现<code>halt</code>指令、错误的指令码和函数码组合的指令或内存地址错误时，就会出现异常，所以异常通常在取指阶段和访存阶段被发现，对于异常<strong>理想的处理方式</strong>为：异常指令之前的指令都能完成，之后的指令都不会修改程序员可见状态，异常指令到达写回阶段时停止执行。</p>
<p>​        但是存在以下<strong>困难：</strong>异常在取指阶段和访存阶段被发现，程序员可见状态在执行阶段、访存阶段和写回阶段被修改。</p>
<p>​        我们首先在所有阶段的流水线寄存器中都包含一个程序状态信号<code>stat</code>，即使出现了异常，也只是将其当做普通信号传到下一阶段。当异常指令到达访存阶段时，后续的三条指令分别处于执行阶段、译码阶段和取指阶段，只有处于执行阶段的指令会修改条件码寄存器，所以要禁止执行阶段中的指令设置条件码。并且在访存阶段插入bubble，使得异常指令执行到写回阶段时，下一条指令就阻塞在执行阶段，不会到达访存阶段来修改内存。由于流水线处理器是按顺序处理指令的，所以第一次在写回阶段检测到异常指令就是最新的异常，所以只要在写回阶段检测到异常指令，就暂停写回，并暂停流水线。</p>
<p><strong>触发条件</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_stat in &#123;SADR, SINS, SHLT&#125; || W_stat in &#123;SADR, SINS, SHLT&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊情况组合"><a href="#特殊情况组合" class="headerlink" title="特殊情况组合"></a>特殊情况组合</h3><p>​        以上讨论都假设了一个时钟周期只发生一种特殊情况，我们还需要讨论在一个时钟周期中是否可能发生同时出现多个特殊情况。</p>
<p>​        下图为出现各种特殊情况是流水线寄存器的情况，我们可以大多数情况中特殊情况的触发条件都是互斥的，但是有两种组合可能会出现。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594085954302-1299dcdc-7522-4144-806d-add0cf901af1.jpg" alt="image"></p>
<ul>
<li><strong>组合A：</strong>所以预测错误可能和<code>ret1</code>同时出现。</li>
</ul>
<p>​        当执行阶段为条件分支，而译码阶段为<code>ret</code>时，由于预测分支采用了AT策略，说明<code>ret</code>指令是条件分支跳转后的第一条指令。此时由于预测错误，说明我们不应该执行<code>ret</code>指令，则理想的处理方式是对执行阶段插入bubble来取消<code>ret</code>的执行。并且当预测错误时，PC选择逻辑会选择<code>E_valA</code>，所以不用考虑流水线寄存器F采取的动作。</p>
<p>​        我们组合两种特殊情况的流水线控制动作，可以发现在E中使用了bubble符合理想的处理方式，并且在取指阶段使用暂停不会造成影响。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594086098481-df94d89b-2319-49e4-b5f3-d4ad1b671ff7.jpg" alt="image"></p>
<ul>
<li><strong>组合B：</strong>加载/使用冒险和<code>ret1</code>的组合</li>
</ul>
<p>​        <code>ret</code>指令在译码阶段会读取<code>%rsp</code>的值，如果我们上一条指令是从内存中读取值来设置<code>%rsp</code>，则会出现加载/使用冒险和<code>ret1</code>的组合。</p>
<p>​        我们需要优先保证处理加载/使用冒险，来对<code>%rsp</code>进行设置，然后再处理<code>ret</code>指令，所以需要将<code>ret</code>指令阻塞在译码阶段，所以对流水线寄存器D需要使用暂停。我们组合两种特殊情况的流水线控制动作</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1413496/1594086147771-a80b4f4a-545a-47da-9e5e-18a762a3fd8f.jpg" alt="image"></p>
<h3 id="流水线逻辑的HCL代码"><a href="#流水线逻辑的HCL代码" class="headerlink" title="流水线逻辑的HCL代码"></a>流水线逻辑的HCL代码</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594086195581-996f40ce-809c-4e9b-9af3-e76a8e3eaecf.jpeg" alt="image"></p>
<p>​        如上图所示是流水线控制逻辑的整体结构，我们依次来说明对应的HCL代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#取指阶段</span><br><span class="line">##是否对F进行暂停</span><br><span class="line">bool F_stall &#x3D; </span><br><span class="line">  #出现加载&#x2F;使用冒险时</span><br><span class="line">  E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125; || #加载&#x2F;使用冒险的触发条件</span><br><span class="line">  #出现ret指令时</span><br><span class="line">  IRET in &#123;D_icode, E_icode, M_icode&#125;; #ret的触发条件</span><br><span class="line">##F是不会插入bubble的</span><br><span class="line">bool F_bubble &#x3D; 0;</span><br><span class="line">#译码阶段</span><br><span class="line">##是否对D进行暂停</span><br><span class="line">bool D_stall &#x3D; </span><br><span class="line">  #出现加载&#x2F;使用冒险时</span><br><span class="line">  E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125;;</span><br><span class="line">##是否对D插入bubble</span><br><span class="line">bool D_bubble &#x3D; </span><br><span class="line">  #出现预测错误时</span><br><span class="line">  (E_icode &#x3D;&#x3D; IJXX &amp;&amp; !e_Cnd) || #预测错误的触发条件</span><br><span class="line">  #出现了ret，但是没有出现加载&#x2F;使用冒险，（组合B）</span><br><span class="line">  !(E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125;) &amp;&amp;</span><br><span class="line">  IRET in &#123;D_icode, E_icode, M_icode&#125;;</span><br><span class="line">#执行阶段</span><br><span class="line">##因为没有特殊情况对E进行暂停，所以直接为0</span><br><span class="line">bool E_stall &#x3D; 0;</span><br><span class="line">##是否对E插入bubble</span><br><span class="line">bool E_bubble &#x3D; </span><br><span class="line">  #出现预测错误时</span><br><span class="line">  (E_icode &#x3D;&#x3D; IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">  #出现加载&#x2F;使用冒险时</span><br><span class="line">  E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125;;</span><br><span class="line">##当出现异常时，我们需确保后续指令不会对条件码寄存器进行修改</span><br><span class="line">bool set_cc &#x3D; E_icode &#x3D;&#x3D; IOPQ &amp;&amp; #首先要保证当前指令是算数指令，才会设置CC</span><br><span class="line">  !m_stat in &#123;SADR, SINS, SHLT&#125; &amp;&amp; #保证上一条处在访存阶段的指令没有出现异常</span><br><span class="line">  !W_stat in &#123;SADR, SINS, SHLT&#125;; #保证上两条指令没有出现异常</span><br><span class="line">#访存阶段</span><br><span class="line">##没有指令会在访存阶段进行暂停</span><br><span class="line">bool M_stall &#x3D; 0;</span><br><span class="line">##当之前的指令出现异常时，我们需要插入bubble来取消指令，防止对内存进行修改</span><br><span class="line">bool M_bubble &#x3D; m_stat in &#123;SADR, SINS, SHLT&#125; || W_stat in &#123;SADR, SINS, SHLT&#125;;</span><br><span class="line">#写回阶段</span><br><span class="line">#没有指令会插入bubble</span><br><span class="line">bool W_bubble &#x3D; 0;</span><br><span class="line">#当出现异常时，会在写回阶段暂停</span><br><span class="line">bool W_stall &#x3D; W_stat in &#123;SADR, SINS, SHLT&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>​        我们通过计算PIPE执行一条指令所需的平均时钟周期来衡量系统的性能，该指标为<strong>CPI（Cycles Per Instruction）</strong>。而影响该指标的因素是流水线中插入bubble的数目，因为插入bubble时就会损失一个流水线周期。</p>
<p>​        我们可以在处理器中运行某个基准程序，然后统计执行阶段中运行的指令数 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232374-d3618b7b-2aa8-4721-8ddd-03c30a05dc04.svg" alt="image"> 和bubble数 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232387-3f0fc473-5c71-4329-9b30-955ca7808af1.svg" alt="image"> ，就得到对应的CPI指标</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232442-c5f92a86-5f5c-4b3e-bf25-d3d526a3c835.svg" alt="image"></p>
<p>​        由于只有三种特殊请款（加载/使用冒险、预测错误、<code>ret</code>指令）会插入bubble，所以我们可以将惩罚项 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232435-b2eb5867-663b-4ff1-84c4-1252628feec8.svg" alt="image"> 分为三部分，<code>lp</code>表示加载/使用冒险插入bubble的平均数，<code>mp</code>表示预测错误插入bubble的平均数，<code>rp</code>表示<code>ret</code>指令插入bubble的平均数，则CPI可变为</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/1413496/1594086232446-af49e018-dbf6-42da-ac6c-11e1e1808a98.svg" alt="image"></p>
<p>​        我们可以根据指令出现的频率以及出现特殊情况的频率对CPI进行计算</p>
<ul>
<li><code>mrmovq</code>和<code>popq</code>占所有执行指令的25%，其中20%会导致加载/使用冒险</li>
<li>条件分支指令栈所有执行指令的20%，使用AT策略会有60%的成功率</li>
<li><code>ret</code>指令栈所有执行指令的2%</li>
</ul>
<p>​        由此我们可以得到三种特殊情况的惩罚</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1413496/1594086232420-8ced6e79-dc1f-4634-87fb-8566c3a3e320.jpeg" alt="image"></p>
<h2 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h2><h3 id="多周期指令"><a href="#多周期指令" class="headerlink" title="多周期指令"></a>多周期指令</h3><p>​        我们提供的Y86-64指令集只有简单的操作，在执行阶段都能在一个时钟周期内完成，但是如果要实现整数乘法和除法以及浮点数运算，我们首先要增加额外的硬件来执行这些计算，并且这些指令在执行阶段通常都需要多个时钟周期才能完成，所以执行这些指令时，我们需要平衡流水线各个部分之间的关系。</p>
<p>​        实现多周期指令的简单方法是直接暂停取指阶段和译码阶段，直到执行阶段执行了所需的时钟周期后才恢复，这种方法的性能通常比较差。</p>
<p>​        常见的方法是使用独立于主流水线的特殊硬件功能单元来处理复杂的操作，通常会有一个功能单位来处理整数乘法和除法，还有一个功能单位来处理浮点数运算。在译码阶段中遇到多周期指令时，就可以将其发射到对应的功能单元进行运算，而主流水线会继续执行其他指令，使得多周期指令和其他指令能在功能单元和主流水线中并发执行。但是如果不同功能单元以及主流水线的指令存在数据相关时，就需要暂停系统的某部分来解决数据冒险。也同样可以使用暂停、转发以及流水线控制。</p>
<h3 id="与存储系统接口的关系"><a href="#与存储系统接口的关系" class="headerlink" title="与存储系统接口的关系"></a>与存储系统接口的关系</h3><p>​        我们假设了取指单元和数据内存都能在一个时钟周期内读写内存中的任意位置，但是实际上并不是。</p>
<ol>
<li>处理器的存储系统是由多种硬件存储器和管理虚拟内存的操作系统共同组成的，而存储系统包含层次结构，最靠近处理器的一层是<strong>高速缓存（Cache）存储器</strong>，能够提供对最常使用的存储器位置的快速访问。典型系统中包含一个用于读指令的cache和一个用于读写数据的cache，并且还有一个<strong>翻译后备缓冲器（Translation Look-aside Buffer，TLB）</strong>来提供从虚拟地址到物理地址的快速翻译。将TLB和cache结合起来，大多数时候能再一个时钟周期内读指令并读写数据。</li>
<li>当我们想要的引用位置不在cache中时，则出现高速缓存<strong>不命中（Miss）</strong>，则流水线会将指令暂停在取指阶段或访存阶段，然后从较高层次的cache或处理器的内存中找到不命中的数据，然后将其保存到cache中，就能恢复指令的运行。这通常需要3~20个时钟周期。</li>
<li>如果我们没有从较高层次的cache或处理器的内存中找到不命中的数据，则需要从磁盘存储器中寻找。硬件会先产生一个<strong>缺页（Page Fault）</strong>异常信号，然后调用操作系统的异常处理程序代码，则操作系统会发起一个从磁盘到主存的传送操作，完成后操作系统会返回原来的程序，然后重新执行导致缺页异常的指令。其中访问磁盘需要数百万个时钟周期，操作系统的缺页中断处理程序需要数百个时钟周期。</li>
</ol>
<h3 id="当前的微处理器设计"><a href="#当前的微处理器设计" class="headerlink" title="当前的微处理器设计"></a>当前的微处理器设计</h3><p>​        我们采用的五阶段流水线设计，吞吐量都现在最多一个时钟周期执行一条指令，CPI测量值不可能小于1.0。较新的处理器支持<strong>超标量（Superscalar）</strong>操作，能够在取值、译码和执行阶段并行处理多条指令，使得CPI测量值小于1.0，通常会使用IPC（每个周期执行的指令数）来测量性能。更新的处理器会支持<strong>乱序（Out-of-order）</strong>技术，对指令执行顺序进行打乱来并行执行多条指令。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">不想画CAD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://levnzzz.github.io/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8/csapp-4/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/">https://levnzzz.github.io/第四章-设立自己的处理器/csapp-4/细读经典/《CSAPP》/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://levnzzz.github.io" target="_blank">OnePiece</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CSAPP/">CSAPP</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/10/17/Z63WiowRkJdsO1K.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/cpu%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/408-1/uncategorized/"><img class="prev-cover" src="https://i.loli.net/2020/10/18/aAVc5XrJoiudfCH.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPU的两种设计方式</div></div></a></div><div class="next-post pull-right"><a href="/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/csapp-3/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/%E3%80%8ACSAPP%E3%80%8B/"><img class="next-cover" src="https://i.loli.net/2020/10/17/Z63WiowRkJdsO1K.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第三章 程序的机器级表示</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/第三章-程序的机器级表示/csapp-3/细读经典/《CSAPP》/" title="第三章 程序的机器级表示"><img class="cover" src="https://i.loli.net/2020/10/17/Z63WiowRkJdsO1K.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-15</div><div class="title">第三章 程序的机器级表示</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 不想画CAD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Forever Youthful Forever Weeping</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }

    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>